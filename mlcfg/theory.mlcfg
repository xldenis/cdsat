module Type
  use Ref
  use mach.int.Int
  use prelude.Int8
  use prelude.Int16
  use mach.int.Int32
  use mach.int.Int64
  use prelude.UInt8
  use prelude.UInt16
  use mach.int.UInt32
  use mach.int.UInt64
  use string.Char
  use floating_point.Single
  use floating_point.Double
  use seq.Seq
  use set.Set
  use set.Fset
  use map.Map
  use prelude.Prelude
  type core_ptr_nonnull_nonnull 't =
    | Core_Ptr_NonNull_NonNull opaque_ptr
    
  type core_marker_phantomdata 't =
    | Core_Marker_PhantomData
    
  type core_ptr_unique_unique 't =
    | Core_Ptr_Unique_Unique (core_ptr_nonnull_nonnull 't) (core_marker_phantomdata 't)
    
  type alloc_rawvec_rawvec 't 'a =
    | Alloc_RawVec_RawVec (core_ptr_unique_unique 't) usize 'a
    
  type alloc_vec_vec 't 'a =
    | Alloc_Vec_Vec (alloc_rawvec_rawvec 't 'a) usize
    
  type cdsat_trail_sort  =
    | Cdsat_Trail_Sort_Boolean
    | Cdsat_Trail_Sort_Rational
    
  type cdsat_trail_value  =
    | Cdsat_Trail_Value_Bool bool
    | Cdsat_Trail_Value_Rat uint64
    
  let function cdsat_trail_value_Rat_0 (self : cdsat_trail_value) : uint64 = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | Cdsat_Trail_Value_Bool _ -> any uint64
      | Cdsat_Trail_Value_Rat a -> a
      end
  let function cdsat_trail_value_Bool_0 (self : cdsat_trail_value) : bool = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | Cdsat_Trail_Value_Bool a -> a
      | Cdsat_Trail_Value_Rat _ -> any bool
      end
  type cdsat_trail_term  =
    | Cdsat_Trail_Term_Variable usize (cdsat_trail_sort)
    | Cdsat_Trail_Term_Value (cdsat_trail_value)
    | Cdsat_Trail_Term_Plus (cdsat_trail_term) (cdsat_trail_term)
    | Cdsat_Trail_Term_Eq (cdsat_trail_term) (cdsat_trail_term)
    | Cdsat_Trail_Term_Conj (cdsat_trail_term) (cdsat_trail_term)
    
  let function cdsat_trail_term_Conj_0 (self : cdsat_trail_term) : cdsat_trail_term = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | Cdsat_Trail_Term_Variable _ _ -> any cdsat_trail_term
      | Cdsat_Trail_Term_Value _ -> any cdsat_trail_term
      | Cdsat_Trail_Term_Plus _ _ -> any cdsat_trail_term
      | Cdsat_Trail_Term_Eq _ _ -> any cdsat_trail_term
      | Cdsat_Trail_Term_Conj a _ -> a
      end
  let function cdsat_trail_term_Conj_1 (self : cdsat_trail_term) : cdsat_trail_term = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | Cdsat_Trail_Term_Variable _ _ -> any cdsat_trail_term
      | Cdsat_Trail_Term_Value _ -> any cdsat_trail_term
      | Cdsat_Trail_Term_Plus _ _ -> any cdsat_trail_term
      | Cdsat_Trail_Term_Eq _ _ -> any cdsat_trail_term
      | Cdsat_Trail_Term_Conj _ a -> a
      end
  let function cdsat_trail_term_Eq_0 (self : cdsat_trail_term) : cdsat_trail_term = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | Cdsat_Trail_Term_Variable _ _ -> any cdsat_trail_term
      | Cdsat_Trail_Term_Value _ -> any cdsat_trail_term
      | Cdsat_Trail_Term_Plus _ _ -> any cdsat_trail_term
      | Cdsat_Trail_Term_Eq a _ -> a
      | Cdsat_Trail_Term_Conj _ _ -> any cdsat_trail_term
      end
  let function cdsat_trail_term_Eq_1 (self : cdsat_trail_term) : cdsat_trail_term = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | Cdsat_Trail_Term_Variable _ _ -> any cdsat_trail_term
      | Cdsat_Trail_Term_Value _ -> any cdsat_trail_term
      | Cdsat_Trail_Term_Plus _ _ -> any cdsat_trail_term
      | Cdsat_Trail_Term_Eq _ a -> a
      | Cdsat_Trail_Term_Conj _ _ -> any cdsat_trail_term
      end
  let function cdsat_trail_term_Plus_0 (self : cdsat_trail_term) : cdsat_trail_term = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | Cdsat_Trail_Term_Variable _ _ -> any cdsat_trail_term
      | Cdsat_Trail_Term_Value _ -> any cdsat_trail_term
      | Cdsat_Trail_Term_Plus a _ -> a
      | Cdsat_Trail_Term_Eq _ _ -> any cdsat_trail_term
      | Cdsat_Trail_Term_Conj _ _ -> any cdsat_trail_term
      end
  let function cdsat_trail_term_Plus_1 (self : cdsat_trail_term) : cdsat_trail_term = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | Cdsat_Trail_Term_Variable _ _ -> any cdsat_trail_term
      | Cdsat_Trail_Term_Value _ -> any cdsat_trail_term
      | Cdsat_Trail_Term_Plus _ a -> a
      | Cdsat_Trail_Term_Eq _ _ -> any cdsat_trail_term
      | Cdsat_Trail_Term_Conj _ _ -> any cdsat_trail_term
      end
  let function cdsat_trail_term_Value_0 (self : cdsat_trail_term) : cdsat_trail_value = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | Cdsat_Trail_Term_Variable _ _ -> any cdsat_trail_value
      | Cdsat_Trail_Term_Value a -> a
      | Cdsat_Trail_Term_Plus _ _ -> any cdsat_trail_value
      | Cdsat_Trail_Term_Eq _ _ -> any cdsat_trail_value
      | Cdsat_Trail_Term_Conj _ _ -> any cdsat_trail_value
      end
  let function cdsat_trail_term_Variable_0 (self : cdsat_trail_term) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | Cdsat_Trail_Term_Variable a _ -> a
      | Cdsat_Trail_Term_Value _ -> any usize
      | Cdsat_Trail_Term_Plus _ _ -> any usize
      | Cdsat_Trail_Term_Eq _ _ -> any usize
      | Cdsat_Trail_Term_Conj _ _ -> any usize
      end
  let function cdsat_trail_term_Variable_1 (self : cdsat_trail_term) : cdsat_trail_sort
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | Cdsat_Trail_Term_Variable _ a -> a
      | Cdsat_Trail_Term_Value _ -> any cdsat_trail_sort
      | Cdsat_Trail_Term_Plus _ _ -> any cdsat_trail_sort
      | Cdsat_Trail_Term_Eq _ _ -> any cdsat_trail_sort
      | Cdsat_Trail_Term_Conj _ _ -> any cdsat_trail_sort
      end
  type alloc_alloc_global  =
    | Alloc_Alloc_Global
    
  type cdsat_trail_reason  =
    | Cdsat_Trail_Reason_Justified (alloc_vec_vec usize (alloc_alloc_global))
    | Cdsat_Trail_Reason_Decision
    | Cdsat_Trail_Reason_Input
    
  let function cdsat_trail_reason_Justified_0 (self : cdsat_trail_reason) : alloc_vec_vec usize (alloc_alloc_global)
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | Cdsat_Trail_Reason_Justified a -> a
      | Cdsat_Trail_Reason_Decision -> any alloc_vec_vec usize (alloc_alloc_global)
      | Cdsat_Trail_Reason_Input -> any alloc_vec_vec usize (alloc_alloc_global)
      end
  type cdsat_trail_assignment  =
    | Cdsat_Trail_Assignment (cdsat_trail_term) (cdsat_trail_value) (cdsat_trail_reason) usize
    
  let function cdsat_trail_assignment_Assignment_term (self : cdsat_trail_assignment) : cdsat_trail_term
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | Cdsat_Trail_Assignment a _ _ _ -> a
      end
  let function cdsat_trail_assignment_Assignment_reason (self : cdsat_trail_assignment) : cdsat_trail_reason
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | Cdsat_Trail_Assignment _ _ a _ -> a
      end
  let function cdsat_trail_assignment_Assignment_val (self : cdsat_trail_assignment) : cdsat_trail_value
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | Cdsat_Trail_Assignment _ a _ _ -> a
      end
  let function cdsat_trail_assignment_Assignment_level (self : cdsat_trail_assignment) : usize
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | Cdsat_Trail_Assignment _ _ _ a -> a
      end
  type cdsat_theory_sort  =
    | Cdsat_Theory_Sort_Rational
    | Cdsat_Theory_Sort_Boolean
    
  type cdsat_theory_var  =
    | Cdsat_Theory_Var int (cdsat_theory_sort)
    
  let function cdsat_theory_var_Var_1 (self : cdsat_theory_var) : cdsat_theory_sort = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | Cdsat_Theory_Var _ a -> a
      end
  type cdsat_theory_value  =
    | Cdsat_Theory_Value_Bool bool
    | Cdsat_Theory_Value_Rat int
    
  type cdsat_theory_term  =
    | Cdsat_Theory_Term_Variable (cdsat_theory_var)
    | Cdsat_Theory_Term_Value (cdsat_theory_value)
    | Cdsat_Theory_Term_Plus (cdsat_theory_term) (cdsat_theory_term)
    | Cdsat_Theory_Term_Eq (cdsat_theory_term) (cdsat_theory_term)
    | Cdsat_Theory_Term_Conj (cdsat_theory_term) (cdsat_theory_term)
    
  type cdsat_theory_assign  =
    | Cdsat_Theory_Assign_Decision (cdsat_theory_term) (cdsat_theory_value)
    | Cdsat_Theory_Assign_Justified (Fset.fset (cdsat_theory_term, cdsat_theory_value)) (cdsat_theory_term) (cdsat_theory_value)
    | Cdsat_Theory_Assign_Input (cdsat_theory_term) (cdsat_theory_value)
    
  type cdsat_theory_trail  =
    | Cdsat_Theory_Trail_Empty
    | Cdsat_Theory_Trail_Assign (cdsat_theory_assign) int (cdsat_theory_trail)
    
  type cdsat_trail_trail  =
    | Cdsat_Trail_Trail (alloc_vec_vec (cdsat_trail_assignment) (alloc_alloc_global)) usize (ghost cdsat_theory_trail)
    
  let function cdsat_trail_trail_Trail_level (self : cdsat_trail_trail) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | Cdsat_Trail_Trail _ a _ -> a
      end
  let function cdsat_trail_trail_Trail_assignments (self : cdsat_trail_trail) : alloc_vec_vec (cdsat_trail_assignment) (alloc_alloc_global)
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | Cdsat_Trail_Trail a _ _ -> a
      end
  let ghost function cdsat_trail_trail_Trail_ghost (self : cdsat_trail_trail) : cdsat_theory_trail
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | Cdsat_Trail_Trail _ _ a -> a
      end
  type core_option_option 't =
    | Core_Option_Option_None
    | Core_Option_Option_Some 't
    
  let function core_option_option_Some_0 (self : core_option_option 't) : 't = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | Core_Option_Option_None -> any 't
      | Core_Option_Option_Some a -> a
      end
  type cdsat_trail_reasonmodel  =
    | Cdsat_Trail_ReasonModel_Justified (Seq.seq usize)
    | Cdsat_Trail_ReasonModel_Decision
    | Cdsat_Trail_ReasonModel_Input
    
  type cdsat_theory_model  =
    | Cdsat_Theory_Model (Map.map (cdsat_theory_var) (cdsat_theory_value))
    
  let function cdsat_theory_model_Model_0 (self : cdsat_theory_model) : Map.map (cdsat_theory_var) (cdsat_theory_value)
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | Cdsat_Theory_Model a -> a
      end
  type cdsat_concrete_answer  =
    | Cdsat_Concrete_Answer_Sat
    | Cdsat_Concrete_Answer_Unsat
    | Cdsat_Concrete_Answer_Unknown
    
  type cdsat_concrete_booltheory  =
    | Cdsat_Concrete_BoolTheory
    
  type cdsat_concrete_solver  =
    | Cdsat_Concrete_Solver (cdsat_concrete_booltheory)
    
  let function cdsat_concrete_solver_Solver_bool_th (self : cdsat_concrete_solver) : cdsat_concrete_booltheory
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | Cdsat_Concrete_Solver a -> a
      end
  type cdsat_theory_normal  =
    | Cdsat_Theory_Normal (cdsat_theory_trail)
    
  let function cdsat_theory_normal_Normal_0 (self : cdsat_theory_normal) : cdsat_theory_trail
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | Cdsat_Theory_Normal a -> a
      end
  type cdsat_concrete_extendresult  =
    | Cdsat_Concrete_ExtendResult_Conflict (alloc_vec_vec usize (alloc_alloc_global))
    | Cdsat_Concrete_ExtendResult_Decision (cdsat_trail_term) (cdsat_trail_value)
    | Cdsat_Concrete_ExtendResult_Satisfied
    
  let function cdsat_concrete_extendresult_Decision_0 (self : cdsat_concrete_extendresult) : cdsat_trail_term
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | Cdsat_Concrete_ExtendResult_Conflict _ -> any cdsat_trail_term
      | Cdsat_Concrete_ExtendResult_Decision a _ -> a
      | Cdsat_Concrete_ExtendResult_Satisfied -> any cdsat_trail_term
      end
  let function cdsat_concrete_extendresult_Decision_1 (self : cdsat_concrete_extendresult) : cdsat_trail_value
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | Cdsat_Concrete_ExtendResult_Conflict _ -> any cdsat_trail_value
      | Cdsat_Concrete_ExtendResult_Decision _ a -> a
      | Cdsat_Concrete_ExtendResult_Satisfied -> any cdsat_trail_value
      end
  let function cdsat_concrete_extendresult_Conflict_0 (self : cdsat_concrete_extendresult) : alloc_vec_vec usize (alloc_alloc_global)
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | Cdsat_Concrete_ExtendResult_Conflict a -> a
      | Cdsat_Concrete_ExtendResult_Decision _ _ -> any alloc_vec_vec usize (alloc_alloc_global)
      | Cdsat_Concrete_ExtendResult_Satisfied -> any alloc_vec_vec usize (alloc_alloc_global)
      end
  type core_mem_manuallydrop_manuallydrop 't =
    | Core_Mem_ManuallyDrop_ManuallyDrop 't
    
  type alloc_vec_intoiter_intoiter 't 'a =
    | Alloc_Vec_IntoIter_IntoIter (core_ptr_nonnull_nonnull 't) (core_marker_phantomdata 't) usize (core_mem_manuallydrop_manuallydrop 'a) opaque_ptr opaque_ptr
    
  type cdsat_concrete_conflictheap
  type cdsat_theory_conflict  =
    | Cdsat_Theory_Conflict (cdsat_theory_trail) (Fset.fset (cdsat_theory_term, cdsat_theory_value))
    
  let function cdsat_theory_conflict_Conflict_0 (self : cdsat_theory_conflict) : cdsat_theory_trail
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | Cdsat_Theory_Conflict a _ -> a
      end
  let function cdsat_theory_conflict_Conflict_1 (self : cdsat_theory_conflict) : Fset.fset (cdsat_theory_term, cdsat_theory_value)
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | Cdsat_Theory_Conflict _ a -> a
      end
  type core_slice_iter_iter 't =
    | Core_Slice_Iter_Iter (core_ptr_nonnull_nonnull 't) opaque_ptr (core_marker_phantomdata 't)
    
  type cdsat_concrete_theorystate  =
    | Cdsat_Concrete_TheoryState_Sat
    | Cdsat_Concrete_TheoryState_Decision (cdsat_trail_term) (cdsat_trail_value)
    | Cdsat_Concrete_TheoryState_Unknown
    
  let function cdsat_concrete_theorystate_Decision_0 (self : cdsat_concrete_theorystate) : cdsat_trail_term
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | Cdsat_Concrete_TheoryState_Sat -> any cdsat_trail_term
      | Cdsat_Concrete_TheoryState_Decision a _ -> a
      | Cdsat_Concrete_TheoryState_Unknown -> any cdsat_trail_term
      end
  let function cdsat_concrete_theorystate_Decision_1 (self : cdsat_concrete_theorystate) : cdsat_trail_value
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | Cdsat_Concrete_TheoryState_Sat -> any cdsat_trail_value
      | Cdsat_Concrete_TheoryState_Decision _ a -> a
      | Cdsat_Concrete_TheoryState_Unknown -> any cdsat_trail_value
      end
  type core_result_result 't 'e =
    | Core_Result_Result_Ok 't
    | Core_Result_Result_Err 'e
    
  type cdsat_trail_assignmentmodel  =
    | Cdsat_Trail_AssignmentModel (cdsat_theory_term) (cdsat_theory_value) (cdsat_trail_reasonmodel) int
    
end
module Cdsat_Trail_Impl6_Level_Interface
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  val level [@cfg:stackify] (self : Type.cdsat_trail_trail) : usize
end
module CreusotContracts_Std1_Vec_Impl0_Model_Interface
  type t
  type a
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use Type
  function model (self : Type.alloc_vec_vec t a) : Seq.seq t
end
module CreusotContracts_Std1_Vec_Impl0_Model
  type t
  type a
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use Type
  function model (self : Type.alloc_vec_vec t a) : Seq.seq t
  axiom model_spec : forall self : Type.alloc_vec_vec t a . Seq.length (model self) <= 18446744073709551615
end
module CreusotContracts_Std1_Vec_Impl0
  type t
  type a
end
module Alloc_Vec_Impl1_Len_Interface
  type t
  type a
  use mach.int.UInt64
  use seq.Seq
  use prelude.Prelude
  use Type
  use mach.int.Int
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = t, type a = a, axiom .
  val len [@cfg:stackify] (self : Type.alloc_vec_vec t a) : usize
    ensures { UInt64.to_int result = Seq.length (Model0.model self) }
    
end
module Cdsat_Trail_Impl6_Len_Interface
  use mach.int.UInt64
  use seq.Seq
  use prelude.Prelude
  use Type
  use mach.int.Int
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.cdsat_trail_assignment,
  type a = Type.alloc_alloc_global, axiom .
  val len [@cfg:stackify] (self : Type.cdsat_trail_trail) : usize
    ensures { [#"/Users/xavier/Code/cdsat/src/trail.rs" 189 14 189 50] UInt64.to_int result = Seq.length (Model0.model (Type.cdsat_trail_trail_Trail_assignments self)) }
    
end
module CreusotContracts_Logic_Model_Model_ModelTy
  type self
  type modelTy
end
module CreusotContracts_Std1_Slice_SliceIndexSpec_InBounds_Interface
  type self
  type t
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy0 with type self = t
  predicate in_bounds (self : self) (seq : ModelTy0.modelTy)
end
module CreusotContracts_Std1_Slice_SliceIndexSpec_InBounds
  type self
  type t
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy0 with type self = t
  predicate in_bounds (self : self) (seq : ModelTy0.modelTy)
end
module Core_Slice_Index_SliceIndex_Output
  type self
  type t
  type output
end
module CreusotContracts_Std1_Slice_SliceIndexSpec_HasValue_Interface
  type self
  type t
  clone Core_Slice_Index_SliceIndex_Output as Output0 with type self = self, type t = t
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy0 with type self = t
  predicate has_value (self : self) (seq : ModelTy0.modelTy) (out : Output0.output)
end
module CreusotContracts_Std1_Slice_SliceIndexSpec_HasValue
  type self
  type t
  clone Core_Slice_Index_SliceIndex_Output as Output0 with type self = self, type t = t
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy0 with type self = t
  predicate has_value (self : self) (seq : ModelTy0.modelTy) (out : Output0.output)
end
module CreusotContracts_Std1_Slice_Impl0_ModelTy
  type t
  use seq.Seq
  type modelTy  =
    Seq.seq t
end
module Alloc_Vec_Impl16_Index_Interface
  type t
  type i
  type a
  use prelude.Prelude
  use Type
  use seq.Seq
  clone CreusotContracts_Std1_Slice_Impl0_ModelTy as ModelTy0 with type t = t
  clone Core_Slice_Index_SliceIndex_Output as Output0 with type self = i, type t = seq t
  clone CreusotContracts_Std1_Slice_SliceIndexSpec_HasValue_Interface as HasValue0 with type self = i, type t = seq t,
  type ModelTy0.modelTy = ModelTy0.modelTy, type Output0.output = Output0.output
  clone CreusotContracts_Std1_Slice_SliceIndexSpec_InBounds_Interface as InBounds0 with type self = i, type t = seq t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = t, type a = a, axiom .
  val index [@cfg:stackify] (self : Type.alloc_vec_vec t a) (index : i) : Output0.output
    requires {InBounds0.in_bounds index (Model0.model self)}
    ensures { HasValue0.has_value index (Model0.model self) result }
    
end
module Alloc_Vec_Impl16
  type t
  type i
  type a
end
module CreusotContracts_Std1_Slice_Impl3_InBounds_Interface
  type t
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use seq.Seq
  predicate in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl3_InBounds
  type t
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use seq.Seq
  predicate in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t) =
    UInt64.to_int self < Seq.length seq
end
module CreusotContracts_Std1_Slice_Impl3
  type t
end
module CreusotContracts_Std1_Slice_Impl3_HasValue_Interface
  type t
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use seq.Seq
  predicate has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t)
end
module CreusotContracts_Std1_Slice_Impl3_HasValue
  type t
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use seq.Seq
  predicate has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t) =
    Seq.get seq (UInt64.to_int self) = out
end
module Core_Slice_Index_Impl2_Output
  type t
  type output  =
    t
end
module Core_Slice_Index_Impl2
  type t
end
module CreusotContracts_Std1_Slice_Impl0
  type t
end
module Cdsat_Trail_Impl7_Index_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.cdsat_trail_assignment,
  type a = Type.alloc_alloc_global, axiom .
  val index [@cfg:stackify] (self : Type.cdsat_trail_trail) (index : usize) : Type.cdsat_trail_assignment
    requires {[#"/Users/xavier/Code/cdsat/src/trail.rs" 408 15 408 49] UInt64.to_int index < Seq.length (Model0.model (Type.cdsat_trail_trail_Trail_assignments self))}
    ensures { [#"/Users/xavier/Code/cdsat/src/trail.rs" 409 14 409 52] result = Seq.get (Model0.model (Type.cdsat_trail_trail_Trail_assignments self)) (UInt64.to_int index) }
    
end
module CreusotContracts_Logic_Model_Model_Model_Interface
  type self
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy0 with type self = self
  function model (self : self) : ModelTy0.modelTy
end
module CreusotContracts_Logic_Model_Model_Model
  type self
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy0 with type self = self
  function model (self : self) : ModelTy0.modelTy
end
module CreusotContracts_Logic_Model_Impl0_ModelTy
  type t
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy0 with type self = t
  type modelTy  =
    ModelTy0.modelTy
end
module Core_Cmp_Impls_Impl9_Eq_Interface
  type a
  type b
  use prelude.Prelude
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy2 with type self = a
  clone CreusotContracts_Logic_Model_Impl0_ModelTy as ModelTy1 with type t = b, type ModelTy0.modelTy = ModelTy2.modelTy
  clone CreusotContracts_Logic_Model_Impl0_ModelTy as ModelTy0 with type t = a, type ModelTy0.modelTy = ModelTy2.modelTy
  clone CreusotContracts_Logic_Model_Model_Model_Interface as Model1 with type self = b,
  type ModelTy0.modelTy = ModelTy1.modelTy
  clone CreusotContracts_Logic_Model_Model_Model_Interface as Model0 with type self = a,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val eq [@cfg:stackify] (self : a) (other : b) : bool
    ensures { result = (Model0.model self = Model1.model other) }
    
end
module Cdsat_Trail_Impl7_Output
  use Type
  type output  =
    Type.cdsat_trail_assignment
end
module Core_Ops_Index_Index_Output
  type self
  type idx
  type output
end
module Core_Ops_Index_Index_Index_Interface
  type self
  type idx
  use prelude.Prelude
  clone Core_Ops_Index_Index_Output as Output0 with type self = self, type idx = idx
  val index [@cfg:stackify] (self : self) (index : idx) : Output0.output
    requires {false}
    
end
module Cdsat_Trail_Impl7
  use Type
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.cdsat_trail_assignment,
  type a = Type.alloc_alloc_global, axiom .
  clone Cdsat_Trail_Impl7_Output as Output0
  clone Cdsat_Trail_Impl7_Index_Interface as Index0 with function Model0.model = Model0.model
  clone Core_Ops_Index_Index_Index_Interface as Index1 with type self = Type.cdsat_trail_trail, type idx = usize,
  val index = Index0.index, type Output0.output = Output0.output
  clone Core_Ops_Index_Index_Output as Output1 with type self = Type.cdsat_trail_trail, type idx = usize,
  type output = Output0.output
end
module Core_Cmp_Impls_Impl9
  type a
  type b
end
module CreusotContracts_Logic_Model_Impl0_Model_Interface
  type t
  use prelude.Prelude
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy0 with type self = t
  function model (self : t) : ModelTy0.modelTy
end
module CreusotContracts_Logic_Model_Impl0_Model
  type t
  use prelude.Prelude
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy0 with type self = t
  clone CreusotContracts_Logic_Model_Model_Model_Interface as Model0 with type self = t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  function model (self : t) : ModelTy0.modelTy =
    Model0.model self
end
module CreusotContracts_Logic_Model_Impl0
  type t
end
module Cdsat_Trail_Impl3_ModelTy
  use Type
  type modelTy  =
    Type.cdsat_theory_term
end
module Cdsat_Trail_Impl2_Model_Interface
  use Type
  function model (self : Type.cdsat_trail_sort) : Type.cdsat_theory_sort
end
module Cdsat_Trail_Impl2_Model
  use Type
  function model [#"/Users/xavier/Code/cdsat/src/trail.rs" 75 4 75 35] (self : Type.cdsat_trail_sort) : Type.cdsat_theory_sort
    
   =
    [#"/Users/xavier/Code/cdsat/src/trail.rs" 76 8 79 9] match (self) with
      | Type.Cdsat_Trail_Sort_Boolean -> Type.Cdsat_Theory_Sort_Boolean
      | Type.Cdsat_Trail_Sort_Rational -> Type.Cdsat_Theory_Sort_Rational
      end
end
module Cdsat_Trail_Impl4_Model_Interface
  use Type
  function model (self : Type.cdsat_trail_value) : Type.cdsat_theory_value
end
module Cdsat_Trail_Impl4_Model
  use Type
  use mach.int.UInt64
  function model [#"/Users/xavier/Code/cdsat/src/trail.rs" 122 4 122 35] (self : Type.cdsat_trail_value) : Type.cdsat_theory_value
    
   =
    [#"/Users/xavier/Code/cdsat/src/trail.rs" 123 8 126 9] match (self) with
      | Type.Cdsat_Trail_Value_Bool b -> Type.Cdsat_Theory_Value_Bool b
      | Type.Cdsat_Trail_Value_Rat r -> Type.Cdsat_Theory_Value_Rat (UInt64.to_int r)
      end
end
module Cdsat_Trail_Impl3_Model_Interface
  use Type
  function model (self : Type.cdsat_trail_term) : Type.cdsat_theory_term
end
module Cdsat_Trail_Impl3_Model
  use Type
  use mach.int.UInt64
  clone Cdsat_Trail_Impl4_Model_Interface as Model1
  clone Cdsat_Trail_Impl2_Model_Interface as Model0
  function model [#"/Users/xavier/Code/cdsat/src/trail.rs" 99 4 99 35] (self : Type.cdsat_trail_term) : Type.cdsat_theory_term
    
   =
    [#"/Users/xavier/Code/cdsat/src/trail.rs" 100 8 106 9] match (self) with
      | Type.Cdsat_Trail_Term_Variable v s -> Type.Cdsat_Theory_Term_Variable (Type.Cdsat_Theory_Var (UInt64.to_int v) (Model0.model s))
      | Type.Cdsat_Trail_Term_Value v -> Type.Cdsat_Theory_Term_Value (Model1.model v)
      | Type.Cdsat_Trail_Term_Plus l r -> Type.Cdsat_Theory_Term_Plus (model l) (model r)
      | Type.Cdsat_Trail_Term_Eq l r -> Type.Cdsat_Theory_Term_Eq (model l) (model r)
      | Type.Cdsat_Trail_Term_Conj l r -> Type.Cdsat_Theory_Term_Conj (model l) (model r)
      end
end
module Cdsat_Trail_Impl3
  use Type
  clone Cdsat_Trail_Impl4_Model as Model3
  clone Cdsat_Trail_Impl2_Model as Model2
  clone Cdsat_Trail_Impl3_ModelTy as ModelTy0
  clone Cdsat_Trail_Impl3_Model as Model0 with function Model0.model = Model2.model,
  function Model1.model = Model3.model
  clone CreusotContracts_Logic_Model_Model_Model_Interface as Model1 with type self = Type.cdsat_trail_term,
  function model = Model0.model, type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy1 with type self = Type.cdsat_trail_term,
  type modelTy = ModelTy0.modelTy
end
module Cdsat_Trail_Impl2_ModelTy
  use Type
  type modelTy  =
    Type.cdsat_theory_sort
end
module Cdsat_Trail_Impl2
  use Type
  clone Cdsat_Trail_Impl2_ModelTy as ModelTy0
  clone Cdsat_Trail_Impl2_Model as Model0
  clone CreusotContracts_Logic_Model_Model_Model_Interface as Model1 with type self = Type.cdsat_trail_sort,
  function model = Model0.model, type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy1 with type self = Type.cdsat_trail_sort,
  type modelTy = ModelTy0.modelTy
end
module Cdsat_Trail_Impl4_ModelTy
  use Type
  type modelTy  =
    Type.cdsat_theory_value
end
module Cdsat_Trail_Impl4
  use Type
  clone Cdsat_Trail_Impl4_ModelTy as ModelTy0
  clone Cdsat_Trail_Impl4_Model as Model0
  clone CreusotContracts_Logic_Model_Model_Model_Interface as Model1 with type self = Type.cdsat_trail_value,
  function model = Model0.model, type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy1 with type self = Type.cdsat_trail_value,
  type modelTy = ModelTy0.modelTy
end
module Cdsat_Trail_Impl6_IndexOf_Interface
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use Type
  use seq.Seq
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.cdsat_trail_assignment,
  type a = Type.alloc_alloc_global, axiom .
  val index_of [@cfg:stackify] (self : Type.cdsat_trail_trail) (a : Type.cdsat_trail_term) : Type.core_option_option usize
    ensures { [#"/Users/xavier/Code/cdsat/src/trail.rs" 315 4 315 82] forall i : (usize) . result = Type.Core_Option_Option_Some i -> UInt64.to_int i < Seq.length (Model0.model (Type.cdsat_trail_trail_Trail_assignments self)) }
    
end
module Cdsat_Trail_Impl6_Get_Interface
  use prelude.Prelude
  use Type
  val get [@cfg:stackify] (self : Type.cdsat_trail_trail) (a : Type.cdsat_trail_term) : Type.core_option_option (Type.cdsat_trail_assignment)
    
end
module Alloc_Vec_Impl14_Clone_Interface
  type t
  type a
  use prelude.Prelude
  use Type
  val clone' [@cfg:stackify] (self : Type.alloc_vec_vec t a) : Type.alloc_vec_vec t a
    ensures { result = self }
    
end
module Alloc_Vec_Impl14
  type t
  type a
end
module Cdsat_Trail_Impl6_Justification_Interface
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  val justification [@cfg:stackify] (self : Type.cdsat_trail_trail) (a : Type.cdsat_trail_assignment) : Type.core_option_option (Type.alloc_vec_vec usize (Type.alloc_alloc_global))
    
end
module Cdsat_Theory_Impl1_Sort_Interface
  use Type
  function sort (self : Type.cdsat_theory_value) : Type.cdsat_theory_sort
end
module Cdsat_Theory_Impl1_Sort
  use Type
  function sort [#"/Users/xavier/Code/cdsat/src/theory.rs" 51 4 51 29] (self : Type.cdsat_theory_value) : Type.cdsat_theory_sort
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 52 8 55 9] match (self) with
      | Type.Cdsat_Theory_Value_Bool _ -> Type.Cdsat_Theory_Sort_Boolean
      | Type.Cdsat_Theory_Value_Rat _ -> Type.Cdsat_Theory_Sort_Rational
      end
end
module Cdsat_Theory_Impl1_IsBool_Interface
  use Type
  predicate is_bool (self : Type.cdsat_theory_value)
end
module Cdsat_Theory_Impl1_IsBool
  use Type
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort0
  predicate is_bool [#"/Users/xavier/Code/cdsat/src/theory.rs" 46 4 46 32] (self : Type.cdsat_theory_value) =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 47 8 47 36] Sort0.sort self = Type.Cdsat_Theory_Sort_Boolean
end
module Cdsat_Trail_Impl5_IsBool_Interface
  use prelude.Prelude
  use Type
  clone Cdsat_Trail_Impl4_ModelTy as ModelTy0
  clone Cdsat_Theory_Impl1_IsBool_Interface as IsBool0
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.cdsat_trail_value,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val is_bool [@cfg:stackify] (self : Type.cdsat_trail_value) : bool
    ensures { [#"/Users/xavier/Code/cdsat/src/trail.rs" 139 14 139 41] result = IsBool0.is_bool (Model0.model self) }
    
end
module Cdsat_Trail_Impl8_IsBool_Interface
  use prelude.Prelude
  use Type
  val is_bool [@cfg:stackify] (self : Type.cdsat_trail_assignment) : bool
end
module Cdsat_Trail_Impl1_ModelTy
  use Type
  type modelTy  =
    Type.cdsat_trail_reasonmodel
end
module Cdsat_Trail_Impl1_Model_Interface
  use Type
  function model (self : Type.cdsat_trail_reason) : Type.cdsat_trail_reasonmodel
end
module Cdsat_Trail_Impl1_Model
  use Type
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = usize, type a = Type.alloc_alloc_global,
  axiom .
  function model [#"/Users/xavier/Code/cdsat/src/trail.rs" 58 4 58 35] (self : Type.cdsat_trail_reason) : Type.cdsat_trail_reasonmodel
    
   =
    [#"/Users/xavier/Code/cdsat/src/trail.rs" 59 8 63 9] match (self) with
      | Type.Cdsat_Trail_Reason_Justified a1 -> Type.Cdsat_Trail_ReasonModel_Justified (Model0.model a1)
      | Type.Cdsat_Trail_Reason_Decision -> Type.Cdsat_Trail_ReasonModel_Decision
      | Type.Cdsat_Trail_Reason_Input -> Type.Cdsat_Trail_ReasonModel_Input
      end
end
module Cdsat_Trail_Impl1
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = usize, type a = Type.alloc_alloc_global, axiom .
  clone Cdsat_Trail_Impl1_ModelTy as ModelTy0
  clone Cdsat_Trail_Impl1_Model as Model0 with function Model0.model = Model2.model
  clone CreusotContracts_Logic_Model_Model_Model_Interface as Model1 with type self = Type.cdsat_trail_reason,
  function model = Model0.model, type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy1 with type self = Type.cdsat_trail_reason,
  type modelTy = ModelTy0.modelTy
end
module CreusotContracts_Logic_Resolve_Resolve_Resolve_Interface
  type self
  predicate resolve (self : self)
end
module CreusotContracts_Logic_Resolve_Resolve_Resolve
  type self
  predicate resolve (self : self)
end
module CreusotContracts_Logic_Resolve_Impl0_Resolve_Interface
  type t1
  type t2
  predicate resolve (self : (t1, t2))
end
module CreusotContracts_Logic_Resolve_Impl0_Resolve
  type t1
  type t2
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve_Interface as Resolve1 with type self = t2
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve_Interface as Resolve0 with type self = t1
  predicate resolve (self : (t1, t2)) =
    Resolve0.resolve (let (a, _) = self in a) /\ Resolve1.resolve (let (_, a) = self in a)
end
module Alloc_Vec_PartialEq_Impl0_Eq_Interface
  type t
  type u
  type a1
  type a2
  use prelude.Prelude
  use Type
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy2 with type self = Type.alloc_vec_vec t a1
  clone CreusotContracts_Logic_Model_Impl0_ModelTy as ModelTy1 with type t = Type.alloc_vec_vec u a2,
  type ModelTy0.modelTy = ModelTy2.modelTy
  clone CreusotContracts_Logic_Model_Impl0_ModelTy as ModelTy0 with type t = Type.alloc_vec_vec t a1,
  type ModelTy0.modelTy = ModelTy2.modelTy
  clone CreusotContracts_Logic_Model_Model_Model_Interface as Model1 with type self = Type.alloc_vec_vec u a2,
  type ModelTy0.modelTy = ModelTy1.modelTy
  clone CreusotContracts_Logic_Model_Model_Model_Interface as Model0 with type self = Type.alloc_vec_vec t a1,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val eq [@cfg:stackify] (self : Type.alloc_vec_vec t a1) (other : Type.alloc_vec_vec u a2) : bool
    ensures { result = (Model0.model self = Model1.model other) }
    
end
module CreusotContracts_Logic_Resolve_Impl0
  type t1
  type t2
end
module Alloc_Vec_PartialEq_Impl0
  type t
  type u
  type a1
  type a2
end
module CreusotContracts_Logic_Resolve_Impl2_Resolve_Interface
  type t
  predicate resolve (self : t)
end
module CreusotContracts_Logic_Resolve_Impl2_Resolve
  type t
  predicate resolve (self : t) =
    true
end
module CreusotContracts_Logic_Resolve_Impl2
  type t
end
module CreusotContracts_Std1_Vec_Impl0_ModelTy
  type t
  type a
  use seq.Seq
  type modelTy  =
    Seq.seq t
end
module Cdsat_Trail_Impl14_Eq_Interface
  use prelude.Prelude
  use Type
  clone Cdsat_Trail_Impl1_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.cdsat_trail_reason,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val eq [@cfg:stackify] (self : Type.cdsat_trail_reason) (rhs : Type.cdsat_trail_reason) : bool
    ensures { [#"/Users/xavier/Code/cdsat/src/trail.rs" 39 16 39 25] result = (Model0.model self = Model0.model rhs) }
    
end
module Core_Cmp_PartialEq_Ne_Interface
  type self
  type rhs
  use prelude.Prelude
  val ne [@cfg:stackify] (self : self) (other : rhs) : bool
    requires {false}
    
end
module Core_Cmp_PartialEq_Eq_Interface
  type self
  type rhs
  use prelude.Prelude
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy0 with type self = self
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model1 with type t = rhs,
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = self,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val eq [@cfg:stackify] (self : self) (other : rhs) : bool
    ensures { result = (Model0.model self = Model1.model other) }
    
end
module Cdsat_Trail_Impl14
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = usize, type a = Type.alloc_alloc_global, axiom .
  clone Cdsat_Trail_Impl1_Model as Model1 with function Model0.model = Model2.model
  clone Cdsat_Trail_Impl1_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = Type.cdsat_trail_reason,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model1.model
  clone Core_Cmp_PartialEq_Ne_Interface as Ne0 with type self = Type.cdsat_trail_reason,
  type rhs = Type.cdsat_trail_reason
  clone Cdsat_Trail_Impl14_Eq_Interface as Eq0 with function Model0.model = Model0.model
  clone Core_Cmp_PartialEq_Eq_Interface as Eq1 with type self = Type.cdsat_trail_reason,
  type rhs = Type.cdsat_trail_reason, val eq = Eq0.eq, function Model0.model = Model0.model,
  function Model1.model = Model0.model, type ModelTy0.modelTy = ModelTy0.modelTy
end
module Cdsat_Trail_Impl8_Decision_Interface
  use prelude.Prelude
  use Type
  val decision [@cfg:stackify] (self : Type.cdsat_trail_assignment) : bool
end
module Cdsat_Trail_Impl8_Value_Interface
  use prelude.Prelude
  use Type
  val value [@cfg:stackify] (self : Type.cdsat_trail_assignment) : Type.cdsat_trail_value
end
module Cdsat_Trail_Impl8_Term_Interface
  use prelude.Prelude
  use Type
  val term [@cfg:stackify] (self : Type.cdsat_trail_assignment) : Type.cdsat_trail_term
end
module Cdsat_Main_Interface
  val main [@cfg:stackify] (_ : ()) : ()
end
module Cdsat_Trail_Impl8_TermValue_Interface
  use prelude.Prelude
  use Type
  function term_value (self : Type.cdsat_trail_assignment) : (Type.cdsat_theory_term, Type.cdsat_theory_value)
end
module Cdsat_Trail_Impl8_TermValue
  use prelude.Prelude
  use Type
  clone Cdsat_Trail_Impl4_Model_Interface as Model1
  clone Cdsat_Trail_Impl3_Model_Interface as Model0
  function term_value [#"/Users/xavier/Code/cdsat/src/trail.rs" 417 4 417 61] (self : Type.cdsat_trail_assignment) : (Type.cdsat_theory_term, Type.cdsat_theory_value)
    
   =
    [#"/Users/xavier/Code/cdsat/src/trail.rs" 418 8 418 45] (Model0.model (Type.cdsat_trail_assignment_Assignment_term self), Model1.model (Type.cdsat_trail_assignment_Assignment_val self))
end
module Cdsat_Theory_Impl0_Sort_Interface
  use Type
  function sort (self : Type.cdsat_theory_term) : Type.cdsat_theory_sort
end
module Cdsat_Theory_Impl0_Sort
  use Type
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort0
  function sort [#"/Users/xavier/Code/cdsat/src/theory.rs" 14 4 14 25] (self : Type.cdsat_theory_term) : Type.cdsat_theory_sort
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 15 8 21 9] match (self) with
      | Type.Cdsat_Theory_Term_Variable v -> Type.cdsat_theory_var_Var_1 v
      | Type.Cdsat_Theory_Term_Value v -> Sort0.sort v
      | Type.Cdsat_Theory_Term_Plus _ _ -> Type.Cdsat_Theory_Sort_Rational
      | Type.Cdsat_Theory_Term_Eq _ _ -> Type.Cdsat_Theory_Sort_Boolean
      | Type.Cdsat_Theory_Term_Conj _ _ -> Type.Cdsat_Theory_Sort_Boolean
      end
end
module Cdsat_Theory_Impl2_Invariant_Interface
  use Type
  predicate invariant' (self : Type.cdsat_theory_assign)
end
module Cdsat_Theory_Impl2_Invariant
  use Type
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  predicate invariant' [#"/Users/xavier/Code/cdsat/src/theory.rs" 82 4 82 30] (self : Type.cdsat_theory_assign) =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 83 8 87 9] match (self) with
      | Type.Cdsat_Theory_Assign_Decision t v -> Sort0.sort t = Sort1.sort v
      | Type.Cdsat_Theory_Assign_Justified _ t v -> Sort0.sort t = Sort1.sort v
      | Type.Cdsat_Theory_Assign_Input t v -> Sort0.sort t = Sort1.sort v
      end
end
module Cdsat_Theory_Impl4_InvariantAssign_Interface
  use Type
  predicate invariant_assign (self : Type.cdsat_theory_trail)
end
module Cdsat_Theory_Impl4_InvariantAssign
  use Type
  clone Cdsat_Theory_Impl2_Invariant_Interface as Invariant0
  predicate invariant_assign [#"/Users/xavier/Code/cdsat/src/theory.rs" 246 4 246 37] (self : Type.cdsat_theory_trail) =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 247 8 250 9] match (self) with
      | Type.Cdsat_Theory_Trail_Empty -> true
      | Type.Cdsat_Theory_Trail_Assign a l tl -> invariant_assign tl /\ Invariant0.invariant' a
      end
end
module Cdsat_Theory_Impl2_ToPair_Interface
  use Type
  function to_pair (self : Type.cdsat_theory_assign) : (Type.cdsat_theory_term, Type.cdsat_theory_value)
end
module Cdsat_Theory_Impl2_ToPair
  use Type
  function to_pair [#"/Users/xavier/Code/cdsat/src/theory.rs" 91 4 91 41] (self : Type.cdsat_theory_assign) : (Type.cdsat_theory_term, Type.cdsat_theory_value)
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 92 8 96 9] match (self) with
      | Type.Cdsat_Theory_Assign_Decision t val' -> (t, val')
      | Type.Cdsat_Theory_Assign_Input t val' -> (t, val')
      | Type.Cdsat_Theory_Assign_Justified _ t val' -> (t, val')
      end
end
module Cdsat_Theory_Impl4_Len_Interface
  use mach.int.Int
  use mach.int.Int32
  use Type
  function len (self : Type.cdsat_theory_trail) : int
end
module Cdsat_Theory_Impl4_Len
  use mach.int.Int
  use mach.int.Int32
  use Type
  function len [#"/Users/xavier/Code/cdsat/src/theory.rs" 406 4 406 27] (self : Type.cdsat_theory_trail) : int =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 407 8 410 9] match (self) with
      | Type.Cdsat_Theory_Trail_Empty -> 0
      | Type.Cdsat_Theory_Trail_Assign _ _ tl -> len tl + 1
      end
  axiom len_spec : forall self : Type.cdsat_theory_trail . [#"/Users/xavier/Code/cdsat/src/theory.rs" 405 14 405 25] len self >= 0
end
module Cdsat_Theory_Impl4_Len_Impl
  use mach.int.Int
  use mach.int.Int32
  use Type
  let rec ghost function len (self : Type.cdsat_theory_trail) : int
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 405 14 405 25] result >= 0 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 407 8 410 9] match (self) with
      | Type.Cdsat_Theory_Trail_Empty -> 0
      | Type.Cdsat_Theory_Trail_Assign _ _ tl -> len tl + 1
      end
end
module Cdsat_Theory_Impl4_Level_Interface
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  function level (self : Type.cdsat_theory_trail) : int
end
module Cdsat_Theory_Impl4_Level
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  function level [#"/Users/xavier/Code/cdsat/src/theory.rs" 395 4 395 29] (self : Type.cdsat_theory_trail) : int =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 396 8 400 9] match (self) with
      | Type.Cdsat_Theory_Trail_Empty -> 0
      | Type.Cdsat_Theory_Trail_Assign (Type.Cdsat_Theory_Assign_Decision _ _) _ tl -> 1 + level tl
      | Type.Cdsat_Theory_Trail_Assign _ _ tl -> level tl
      end
  axiom level_spec : forall self : Type.cdsat_theory_trail . ([#"/Users/xavier/Code/cdsat/src/theory.rs" 393 14 393 34] level self <= Len0.len self) && ([#"/Users/xavier/Code/cdsat/src/theory.rs" 392 14 392 25] level self >= 0)
end
module Cdsat_Theory_Impl4_Level_Impl
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Cdsat_Theory_Impl4_Len as Len0 with axiom .
  let rec ghost function level (self : Type.cdsat_theory_trail) : int
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 392 14 392 25] result >= 0 }
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 393 14 393 34] result <= Len0.len self }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 396 8 400 9] match (self) with
      | Type.Cdsat_Theory_Trail_Empty -> 0
      | Type.Cdsat_Theory_Trail_Assign (Type.Cdsat_Theory_Assign_Decision _ _) _ tl -> 1 + level tl
      | Type.Cdsat_Theory_Trail_Assign _ _ tl -> level tl
      end
end
module Cdsat_Theory_Impl4_InvariantNonneg_Interface
  use Type
  predicate invariant_nonneg (self : Type.cdsat_theory_trail)
end
module Cdsat_Theory_Impl4_InvariantNonneg
  use Type
  use mach.int.Int
  use mach.int.Int32
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  predicate invariant_nonneg [#"/Users/xavier/Code/cdsat/src/theory.rs" 238 4 238 37] (self : Type.cdsat_theory_trail) =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 239 8 242 9] match (self) with
      | Type.Cdsat_Theory_Trail_Empty -> true
      | Type.Cdsat_Theory_Trail_Assign a l tl -> invariant_nonneg tl /\ l >= 0 /\ l <= Level0.level self
      end
end
module Cdsat_Theory_Impl4_Find_Interface
  use Type
  use mach.int.Int
  use mach.int.Int32
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl2_ToPair_Interface as ToPair0
  function find (self : Type.cdsat_theory_trail) (d : (Type.cdsat_theory_term, Type.cdsat_theory_value)) : Type.core_option_option (Type.cdsat_theory_assign, int)
    
end
module Cdsat_Theory_Impl4_Find
  use Type
  use mach.int.Int
  use mach.int.Int32
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl2_ToPair_Interface as ToPair0
  function find [#"/Users/xavier/Code/cdsat/src/theory.rs" 331 4 331 64] (self : Type.cdsat_theory_trail) (d : (Type.cdsat_theory_term, Type.cdsat_theory_value)) : Type.core_option_option (Type.cdsat_theory_assign, int)
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 332 8 341 9] match (self) with
      | Type.Cdsat_Theory_Trail_Empty -> Type.Core_Option_Option_None
      | Type.Cdsat_Theory_Trail_Assign a l tl -> if ToPair0.to_pair a = d then
        Type.Core_Option_Option_Some (a, l)
      else
        find tl d
      
      end
  axiom find_spec : forall self : Type.cdsat_theory_trail, d : (Type.cdsat_theory_term, Type.cdsat_theory_value) . ([#"/Users/xavier/Code/cdsat/src/theory.rs" 330 4 330 104] InvariantAssign0.invariant_assign self -> (forall p : ((Type.cdsat_theory_assign, int)) . find self d = Type.Core_Option_Option_Some p -> Sort0.sort (let (a, _) = d in a) = Sort1.sort (let (_, a) = d in a))) && ([#"/Users/xavier/Code/cdsat/src/theory.rs" 329 4 329 111] InvariantNonneg0.invariant_nonneg self -> (forall p : ((Type.cdsat_theory_assign, int)) . find self d = Type.Core_Option_Option_Some p -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= Level0.level self)) && ([#"/Users/xavier/Code/cdsat/src/theory.rs" 325 14 328 5] match (find self d) with
    | Type.Core_Option_Option_Some (a, l) -> ToPair0.to_pair a = d
    | _ -> true
    end)
end
module Cdsat_Theory_Impl4_Find_Impl
  use Type
  use mach.int.Int
  use mach.int.Int32
  clone Cdsat_Theory_Impl1_Sort as Sort1
  clone Cdsat_Theory_Impl0_Sort as Sort0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl2_Invariant as Invariant0 with function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_Len as Len0 with axiom .
  clone Cdsat_Theory_Impl4_InvariantAssign as InvariantAssign0 with predicate Invariant0.invariant' = Invariant0.invariant'
  clone Cdsat_Theory_Impl4_Level as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg as InvariantNonneg0 with function Level0.level = Level0.level,
  function Len0.len = Len0.len
  clone Cdsat_Theory_Impl2_ToPair as ToPair0
  let rec ghost function find (self : Type.cdsat_theory_trail) (d : (Type.cdsat_theory_term, Type.cdsat_theory_value)) : Type.core_option_option (Type.cdsat_theory_assign, int)
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 325 14 328 5] match (result) with
      | Type.Core_Option_Option_Some (a, l) -> ToPair0.to_pair a = d
      | _ -> true
      end }
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 329 4 329 111] InvariantNonneg0.invariant_nonneg self -> (forall p : ((Type.cdsat_theory_assign, int)) . result = Type.Core_Option_Option_Some p -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= Level0.level self) }
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 330 4 330 104] InvariantAssign0.invariant_assign self -> (forall p : ((Type.cdsat_theory_assign, int)) . result = Type.Core_Option_Option_Some p -> Sort0.sort (let (a, _) = d in a) = Sort1.sort (let (_, a) = d in a)) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 332 8 341 9] match (self) with
      | Type.Cdsat_Theory_Trail_Empty -> Type.Core_Option_Option_None
      | Type.Cdsat_Theory_Trail_Assign a l tl -> if let a = ToPair0.to_pair a in pure {a = d} then
        Type.Core_Option_Option_Some (a, l)
      else
        find tl d
      
      end
end
module Cdsat_Theory_Impl4_Contains_Interface
  use Type
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  predicate contains (self : Type.cdsat_theory_trail) (d : (Type.cdsat_theory_term, Type.cdsat_theory_value))
end
module Cdsat_Theory_Impl4_Contains
  use Type
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  use mach.int.Int
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl2_ToPair_Interface as ToPair0
  clone Cdsat_Theory_Impl4_Find_Interface as Find0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function Len0.len = Len0.len, axiom .
  predicate contains [#"/Users/xavier/Code/cdsat/src/theory.rs" 317 4 317 51] (self : Type.cdsat_theory_trail) (d : (Type.cdsat_theory_term, Type.cdsat_theory_value))
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 318 8 321 9] match (Find0.find self d) with
      | Type.Core_Option_Option_Some ix -> true
      | Type.Core_Option_Option_None -> false
      end
  axiom contains_spec : forall self : Type.cdsat_theory_trail, d : (Type.cdsat_theory_term, Type.cdsat_theory_value) . [#"/Users/xavier/Code/cdsat/src/theory.rs" 316 4 316 87] InvariantAssign0.invariant_assign self -> contains self d = true -> Sort0.sort (let (a, _) = d in a) = Sort1.sort (let (_, a) = d in a)
end
module Cdsat_Theory_Impl4_Contains_Impl
  use Type
  use mach.int.Int
  clone Cdsat_Theory_Impl4_Len as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg as InvariantNonneg0 with function Level0.level = Level0.level,
  function Len0.len = Len0.len
  clone Cdsat_Theory_Impl2_ToPair as ToPair0
  clone Cdsat_Theory_Impl1_Sort as Sort1
  clone Cdsat_Theory_Impl0_Sort as Sort0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl2_Invariant as Invariant0 with function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_InvariantAssign as InvariantAssign0 with predicate Invariant0.invariant' = Invariant0.invariant'
  clone Cdsat_Theory_Impl4_Find as Find0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function Len0.len = Len0.len, axiom .
  let rec ghost function contains (self : Type.cdsat_theory_trail) (d : (Type.cdsat_theory_term, Type.cdsat_theory_value)) : bool
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 316 4 316 87] InvariantAssign0.invariant_assign self -> result = true -> Sort0.sort (let (a, _) = d in a) = Sort1.sort (let (_, a) = d in a) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 318 8 321 9] match (Find0.find self d) with
      | Type.Core_Option_Option_Some ix -> true
      | Type.Core_Option_Option_None -> false
      end
end
module Cdsat_Theory_Impl4_LevelOf_Interface
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  function level_of (self : Type.cdsat_theory_trail) (d : (Type.cdsat_theory_term, Type.cdsat_theory_value)) : int
end
module Cdsat_Theory_Impl4_LevelOf
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone Cdsat_Theory_Impl2_ToPair_Interface as ToPair0
  clone Cdsat_Theory_Impl4_Find_Interface as Find0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function Len0.len = Len0.len, axiom .
  function level_of [#"/Users/xavier/Code/cdsat/src/theory.rs" 308 4 308 50] (self : Type.cdsat_theory_trail) (d : (Type.cdsat_theory_term, Type.cdsat_theory_value)) : int
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 309 8 312 9] match (Find0.find self d) with
      | Type.Core_Option_Option_Some (_, l) -> l
      | Type.Core_Option_Option_None -> 0
      end
  axiom level_of_spec : forall self : Type.cdsat_theory_trail, d : (Type.cdsat_theory_term, Type.cdsat_theory_value) . ([#"/Users/xavier/Code/cdsat/src/theory.rs" 306 15 306 38] InvariantNonneg0.invariant_nonneg self) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 307 14 307 51] level_of self d >= 0 /\ level_of self d <= Level0.level self)
end
module Cdsat_Theory_Impl4_LevelOf_Impl
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Cdsat_Theory_Impl1_Sort as Sort1
  clone Cdsat_Theory_Impl0_Sort as Sort0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl2_Invariant as Invariant0 with function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_InvariantAssign as InvariantAssign0 with predicate Invariant0.invariant' = Invariant0.invariant'
  clone Cdsat_Theory_Impl2_ToPair as ToPair0
  clone Cdsat_Theory_Impl4_Len as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg as InvariantNonneg0 with function Level0.level = Level0.level,
  function Len0.len = Len0.len
  clone Cdsat_Theory_Impl4_Find as Find0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function Len0.len = Len0.len, axiom .
  let rec ghost function level_of (self : Type.cdsat_theory_trail) (d : (Type.cdsat_theory_term, Type.cdsat_theory_value)) : int
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 306 15 306 38] InvariantNonneg0.invariant_nonneg self}
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 307 14 307 51] result >= 0 /\ result <= Level0.level self }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 309 8 312 9] match (Find0.find self d) with
      | Type.Core_Option_Option_Some (_, l) -> l
      | Type.Core_Option_Option_None -> 0
      end
end
module Cdsat_Trail_Impl6_AbstractRelation_Interface
  use Type
  predicate abstract_relation (self : Type.cdsat_trail_trail)
end
module Cdsat_Trail_Impl6_AbstractRelation
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone Cdsat_Theory_Impl4_LevelOf_Interface as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_Contains_Interface as Contains0 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Trail_Impl8_TermValue_Interface as TermValue0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.cdsat_trail_assignment,
  type a = Type.alloc_alloc_global, axiom .
  predicate abstract_relation [#"/Users/xavier/Code/cdsat/src/trail.rs" 227 4 227 38] (self : Type.cdsat_trail_trail) =
    [#"/Users/xavier/Code/cdsat/src/trail.rs" 229 12 230 163] (forall i : (int) . 0 <= i /\ i < Seq.length (Model0.model (Type.cdsat_trail_trail_Trail_assignments self)) -> Contains0.contains (Type.cdsat_trail_trail_Trail_ghost self) (TermValue0.term_value (Seq.get (Model0.model (Type.cdsat_trail_trail_Trail_assignments self)) i))) /\ (forall i : (int) . 0 <= i /\ i < Seq.length (Model0.model (Type.cdsat_trail_trail_Trail_assignments self)) -> LevelOf0.level_of (Type.cdsat_trail_trail_Trail_ghost self) (TermValue0.term_value (Seq.get (Model0.model (Type.cdsat_trail_trail_Trail_assignments self)) i)) = UInt64.to_int (Type.cdsat_trail_assignment_Assignment_level (Seq.get (Model0.model (Type.cdsat_trail_trail_Trail_assignments self)) i)))
end
module Cdsat_Theory_Impl3_Invariant_Interface
  use Type
  predicate invariant' (self : Type.cdsat_theory_model)
end
module Cdsat_Theory_Impl3_Invariant
  use Type
  use map.Map
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort0
  predicate invariant' [#"/Users/xavier/Code/cdsat/src/theory.rs" 115 4 115 34] (self : Type.cdsat_theory_model) =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 116 8 118 9] forall v : (Type.cdsat_theory_value) . forall k : (Type.cdsat_theory_var) . Map.get (Type.cdsat_theory_model_Model_0 self) k = v -> Type.cdsat_theory_var_Var_1 k = Sort0.sort v
end
module CreusotContracts_Logic_Fset_Impl0_Contains_Interface
  type t
  use set.Fset
  predicate contains [@inline:trivial] (self : Fset.fset t) (e : t)
end
module CreusotContracts_Logic_Fset_Impl0_Contains
  type t
  use set.Fset
  predicate contains [@inline:trivial] (self : Fset.fset t) (e : t) =
    Fset.mem e self
end
module Cdsat_Theory_Impl3_Interp_Interface
  use Type
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl3_Invariant_Interface as Invariant0
  function interp (self : Type.cdsat_theory_model) (t : Type.cdsat_theory_term) : Type.cdsat_theory_value
end
module Cdsat_Theory_Impl3_Interp
  use Type
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl3_Invariant_Interface as Invariant0
  use map.Map
  use mach.int.Int
  use mach.int.Int32
  function interp [#"/Users/xavier/Code/cdsat/src/theory.rs" 123 4 123 37] (self : Type.cdsat_theory_model) (t : Type.cdsat_theory_term) : Type.cdsat_theory_value
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 124 8 136 9] match (t) with
      | Type.Cdsat_Theory_Term_Variable v -> Map.get (Type.cdsat_theory_model_Model_0 self) v
      | Type.Cdsat_Theory_Term_Value v -> v
      | Type.Cdsat_Theory_Term_Plus l r -> match ((interp self l, interp self r)) with
        | (Type.Cdsat_Theory_Value_Rat r1, Type.Cdsat_Theory_Value_Rat r2) -> Type.Cdsat_Theory_Value_Rat (r1 + r2)
        | _ -> Type.Cdsat_Theory_Value_Rat (- 1)
        end
      | Type.Cdsat_Theory_Term_Conj l r -> match ((interp self l, interp self r)) with
        | (Type.Cdsat_Theory_Value_Bool b1, Type.Cdsat_Theory_Value_Bool b2) -> Type.Cdsat_Theory_Value_Bool (b1 /\ b2)
        | _ -> Type.Cdsat_Theory_Value_Bool false
        end
      | Type.Cdsat_Theory_Term_Eq l r -> Type.Cdsat_Theory_Value_Bool (interp self l = interp self r)
      end
  axiom interp_spec : forall self : Type.cdsat_theory_model, t : Type.cdsat_theory_term . [#"/Users/xavier/Code/cdsat/src/theory.rs" 122 4 122 62] Invariant0.invariant' self -> Sort0.sort (interp self t) = Sort1.sort t
end
module Cdsat_Theory_Impl3_Interp_Impl
  use Type
  use map.Map
  use mach.int.Int
  use mach.int.Int32
  clone Cdsat_Theory_Impl1_Sort as Sort0
  clone Cdsat_Theory_Impl0_Sort as Sort1 with function Sort0.sort = Sort0.sort
  clone Cdsat_Theory_Impl3_Invariant as Invariant0 with function Sort0.sort = Sort0.sort
  let rec ghost function interp (self : Type.cdsat_theory_model) (t : Type.cdsat_theory_term) : Type.cdsat_theory_value
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 122 4 122 62] Invariant0.invariant' self -> Sort0.sort result = Sort1.sort t }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 124 8 136 9] match (t) with
      | Type.Cdsat_Theory_Term_Variable v -> let a' = Type.cdsat_theory_model_Model_0 self in Map.get a' v
      | Type.Cdsat_Theory_Term_Value v -> v
      | Type.Cdsat_Theory_Term_Plus l r -> match ((interp self l, interp self r)) with
        | (Type.Cdsat_Theory_Value_Rat r1, Type.Cdsat_Theory_Value_Rat r2) -> Type.Cdsat_Theory_Value_Rat (r1 + r2)
        | _ -> Type.Cdsat_Theory_Value_Rat (- 1)
        end
      | Type.Cdsat_Theory_Term_Conj l r -> match ((interp self l, interp self r)) with
        | (Type.Cdsat_Theory_Value_Bool b1, Type.Cdsat_Theory_Value_Bool b2) -> Type.Cdsat_Theory_Value_Bool (b1 && b2)
        | _ -> Type.Cdsat_Theory_Value_Bool false
        end
      | Type.Cdsat_Theory_Term_Eq l r -> Type.Cdsat_Theory_Value_Bool (let b = interp self r in let a = interp self l in pure {a = b})
      end
end
module Cdsat_Theory_Impl3_Satisfies_Interface
  use Type
  predicate satisfies (self : Type.cdsat_theory_model) (v : (Type.cdsat_theory_term, Type.cdsat_theory_value))
end
module Cdsat_Theory_Impl3_Satisfies
  use Type
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl3_Invariant_Interface as Invariant0
  clone Cdsat_Theory_Impl3_Interp_Interface as Interp0 with predicate Invariant0.invariant' = Invariant0.invariant',
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, axiom .
  predicate satisfies [#"/Users/xavier/Code/cdsat/src/theory.rs" 140 4 140 48] (self : Type.cdsat_theory_model) (v : (Type.cdsat_theory_term, Type.cdsat_theory_value))
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 141 8 141 31] Interp0.interp self (let (a, _) = v in a) = (let (_, a) = v in a)
end
module Cdsat_Theory_Impl3_SatisfySet_Interface
  use Type
  use set.Fset
  predicate satisfy_set (self : Type.cdsat_theory_model) (v : Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value))
    
end
module Cdsat_Theory_Impl3_SatisfySet
  use Type
  use set.Fset
  clone Cdsat_Theory_Impl3_Satisfies_Interface as Satisfies0
  clone CreusotContracts_Logic_Fset_Impl0_Contains_Interface as Contains0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  predicate satisfy_set [#"/Users/xavier/Code/cdsat/src/theory.rs" 145 4 145 60] (self : Type.cdsat_theory_model) (v : Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value))
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 146 8 146 71] forall a : ((Type.cdsat_theory_term, Type.cdsat_theory_value)) . Contains0.contains v a -> Satisfies0.satisfies self a
end
module Cdsat_Theory_Impl2_JustifiedSound_Interface
  use Type
  predicate justified_sound (self : Type.cdsat_theory_assign)
end
module Cdsat_Theory_Impl2_JustifiedSound
  use Type
  clone Cdsat_Theory_Impl3_Satisfies_Interface as Satisfies0
  clone Cdsat_Theory_Impl3_SatisfySet_Interface as SatisfySet0
  clone Cdsat_Theory_Impl3_Invariant_Interface as Invariant0
  predicate justified_sound [#"/Users/xavier/Code/cdsat/src/theory.rs" 100 4 100 36] (self : Type.cdsat_theory_assign) =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 101 8 106 9] match (self) with
      | Type.Cdsat_Theory_Assign_Justified just t val' -> forall m : (Type.cdsat_theory_model) . Invariant0.invariant' m -> SatisfySet0.satisfy_set m just -> Satisfies0.satisfies m (t, val')
      | _ -> true
      end
end
module Cdsat_Theory_Impl4_Sound_Interface
  use Type
  predicate sound [@inline:trivial] (self : Type.cdsat_theory_trail)
end
module Cdsat_Theory_Impl4_Sound
  use Type
  clone Cdsat_Theory_Impl2_JustifiedSound_Interface as JustifiedSound0
  predicate sound [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 183 4 183 30] (self : Type.cdsat_theory_trail)
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 184 8 187 9] match (self) with
      | Type.Cdsat_Theory_Trail_Empty -> true
      | Type.Cdsat_Theory_Trail_Assign a l tl -> sound tl /\ JustifiedSound0.justified_sound a
      end
end
module CreusotContracts_Logic_Fset_Impl0_Remove_Interface
  type t
  use set.Fset
  function remove [@inline:trivial] (self : Fset.fset t) (a : t) : Fset.fset t
end
module CreusotContracts_Logic_Fset_Impl0_Remove
  type t
  use set.Fset
  function remove [@inline:trivial] (self : Fset.fset t) (a : t) : Fset.fset t =
    Fset.remove a self
end
module Cdsat_Theory_Impl4_SetLevel_Interface
  use Type
  use mach.int.Int
  use set.Fset
  use mach.int.Int32
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl4_LevelOf_Interface as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  clone CreusotContracts_Logic_Fset_Impl0_Contains_Interface as Contains0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  function set_level (self : Type.cdsat_theory_trail) (s : Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value)) : int
    
end
module Cdsat_Theory_Impl4_SetLevel
  use Type
  use mach.int.Int
  use set.Fset
  use mach.int.Int32
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl4_LevelOf_Interface as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  clone CreusotContracts_Logic_Fset_Impl0_Contains_Interface as Contains0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone CreusotContracts_Logic_Fset_Impl0_Remove_Interface as Remove0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  function set_level [#"/Users/xavier/Code/cdsat/src/theory.rs" 206 4 206 57] (self : Type.cdsat_theory_trail) (s : Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value)) : int
    
  axiom def : forall self : Type.cdsat_theory_trail, s : Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value) . set_level self s = ([#"/Users/xavier/Code/cdsat/src/theory.rs" 199 4 199 12] if Fset.cardinal s = 0 then
    0
  else
    if Fset.cardinal s = 1 then
      LevelOf0.level_of self (Fset.pick s)
    else
      let a = Fset.pick s in let rec' = set_level self (Remove0.remove s a) in if LevelOf0.level_of self a >= rec' then
        LevelOf0.level_of self a
      else
        rec'
      
    
  )
  axiom set_level_spec : forall self : Type.cdsat_theory_trail, s : Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value) . ([#"/Users/xavier/Code/cdsat/src/theory.rs" 201 15 201 38] InvariantNonneg0.invariant_nonneg self) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 205 14 205 36] set_level self s <= Level0.level self) && ([#"/Users/xavier/Code/cdsat/src/theory.rs" 204 14 204 25] set_level self s >= 0) && ([#"/Users/xavier/Code/cdsat/src/theory.rs" 203 4 203 94] s <> Fset.empty  -> (exists i : ((Type.cdsat_theory_term, Type.cdsat_theory_value)) . Contains0.contains s i /\ LevelOf0.level_of self i = set_level self s)) && ([#"/Users/xavier/Code/cdsat/src/theory.rs" 202 4 202 74] forall i : ((Type.cdsat_theory_term, Type.cdsat_theory_value)) . Contains0.contains s i -> LevelOf0.level_of self i <= set_level self s)
end
module Cdsat_Theory_Impl4_SetLevel_Impl
  use Type
  use mach.int.Int
  use set.Fset
  use mach.int.Int32
  clone Cdsat_Theory_Impl1_Sort as Sort1
  clone Cdsat_Theory_Impl0_Sort as Sort0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl2_Invariant as Invariant0 with function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_InvariantAssign as InvariantAssign0 with predicate Invariant0.invariant' = Invariant0.invariant'
  clone Cdsat_Theory_Impl2_ToPair as ToPair0
  clone Cdsat_Theory_Impl4_Len as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg as InvariantNonneg0 with function Level0.level = Level0.level,
  function Len0.len = Len0.len
  clone Cdsat_Theory_Impl4_Find as Find0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function Len0.len = Len0.len, axiom .
  clone CreusotContracts_Logic_Fset_Impl0_Remove as Remove0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_LevelOf as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, axiom .
  clone CreusotContracts_Logic_Fset_Impl0_Contains as Contains0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  let rec ghost function set_level (self : Type.cdsat_theory_trail) (s : Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value)) : int
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 201 15 201 38] InvariantNonneg0.invariant_nonneg self}
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 202 4 202 74] forall i : ((Type.cdsat_theory_term, Type.cdsat_theory_value)) . Contains0.contains s i -> LevelOf0.level_of self i <= result }
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 203 4 203 94] s <> Fset.empty  -> (exists i : ((Type.cdsat_theory_term, Type.cdsat_theory_value)) . Contains0.contains s i /\ LevelOf0.level_of self i = result) }
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 204 14 204 25] result >= 0 }
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 205 14 205 36] result <= Level0.level self }
    variant {[#"/Users/xavier/Code/cdsat/src/theory.rs" 200 14 200 21] Fset.cardinal s}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 199 4 199 12] if pure {Fset.cardinal s = 0} then
      0
    else
      if pure {Fset.cardinal s = 1} then
        LevelOf0.level_of self (Fset.pick s)
      else
        let a = Fset.pick s in let rec' = let b' = Remove0.remove s a in set_level self b' in if LevelOf0.level_of self a >= rec' then
          LevelOf0.level_of self a
        else
          rec'
        
      
    
end
module Cdsat_Theory_Impl4_InvariantLevel_Interface
  use Type
  predicate invariant_level (self : Type.cdsat_theory_trail)
end
module Cdsat_Theory_Impl4_InvariantLevel
  use Type
  use mach.int.Int
  use mach.int.Int32
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl4_LevelOf_Interface as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  clone CreusotContracts_Logic_Fset_Impl0_Contains_Interface as Contains0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_SetLevel_Interface as SetLevel0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  predicate invariant_level [#"/Users/xavier/Code/cdsat/src/theory.rs" 223 4 223 36] (self : Type.cdsat_theory_trail) =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 224 8 234 9] match (self) with
      | Type.Cdsat_Theory_Trail_Empty -> true
      | Type.Cdsat_Theory_Trail_Assign a l tl -> invariant_level tl /\ match (a) with
        | Type.Cdsat_Theory_Assign_Input _ _ -> l = 0
        | Type.Cdsat_Theory_Assign_Decision _ _ -> Level0.level tl + 1 = l
        | Type.Cdsat_Theory_Assign_Justified j _ _ -> SetLevel0.set_level tl j = l
        end
      end
end
module Cdsat_Theory_Impl4_InvariantContains_Interface
  use Type
  predicate invariant_contains (self : Type.cdsat_theory_trail)
end
module Cdsat_Theory_Impl4_InvariantContains
  use Type
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone Cdsat_Theory_Impl4_Contains_Interface as Contains1 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, axiom .
  clone CreusotContracts_Logic_Fset_Impl0_Contains_Interface as Contains0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  predicate invariant_contains [#"/Users/xavier/Code/cdsat/src/theory.rs" 254 4 254 39] (self : Type.cdsat_theory_trail)
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 255 8 268 9] match (self) with
      | Type.Cdsat_Theory_Trail_Empty -> true
      | Type.Cdsat_Theory_Trail_Assign a l tl -> invariant_contains tl /\ match (a) with
        | Type.Cdsat_Theory_Assign_Justified j _ _ -> forall a : ((Type.cdsat_theory_term, Type.cdsat_theory_value)) . Contains0.contains j a -> Contains1.contains tl a
        | _ -> true
        end
      end
end
module Cdsat_Theory_Impl1_Negate_Interface
  use Type
  clone Cdsat_Theory_Impl1_IsBool_Interface as IsBool0
  function negate (self : Type.cdsat_theory_value) : Type.cdsat_theory_value
end
module Cdsat_Theory_Impl1_Negate
  use Type
  clone Cdsat_Theory_Impl1_IsBool_Interface as IsBool0
  function negate [#"/Users/xavier/Code/cdsat/src/theory.rs" 61 4 61 31] (self : Type.cdsat_theory_value) : Type.cdsat_theory_value
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 62 8 65 9] match (self) with
      | Type.Cdsat_Theory_Value_Bool b -> Type.Cdsat_Theory_Value_Bool (not b)
      | _ -> self
      end
  axiom negate_spec : forall self : Type.cdsat_theory_value . ([#"/Users/xavier/Code/cdsat/src/theory.rs" 59 15 59 29] IsBool0.is_bool self) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 60 14 60 30] IsBool0.is_bool (negate self))
end
module Cdsat_Theory_Impl1_Negate_Impl
  use Type
  clone Cdsat_Theory_Impl1_Sort as Sort0
  clone Cdsat_Theory_Impl1_IsBool as IsBool0 with function Sort0.sort = Sort0.sort
  let rec ghost function negate (self : Type.cdsat_theory_value) : Type.cdsat_theory_value
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 59 15 59 29] IsBool0.is_bool self}
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 60 14 60 30] IsBool0.is_bool result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 62 8 65 9] match (self) with
      | Type.Cdsat_Theory_Value_Bool b -> Type.Cdsat_Theory_Value_Bool (not b)
      | _ -> self
      end
end
module Cdsat_Theory_Impl4_TrailUnique_Interface
  use Type
  predicate trail_unique (self : Type.cdsat_theory_trail)
end
module Cdsat_Theory_Impl4_TrailUnique
  use Type
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone Cdsat_Theory_Impl1_IsBool_Interface as IsBool0
  clone Cdsat_Theory_Impl1_Negate_Interface as Negate0 with predicate IsBool0.is_bool = IsBool0.is_bool, axiom .
  clone Cdsat_Theory_Impl4_Contains_Interface as Contains0 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl2_ToPair_Interface as ToPair0
  predicate trail_unique [#"/Users/xavier/Code/cdsat/src/theory.rs" 272 4 272 33] (self : Type.cdsat_theory_trail) =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 273 8 285 9] match (self) with
      | Type.Cdsat_Theory_Trail_Empty -> true
      | Type.Cdsat_Theory_Trail_Assign a l tl -> let ap = ToPair0.to_pair a in not Contains0.contains tl ap /\ trail_unique tl /\ (if IsBool0.is_bool (let (_, a) = ap in a) then
        not Contains0.contains tl (let (a, _) = ap in a, Negate0.negate (let (_, a) = ap in a))
      else
        true
      )
      end
end
module Cdsat_Theory_Impl4_Invariant_Interface
  use Type
  predicate invariant' (self : Type.cdsat_theory_trail)
end
module Cdsat_Theory_Impl4_Invariant
  use Type
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl4_TrailUnique_Interface as TrailUnique0
  clone Cdsat_Theory_Impl4_InvariantContains_Interface as InvariantContains0
  clone Cdsat_Theory_Impl4_InvariantLevel_Interface as InvariantLevel0
  predicate invariant' [#"/Users/xavier/Code/cdsat/src/theory.rs" 289 4 289 34] (self : Type.cdsat_theory_trail) =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 290 8 294 38] InvariantLevel0.invariant_level self /\ InvariantContains0.invariant_contains self /\ TrailUnique0.trail_unique self /\ InvariantNonneg0.invariant_nonneg self /\ InvariantAssign0.invariant_assign self
end
module Cdsat_Trail_Impl6_Invariant_Interface
  use Type
  predicate invariant' (self : Type.cdsat_trail_trail)
end
module Cdsat_Trail_Impl6_Invariant
  use Type
  use mach.int.UInt64
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_Invariant_Interface as Invariant0
  clone Cdsat_Theory_Impl4_Sound_Interface as Sound0
  clone Cdsat_Trail_Impl6_AbstractRelation_Interface as AbstractRelation0
  predicate invariant' [#"/Users/xavier/Code/cdsat/src/trail.rs" 205 4 205 34] (self : Type.cdsat_trail_trail) =
    [#"/Users/xavier/Code/cdsat/src/trail.rs" 206 8 211 9] AbstractRelation0.abstract_relation self /\ Sound0.sound (Type.cdsat_trail_trail_Trail_ghost self) /\ Invariant0.invariant' (Type.cdsat_trail_trail_Trail_ghost self) /\ Level0.level (Type.cdsat_trail_trail_Trail_ghost self) = UInt64.to_int (Type.cdsat_trail_trail_Trail_level self)
end
module Cdsat_Theory_Impl4_SatisfiedBy_Interface
  use Type
  predicate satisfied_by (self : Type.cdsat_theory_trail) (m : Type.cdsat_theory_model)
end
module Cdsat_Theory_Impl4_SatisfiedBy
  use Type
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone Cdsat_Theory_Impl3_Satisfies_Interface as Satisfies0
  clone Cdsat_Theory_Impl4_Contains_Interface as Contains0 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, axiom .
  predicate satisfied_by [#"/Users/xavier/Code/cdsat/src/theory.rs" 431 4 431 43] (self : Type.cdsat_theory_trail) (m : Type.cdsat_theory_model)
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 432 8 432 71] forall a : ((Type.cdsat_theory_term, Type.cdsat_theory_value)) . Contains0.contains self a -> Satisfies0.satisfies m a
end
module Cdsat_Theory_Impl4_CountBounds_Interface
  use Type
  use mach.int.Int
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_LevelOf_Interface as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_Contains_Interface as Contains0 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_Invariant_Interface as Invariant0
  function count_bounds (self : Type.cdsat_theory_trail) : ()
end
module Cdsat_Theory_Impl4_CountBounds
  use Type
  use mach.int.Int
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_LevelOf_Interface as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_Contains_Interface as Contains0 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_Invariant_Interface as Invariant0
  function count_bounds [#"/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 31] (self : Type.cdsat_theory_trail) : () =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 470 8 475 9] match (self) with
      | Type.Cdsat_Theory_Trail_Empty -> ()
      | Type.Cdsat_Theory_Trail_Assign (Type.Cdsat_Theory_Assign_Input _ _) _ tl -> count_bounds tl
      | Type.Cdsat_Theory_Trail_Assign (Type.Cdsat_Theory_Assign_Decision _ _) _ tl -> count_bounds tl
      | Type.Cdsat_Theory_Trail_Assign (Type.Cdsat_Theory_Assign_Justified _ _ _) _ tl -> count_bounds tl
      end
  axiom count_bounds_spec : forall self : Type.cdsat_theory_trail . ([#"/Users/xavier/Code/cdsat/src/theory.rs" 467 15 467 31] Invariant0.invariant' self) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 468 4 468 83] forall a : ((Type.cdsat_theory_term, Type.cdsat_theory_value)) . Contains0.contains self a -> LevelOf0.level_of self a <= Level0.level self)
end
module Cdsat_Theory_Impl4_CountBounds_Impl
  use Type
  use mach.int.Int
  clone CreusotContracts_Logic_Fset_Impl0_Remove as Remove0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl1_Sort as Sort1
  clone Cdsat_Theory_Impl0_Sort as Sort0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl2_Invariant as Invariant1 with function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl1_IsBool as IsBool0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl1_Negate as Negate0 with predicate IsBool0.is_bool = IsBool0.is_bool, axiom .
  clone CreusotContracts_Logic_Fset_Impl0_Contains as Contains1 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_Len as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantAssign as InvariantAssign0 with predicate Invariant0.invariant' = Invariant1.invariant'
  clone Cdsat_Theory_Impl2_ToPair as ToPair0
  clone Cdsat_Theory_Impl4_InvariantNonneg as InvariantNonneg0 with function Level0.level = Level0.level,
  function Len0.len = Len0.len
  clone Cdsat_Theory_Impl4_Find as Find0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_LevelOf as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_SetLevel as SetLevel0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, function Len0.len = Len0.len, function Remove0.remove = Remove0.remove, axiom .
  clone Cdsat_Theory_Impl4_Contains as Contains0 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_TrailUnique as TrailUnique0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate Contains0.contains = Contains0.contains, predicate IsBool0.is_bool = IsBool0.is_bool,
  function Negate0.negate = Negate0.negate,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_InvariantContains as InvariantContains0 with predicate Contains0.contains = Contains1.contains,
  predicate Contains1.contains = Contains0.contains,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_InvariantLevel as InvariantLevel0 with function Level0.level = Level0.level,
  function SetLevel0.set_level = SetLevel0.set_level, function Len0.len = Len0.len,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of
  clone Cdsat_Theory_Impl4_Invariant as Invariant0 with predicate InvariantLevel0.invariant_level = InvariantLevel0.invariant_level,
  predicate InvariantContains0.invariant_contains = InvariantContains0.invariant_contains,
  predicate TrailUnique0.trail_unique = TrailUnique0.trail_unique,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign
  let rec ghost function count_bounds (self : Type.cdsat_theory_trail) : ()
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 467 15 467 31] Invariant0.invariant' self}
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 468 4 468 83] forall a : ((Type.cdsat_theory_term, Type.cdsat_theory_value)) . Contains0.contains self a -> LevelOf0.level_of self a <= Level0.level self }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 470 8 475 9] match (self) with
      | Type.Cdsat_Theory_Trail_Empty -> ()
      | Type.Cdsat_Theory_Trail_Assign (Type.Cdsat_Theory_Assign_Input _ _) _ tl -> count_bounds tl
      | Type.Cdsat_Theory_Trail_Assign (Type.Cdsat_Theory_Assign_Decision _ _) _ tl -> count_bounds tl
      | Type.Cdsat_Theory_Trail_Assign (Type.Cdsat_Theory_Assign_Justified _ _ _) _ tl -> count_bounds tl
      end
end
module Cdsat_Theory_Impl4_Restrict_Interface
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_SatisfiedBy_Interface as SatisfiedBy0
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_LevelOf_Interface as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_Contains_Interface as Contains0 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_Invariant_Interface as Invariant0
  function restrict (self : Type.cdsat_theory_trail) (level : int) : Type.cdsat_theory_trail
end
module Cdsat_Theory_Impl4_Restrict
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_SatisfiedBy_Interface as SatisfiedBy0
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_LevelOf_Interface as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_Contains_Interface as Contains0 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_Invariant_Interface as Invariant0
  clone Cdsat_Theory_Impl4_CountBounds_Interface as CountBounds0 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Len0.len = Len0.len, axiom .
  function restrict [#"/Users/xavier/Code/cdsat/src/theory.rs" 376 4 376 45] (self : Type.cdsat_theory_trail) (level : int) : Type.cdsat_theory_trail
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 377 8 388 9] match (self) with
      | Type.Cdsat_Theory_Trail_Empty -> Type.Cdsat_Theory_Trail_Empty
      | Type.Cdsat_Theory_Trail_Assign a l tl -> let tl = restrict tl level in let _ = CountBounds0.count_bounds tl in if l <= level then
        Type.Cdsat_Theory_Trail_Assign a l tl
      else
        tl
      
      end
  axiom restrict_spec : forall self : Type.cdsat_theory_trail, level : int . ([#"/Users/xavier/Code/cdsat/src/theory.rs" 365 15 365 31] Invariant0.invariant' self) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 367 15 367 25] level >= 0) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 375 14 375 40] Len0.len (restrict self level) <= Len0.len self) && ([#"/Users/xavier/Code/cdsat/src/theory.rs" 374 4 374 71] Level0.level self < level -> Level0.level (restrict self level) = Level0.level self) && ([#"/Users/xavier/Code/cdsat/src/theory.rs" 373 4 373 65] Level0.level self >= level -> Level0.level (restrict self level) = level) && ([#"/Users/xavier/Code/cdsat/src/theory.rs" 372 4 372 77] forall m : (Type.cdsat_theory_model) . SatisfiedBy0.satisfied_by self m -> SatisfiedBy0.satisfied_by (restrict self level) m) && ([#"/Users/xavier/Code/cdsat/src/theory.rs" 371 4 371 71] forall a : ((Type.cdsat_theory_term, Type.cdsat_theory_value)) . not Contains0.contains self a -> not Contains0.contains (restrict self level) a) && ([#"/Users/xavier/Code/cdsat/src/theory.rs" 370 4 370 56] level >= Level0.level self -> restrict self level = self) && ([#"/Users/xavier/Code/cdsat/src/theory.rs" 369 4 369 100] forall a : ((Type.cdsat_theory_term, Type.cdsat_theory_value)) . Contains0.contains (restrict self level) a -> Contains0.contains self a /\ LevelOf0.level_of (restrict self level) a <= level) && ([#"/Users/xavier/Code/cdsat/src/theory.rs" 368 4 368 141] forall a : ((Type.cdsat_theory_term, Type.cdsat_theory_value)) . Contains0.contains self a -> LevelOf0.level_of self a <= level -> Contains0.contains (restrict self level) a /\ LevelOf0.level_of (restrict self level) a = LevelOf0.level_of self a) && ([#"/Users/xavier/Code/cdsat/src/theory.rs" 366 14 366 32] Invariant0.invariant' (restrict self level))
end
module Cdsat_Theory_Impl4_Restrict_Impl
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone CreusotContracts_Logic_Fset_Impl0_Remove as Remove0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl1_Sort as Sort1
  clone Cdsat_Theory_Impl3_Invariant as Invariant2 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl0_Sort as Sort0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl3_Interp as Interp0 with predicate Invariant0.invariant' = Invariant2.invariant',
  function Sort0.sort = Sort1.sort, function Sort1.sort = Sort0.sort, axiom .
  clone Cdsat_Theory_Impl2_Invariant as Invariant1 with function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl1_IsBool as IsBool0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl1_Negate as Negate0 with predicate IsBool0.is_bool = IsBool0.is_bool, axiom .
  clone CreusotContracts_Logic_Fset_Impl0_Contains as Contains1 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_Len as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantAssign as InvariantAssign0 with predicate Invariant0.invariant' = Invariant1.invariant'
  clone Cdsat_Theory_Impl2_ToPair as ToPair0
  clone Cdsat_Theory_Impl4_InvariantNonneg as InvariantNonneg0 with function Level0.level = Level0.level,
  function Len0.len = Len0.len
  clone Cdsat_Theory_Impl4_Find as Find0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_LevelOf as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_SetLevel as SetLevel0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, function Len0.len = Len0.len, function Remove0.remove = Remove0.remove, axiom .
  clone Cdsat_Theory_Impl3_Satisfies as Satisfies0 with function Interp0.interp = Interp0.interp,
  predicate Invariant0.invariant' = Invariant2.invariant', function Sort0.sort = Sort1.sort,
  function Sort1.sort = Sort0.sort
  clone Cdsat_Theory_Impl4_Contains as Contains0 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_TrailUnique as TrailUnique0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate Contains0.contains = Contains0.contains, predicate IsBool0.is_bool = IsBool0.is_bool,
  function Negate0.negate = Negate0.negate,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_InvariantContains as InvariantContains0 with predicate Contains0.contains = Contains1.contains,
  predicate Contains1.contains = Contains0.contains,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_InvariantLevel as InvariantLevel0 with function Level0.level = Level0.level,
  function SetLevel0.set_level = SetLevel0.set_level, function Len0.len = Len0.len,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of
  clone Cdsat_Theory_Impl4_Invariant as Invariant0 with predicate InvariantLevel0.invariant_level = InvariantLevel0.invariant_level,
  predicate InvariantContains0.invariant_contains = InvariantContains0.invariant_contains,
  predicate TrailUnique0.trail_unique = TrailUnique0.trail_unique,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign
  clone Cdsat_Theory_Impl4_CountBounds as CountBounds0 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_SatisfiedBy as SatisfiedBy0 with predicate Contains0.contains = Contains0.contains,
  predicate Satisfies0.satisfies = Satisfies0.satisfies,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  let rec ghost function restrict (self : Type.cdsat_theory_trail) (level : int) : Type.cdsat_theory_trail
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 365 15 365 31] Invariant0.invariant' self}
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 367 15 367 25] level >= 0}
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 366 14 366 32] Invariant0.invariant' result }
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 368 4 368 141] forall a : ((Type.cdsat_theory_term, Type.cdsat_theory_value)) . Contains0.contains self a -> LevelOf0.level_of self a <= level -> Contains0.contains result a /\ LevelOf0.level_of result a = LevelOf0.level_of self a }
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 369 4 369 100] forall a : ((Type.cdsat_theory_term, Type.cdsat_theory_value)) . Contains0.contains result a -> Contains0.contains self a /\ LevelOf0.level_of result a <= level }
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 370 4 370 56] level >= Level0.level self -> result = self }
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 371 4 371 71] forall a : ((Type.cdsat_theory_term, Type.cdsat_theory_value)) . not Contains0.contains self a -> not Contains0.contains result a }
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 372 4 372 77] forall m : (Type.cdsat_theory_model) . SatisfiedBy0.satisfied_by self m -> SatisfiedBy0.satisfied_by result m }
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 373 4 373 65] Level0.level self >= level -> Level0.level result = level }
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 374 4 374 71] Level0.level self < level -> Level0.level result = Level0.level self }
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 375 14 375 40] Len0.len result <= Len0.len self }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 377 8 388 9] match (self) with
      | Type.Cdsat_Theory_Trail_Empty -> Type.Cdsat_Theory_Trail_Empty
      | Type.Cdsat_Theory_Trail_Assign a l tl -> let tl = restrict tl level in let _ = CountBounds0.count_bounds tl in if l <= level then
        Type.Cdsat_Theory_Trail_Assign a l tl
      else
        tl
      
      end
end
module Cdsat_Theory_Impl4_Unsat_Interface
  use Type
  predicate unsat (self : Type.cdsat_theory_trail)
end
module Cdsat_Theory_Impl4_Unsat
  use Type
  use mach.int.Int
  use mach.int.Int32
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_LevelOf_Interface as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_Contains_Interface as Contains0 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_Invariant_Interface as Invariant1
  clone Cdsat_Theory_Impl4_SatisfiedBy_Interface as SatisfiedBy0
  clone Cdsat_Theory_Impl4_Restrict_Interface as Restrict0 with predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  function Len0.len = Len0.len, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, axiom .
  clone Cdsat_Theory_Impl3_Invariant_Interface as Invariant0
  predicate unsat [#"/Users/xavier/Code/cdsat/src/theory.rs" 437 4 437 30] (self : Type.cdsat_theory_trail) =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 438 8 438 100] forall m : (Type.cdsat_theory_model) . Invariant0.invariant' m -> SatisfiedBy0.satisfied_by (Restrict0.restrict self 0) m -> false
end
module Cdsat_Theory_Impl4_Impls_Interface
  use Type
  clone Cdsat_Theory_Impl4_Unsat_Interface as Unsat0
  predicate impls (self : Type.cdsat_theory_trail) (rhs : Type.cdsat_theory_trail)
end
module Cdsat_Theory_Impl4_Impls
  use Type
  clone Cdsat_Theory_Impl4_Unsat_Interface as Unsat0
  use mach.int.Int
  use mach.int.Int32
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_LevelOf_Interface as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_Contains_Interface as Contains0 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_Invariant_Interface as Invariant1
  clone Cdsat_Theory_Impl4_SatisfiedBy_Interface as SatisfiedBy0
  clone Cdsat_Theory_Impl4_Restrict_Interface as Restrict0 with predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  function Len0.len = Len0.len, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, axiom .
  clone Cdsat_Theory_Impl3_Invariant_Interface as Invariant0
  predicate impls [#"/Users/xavier/Code/cdsat/src/theory.rs" 448 4 448 41] (self : Type.cdsat_theory_trail) (rhs : Type.cdsat_theory_trail)
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 449 8 449 126] forall m : (Type.cdsat_theory_model) . Invariant0.invariant' m -> SatisfiedBy0.satisfied_by (Restrict0.restrict self 0) m -> SatisfiedBy0.satisfied_by (Restrict0.restrict rhs 0) m
  axiom impls_spec : forall self : Type.cdsat_theory_trail, rhs : Type.cdsat_theory_trail . [#"/Users/xavier/Code/cdsat/src/theory.rs" 447 4 447 57] impls self rhs -> Unsat0.unsat rhs -> Unsat0.unsat self
end
module Cdsat_Theory_Impl4_Impls_Impl
  use Type
  use mach.int.Int
  use mach.int.Int32
  clone CreusotContracts_Logic_Fset_Impl0_Remove as Remove0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl1_Sort as Sort1
  clone Cdsat_Theory_Impl1_IsBool as IsBool0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl1_Negate as Negate0 with predicate IsBool0.is_bool = IsBool0.is_bool, axiom .
  clone CreusotContracts_Logic_Fset_Impl0_Contains as Contains1 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_Len as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl0_Sort as Sort0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl2_Invariant as Invariant2 with function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_InvariantAssign as InvariantAssign0 with predicate Invariant0.invariant' = Invariant2.invariant'
  clone Cdsat_Theory_Impl2_ToPair as ToPair0
  clone Cdsat_Theory_Impl4_InvariantNonneg as InvariantNonneg0 with function Level0.level = Level0.level,
  function Len0.len = Len0.len
  clone Cdsat_Theory_Impl4_Find as Find0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_LevelOf as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_SetLevel as SetLevel0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, function Len0.len = Len0.len, function Remove0.remove = Remove0.remove, axiom .
  clone Cdsat_Theory_Impl3_Invariant as Invariant0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl3_Interp as Interp0 with predicate Invariant0.invariant' = Invariant0.invariant',
  function Sort0.sort = Sort1.sort, function Sort1.sort = Sort0.sort, axiom .
  clone Cdsat_Theory_Impl4_Contains as Contains0 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_TrailUnique as TrailUnique0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate Contains0.contains = Contains0.contains, predicate IsBool0.is_bool = IsBool0.is_bool,
  function Negate0.negate = Negate0.negate,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_InvariantContains as InvariantContains0 with predicate Contains0.contains = Contains1.contains,
  predicate Contains1.contains = Contains0.contains,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_InvariantLevel as InvariantLevel0 with function Level0.level = Level0.level,
  function SetLevel0.set_level = SetLevel0.set_level, function Len0.len = Len0.len,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of
  clone Cdsat_Theory_Impl3_Satisfies as Satisfies0 with function Interp0.interp = Interp0.interp,
  predicate Invariant0.invariant' = Invariant0.invariant', function Sort0.sort = Sort1.sort,
  function Sort1.sort = Sort0.sort
  clone Cdsat_Theory_Impl4_Invariant as Invariant1 with predicate InvariantLevel0.invariant_level = InvariantLevel0.invariant_level,
  predicate InvariantContains0.invariant_contains = InvariantContains0.invariant_contains,
  predicate TrailUnique0.trail_unique = TrailUnique0.trail_unique,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign
  clone Cdsat_Theory_Impl4_CountBounds as CountBounds0 with predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_SatisfiedBy as SatisfiedBy0 with predicate Contains0.contains = Contains0.contains,
  predicate Satisfies0.satisfies = Satisfies0.satisfies,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_Restrict as Restrict0 with predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  function Len0.len = Len0.len, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function CountBounds0.count_bounds = CountBounds0.count_bounds, axiom .
  clone Cdsat_Theory_Impl4_Unsat as Unsat0 with predicate Invariant0.invariant' = Invariant0.invariant',
  function Restrict0.restrict = Restrict0.restrict, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  predicate Invariant1.invariant' = Invariant1.invariant', predicate Contains0.contains = Contains0.contains,
  function LevelOf0.level_of = LevelOf0.level_of, function Level0.level = Level0.level, function Len0.len = Len0.len,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg
  let rec ghost function impls (self : Type.cdsat_theory_trail) (rhs : Type.cdsat_theory_trail) : bool
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 447 4 447 57] result -> Unsat0.unsat rhs -> Unsat0.unsat self }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 449 8 449 126] pure {forall m : (Type.cdsat_theory_model) . Invariant0.invariant' m -> SatisfiedBy0.satisfied_by (Restrict0.restrict self 0) m -> SatisfiedBy0.satisfied_by (Restrict0.restrict rhs 0) m}
end
module Cdsat_Trail_Impl6_Unsat_Interface
  use Type
  predicate unsat (self : Type.cdsat_trail_trail)
end
module Cdsat_Trail_Impl6_Unsat
  use Type
  clone Cdsat_Theory_Impl4_Unsat_Interface as Unsat0
  predicate unsat [#"/Users/xavier/Code/cdsat/src/trail.rs" 195 4 195 30] (self : Type.cdsat_trail_trail) =
    [#"/Users/xavier/Code/cdsat/src/trail.rs" 194 4 194 16] Unsat0.unsat (Type.cdsat_trail_trail_Trail_ghost self)
end
module CreusotContracts_Logic_Fset_Impl0_Insert_Interface
  type t
  use set.Fset
  function insert [@inline:trivial] (self : Fset.fset t) (e : t) : Fset.fset t
end
module CreusotContracts_Logic_Fset_Impl0_Insert
  type t
  use set.Fset
  function insert [@inline:trivial] (self : Fset.fset t) (e : t) : Fset.fset t =
    Fset.add e self
end
module Cdsat_Trail_Impl6_AbsJustInner_Interface
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use set.Fset
  clone Cdsat_Trail_Impl8_TermValue_Interface as TermValue0
  clone CreusotContracts_Logic_Fset_Impl0_Contains_Interface as Contains0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.cdsat_trail_assignment,
  type a = Type.alloc_alloc_global, axiom .
  function abs_just_inner (self : Type.cdsat_trail_trail) (just : Seq.seq usize) (ix : int) : Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value)
    
end
module Cdsat_Trail_Impl6_AbsJustInner
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use set.Fset
  clone Cdsat_Trail_Impl8_TermValue_Interface as TermValue0
  clone CreusotContracts_Logic_Fset_Impl0_Contains_Interface as Contains0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.cdsat_trail_assignment,
  type a = Type.alloc_alloc_global, axiom .
  clone CreusotContracts_Logic_Fset_Impl0_Insert_Interface as Insert0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Trail_Impl4_Model_Interface as Model2
  clone Cdsat_Trail_Impl3_Model_Interface as Model1
  function abs_just_inner [#"/Users/xavier/Code/cdsat/src/trail.rs" 274 4 274 97] (self : Type.cdsat_trail_trail) (just : Seq.seq usize) (ix : int) : Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value)
    
  axiom def : forall self : Type.cdsat_trail_trail, just : Seq.seq usize, ix : int . abs_just_inner self just ix = ([#"/Users/xavier/Code/cdsat/src/trail.rs" 267 4 267 12] if ix < Seq.length just then
    let set = abs_just_inner self just (ix + 1) in let a = Seq.get (Model0.model (Type.cdsat_trail_trail_Trail_assignments self)) (UInt64.to_int (Seq.get just ix)) in Insert0.insert set (Model1.model (Type.cdsat_trail_assignment_Assignment_term a), Model2.model (Type.cdsat_trail_assignment_Assignment_val a))
  else
    Fset.empty 
  )
  axiom abs_just_inner_spec : forall self : Type.cdsat_trail_trail, just : Seq.seq usize, ix : int . ([#"/Users/xavier/Code/cdsat/src/trail.rs" 269 15 269 22] ix >= 0) -> ([#"/Users/xavier/Code/cdsat/src/trail.rs" 270 4 270 96] forall i : (int) . 0 <= i /\ i < Seq.length just -> UInt64.to_int (Seq.get just i) < Seq.length (Model0.model (Type.cdsat_trail_trail_Trail_assignments self))) -> ([#"/Users/xavier/Code/cdsat/src/trail.rs" 273 4 273 120] forall i : (int) . ix <= i /\ i < Seq.length just -> Contains0.contains (abs_just_inner self just ix) (TermValue0.term_value (Seq.get (Model0.model (Type.cdsat_trail_trail_Trail_assignments self)) (UInt64.to_int (Seq.get just i))))) && ([#"/Users/xavier/Code/cdsat/src/trail.rs" 272 4 272 143] forall a : ((Type.cdsat_theory_term, Type.cdsat_theory_value)) . Contains0.contains (abs_just_inner self just ix) a -> (exists i : (int) . ix <= i /\ i < Seq.length just /\ a = TermValue0.term_value (Seq.get (Model0.model (Type.cdsat_trail_trail_Trail_assignments self)) (UInt64.to_int (Seq.get just i))))) && ([#"/Users/xavier/Code/cdsat/src/trail.rs" 271 4 271 150] forall a : ((Type.cdsat_theory_term, Type.cdsat_theory_value)) . Contains0.contains (abs_just_inner self just ix) a -> (exists i : (int) . 0 <= i /\ i < Seq.length (Model0.model (Type.cdsat_trail_trail_Trail_assignments self)) /\ a = TermValue0.term_value (Seq.get (Model0.model (Type.cdsat_trail_trail_Trail_assignments self)) i)))
end
module Cdsat_Trail_Impl6_AbstractJustification_Interface
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use set.Fset
  clone Cdsat_Trail_Impl8_TermValue_Interface as TermValue0
  clone CreusotContracts_Logic_Fset_Impl0_Contains_Interface as Contains0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.cdsat_trail_assignment,
  type a = Type.alloc_alloc_global, axiom .
  function abstract_justification (self : Type.cdsat_trail_trail) (just : Seq.seq usize) : Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value)
    
end
module Cdsat_Trail_Impl6_AbstractJustification
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use set.Fset
  clone Cdsat_Trail_Impl8_TermValue_Interface as TermValue0
  clone CreusotContracts_Logic_Fset_Impl0_Contains_Interface as Contains0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.cdsat_trail_assignment,
  type a = Type.alloc_alloc_global, axiom .
  clone Cdsat_Trail_Impl6_AbsJustInner_Interface as AbsJustInner0 with function Model0.model = Model0.model,
  predicate Contains0.contains = Contains0.contains, function TermValue0.term_value = TermValue0.term_value, axiom .
  function abstract_justification [#"/Users/xavier/Code/cdsat/src/trail.rs" 263 4 263 97] (self : Type.cdsat_trail_trail) (just : Seq.seq usize) : Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value)
    
  axiom def : forall self : Type.cdsat_trail_trail, just : Seq.seq usize . abstract_justification self just = ([#"/Users/xavier/Code/cdsat/src/trail.rs" 264 8 264 36] AbsJustInner0.abs_just_inner self just 0)
  axiom abstract_justification_spec : forall self : Type.cdsat_trail_trail, just : Seq.seq usize . ([#"/Users/xavier/Code/cdsat/src/trail.rs" 258 4 258 96] forall i : (int) . 0 <= i /\ i < Seq.length just -> UInt64.to_int (Seq.get just i) < Seq.length (Model0.model (Type.cdsat_trail_trail_Trail_assignments self))) -> ([#"/Users/xavier/Code/cdsat/src/trail.rs" 261 4 261 119] forall i : (int) . 0 <= i /\ i < Seq.length just -> Contains0.contains (abstract_justification self just) (TermValue0.term_value (Seq.get (Model0.model (Type.cdsat_trail_trail_Trail_assignments self)) (UInt64.to_int (Seq.get just i))))) && ([#"/Users/xavier/Code/cdsat/src/trail.rs" 260 4 260 142] forall a : ((Type.cdsat_theory_term, Type.cdsat_theory_value)) . Contains0.contains (abstract_justification self just) a -> (exists i : (int) . 0 <= i /\ i < Seq.length just /\ a = TermValue0.term_value (Seq.get (Model0.model (Type.cdsat_trail_trail_Trail_assignments self)) (UInt64.to_int (Seq.get just i))))) && ([#"/Users/xavier/Code/cdsat/src/trail.rs" 259 4 259 150] forall a : ((Type.cdsat_theory_term, Type.cdsat_theory_value)) . Contains0.contains (abstract_justification self just) a -> (exists i : (int) . 0 <= i /\ i < Seq.length (Model0.model (Type.cdsat_trail_trail_Trail_assignments self)) /\ a = TermValue0.term_value (Seq.get (Model0.model (Type.cdsat_trail_trail_Trail_assignments self)) i)))
end
module Cdsat_Theory_Impl5_Sound_Interface
  use Type
  predicate sound [@inline:trivial] (self : Type.cdsat_theory_normal)
end
module Cdsat_Theory_Impl5_Sound
  use Type
  clone Cdsat_Theory_Impl4_Sound_Interface as Sound0
  predicate sound [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 533 4 533 30] (self : Type.cdsat_theory_normal)
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 531 4 531 16] Sound0.sound (Type.cdsat_theory_normal_Normal_0 self)
end
module Cdsat_Theory_Impl5_Fail2_Interface
  use Type
  use set.Fset
  clone Cdsat_Theory_Impl4_Unsat_Interface as Unsat0
  clone Cdsat_Theory_Impl5_Sound_Interface as Sound0
  clone Cdsat_Theory_Impl4_Invariant_Interface as Invariant0
  predicate fail2 (self : Type.cdsat_theory_normal) (just : Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value))
end
module Cdsat_Theory_Impl5_Fail2
  use Type
  use set.Fset
  clone Cdsat_Theory_Impl4_Unsat_Interface as Unsat0
  clone Cdsat_Theory_Impl5_Sound_Interface as Sound0
  clone Cdsat_Theory_Impl4_Invariant_Interface as Invariant0
  use mach.int.Int
  use mach.int.Int32
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl4_LevelOf_Interface as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone CreusotContracts_Logic_Fset_Impl0_Contains_Interface as Contains0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_SetLevel_Interface as SetLevel0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl3_SatisfySet_Interface as SatisfySet0
  clone Cdsat_Theory_Impl4_Contains_Interface as Contains1 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, axiom .
  predicate fail2 [#"/Users/xavier/Code/cdsat/src/theory.rs" 592 4 592 57] (self : Type.cdsat_theory_normal) (just : Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value))
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 596 12 598 39] (forall j : ((Type.cdsat_theory_term, Type.cdsat_theory_value)) . Contains0.contains just j -> Contains1.contains (Type.cdsat_theory_normal_Normal_0 self) j) /\ (forall m : (Type.cdsat_theory_model) . SatisfySet0.satisfy_set m just -> false) /\ SetLevel0.set_level (Type.cdsat_theory_normal_Normal_0 self) just = 0
  axiom fail2_spec : forall self : Type.cdsat_theory_normal, just : Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value) . ([#"/Users/xavier/Code/cdsat/src/theory.rs" 589 15 589 35] Invariant0.invariant' (Type.cdsat_theory_normal_Normal_0 self)) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 590 15 590 27] Sound0.sound self) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 591 4 591 41] fail2 self just -> Unsat0.unsat (Type.cdsat_theory_normal_Normal_0 self))
end
module Cdsat_Theory_Impl5_Fail2_Impl
  use Type
  use set.Fset
  use mach.int.Int
  use mach.int.Int32
  clone Cdsat_Theory_Impl1_Sort as Sort1
  clone Cdsat_Theory_Impl0_Sort as Sort0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl3_Invariant as Invariant1 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl3_Interp as Interp0 with predicate Invariant0.invariant' = Invariant1.invariant',
  function Sort0.sort = Sort1.sort, function Sort1.sort = Sort0.sort, axiom .
  clone Cdsat_Theory_Impl4_Len as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg as InvariantNonneg0 with function Level0.level = Level0.level,
  function Len0.len = Len0.len
  clone Cdsat_Theory_Impl2_Invariant as Invariant2 with function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_InvariantAssign as InvariantAssign0 with predicate Invariant0.invariant' = Invariant2.invariant'
  clone Cdsat_Theory_Impl2_ToPair as ToPair0
  clone Cdsat_Theory_Impl4_Find as Find0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_LevelOf as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_Contains as Contains1 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl1_IsBool as IsBool0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl1_Negate as Negate0 with predicate IsBool0.is_bool = IsBool0.is_bool, axiom .
  clone Cdsat_Theory_Impl4_TrailUnique as TrailUnique0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate Contains0.contains = Contains1.contains, predicate IsBool0.is_bool = IsBool0.is_bool,
  function Negate0.negate = Negate0.negate,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone CreusotContracts_Logic_Fset_Impl0_Contains as Contains0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_InvariantContains as InvariantContains0 with predicate Contains0.contains = Contains0.contains,
  predicate Contains1.contains = Contains1.contains,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone CreusotContracts_Logic_Fset_Impl0_Remove as Remove0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_SetLevel as SetLevel0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, function Len0.len = Len0.len, function Remove0.remove = Remove0.remove, axiom .
  clone Cdsat_Theory_Impl4_InvariantLevel as InvariantLevel0 with function Level0.level = Level0.level,
  function SetLevel0.set_level = SetLevel0.set_level, function Len0.len = Len0.len,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of
  clone Cdsat_Theory_Impl4_Invariant as Invariant0 with predicate InvariantLevel0.invariant_level = InvariantLevel0.invariant_level,
  predicate InvariantContains0.invariant_contains = InvariantContains0.invariant_contains,
  predicate TrailUnique0.trail_unique = TrailUnique0.trail_unique,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign
  clone Cdsat_Theory_Impl4_CountBounds as CountBounds0 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl3_Satisfies as Satisfies0 with function Interp0.interp = Interp0.interp,
  predicate Invariant0.invariant' = Invariant1.invariant', function Sort0.sort = Sort1.sort,
  function Sort1.sort = Sort0.sort
  clone Cdsat_Theory_Impl3_SatisfySet as SatisfySet0 with predicate Contains0.contains = Contains0.contains,
  predicate Satisfies0.satisfies = Satisfies0.satisfies
  clone Cdsat_Theory_Impl2_JustifiedSound as JustifiedSound0 with predicate Invariant0.invariant' = Invariant1.invariant',
  predicate SatisfySet0.satisfy_set = SatisfySet0.satisfy_set, predicate Satisfies0.satisfies = Satisfies0.satisfies
  clone Cdsat_Theory_Impl4_SatisfiedBy as SatisfiedBy0 with predicate Contains0.contains = Contains1.contains,
  predicate Satisfies0.satisfies = Satisfies0.satisfies,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_Restrict as Restrict0 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  function Len0.len = Len0.len, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function CountBounds0.count_bounds = CountBounds0.count_bounds, axiom .
  clone Cdsat_Theory_Impl4_Sound as Sound1 with predicate JustifiedSound0.justified_sound = JustifiedSound0.justified_sound
  clone Cdsat_Theory_Impl4_Unsat as Unsat0 with predicate Invariant0.invariant' = Invariant1.invariant',
  function Restrict0.restrict = Restrict0.restrict, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  predicate Invariant1.invariant' = Invariant0.invariant', predicate Contains0.contains = Contains1.contains,
  function LevelOf0.level_of = LevelOf0.level_of, function Level0.level = Level0.level, function Len0.len = Len0.len,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg
  clone Cdsat_Theory_Impl5_Sound as Sound0 with predicate Sound0.sound = Sound1.sound
  let rec ghost function fail2 (self : Type.cdsat_theory_normal) (just : Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value)) : bool
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 589 15 589 35] Invariant0.invariant' (Type.cdsat_theory_normal_Normal_0 self)}
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 590 15 590 27] Sound0.sound self}
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 591 4 591 41] result -> Unsat0.unsat (Type.cdsat_theory_normal_Normal_0 self) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 596 12 598 39] pure {forall j : ((Type.cdsat_theory_term, Type.cdsat_theory_value)) . Contains0.contains just j -> Contains1.contains (Type.cdsat_theory_normal_Normal_0 self) j} && pure {forall m : (Type.cdsat_theory_model) . SatisfySet0.satisfy_set m just -> false} && (let a = let a' = Type.cdsat_theory_normal_Normal_0 self in SetLevel0.set_level a' just in pure {a = 0})
end
module Cdsat_Theory_Impl4_Acceptable_Interface
  use Type
  predicate acceptable (self : Type.cdsat_theory_trail) (t : Type.cdsat_theory_term) (val' : Type.cdsat_theory_value)
end
module Cdsat_Theory_Impl4_Acceptable
  use Type
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone Cdsat_Theory_Impl1_IsBool_Interface as IsBool0
  clone Cdsat_Theory_Impl1_Negate_Interface as Negate0 with predicate IsBool0.is_bool = IsBool0.is_bool, axiom .
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_Contains_Interface as Contains0 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, axiom .
  predicate acceptable [#"/Users/xavier/Code/cdsat/src/theory.rs" 298 4 298 56] (self : Type.cdsat_theory_trail) (t : Type.cdsat_theory_term) (val' : Type.cdsat_theory_value)
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 299 8 301 79] not Contains0.contains self (t, val') /\ Sort0.sort t = Sort1.sort val' /\ (IsBool0.is_bool val' -> not Contains0.contains self (t, Negate0.negate val'))
end
module Cdsat_Concrete_Impl1_Extend_Interface
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  clone Cdsat_Theory_Impl4_Unsat_Interface as Unsat0
  clone Cdsat_Trail_Impl8_TermValue_Interface as TermValue0
  clone CreusotContracts_Logic_Fset_Impl0_Contains_Interface as Contains0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_Impls_Interface as Impls0 with predicate Unsat0.unsat = Unsat0.unsat, axiom .
  clone Cdsat_Theory_Impl3_SatisfySet_Interface as SatisfySet0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model3 with type t = Type.cdsat_trail_assignment,
  type a = Type.alloc_alloc_global, axiom .
  clone Cdsat_Trail_Impl6_AbstractJustification_Interface as AbstractJustification0 with function Model0.model = Model3.model,
  predicate Contains0.contains = Contains0.contains, function TermValue0.term_value = TermValue0.term_value, axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = usize, type a = Type.alloc_alloc_global,
  axiom .
  clone Cdsat_Theory_Impl4_Acceptable_Interface as Acceptable0
  clone Cdsat_Trail_Impl4_Model_Interface as Model1
  clone Cdsat_Trail_Impl3_Model_Interface as Model0
  clone Cdsat_Trail_Impl6_Invariant_Interface as Invariant0
  val extend [@cfg:stackify] (self : borrowed (Type.cdsat_concrete_booltheory)) (tl : borrowed (Type.cdsat_trail_trail)) : Type.cdsat_concrete_extendresult
    requires {[#"/Users/xavier/Code/cdsat/src/concrete.rs" 230 4 230 38] Invariant0.invariant' ( * tl)}
    ensures { [#"/Users/xavier/Code/cdsat/src/concrete.rs" 230 4 230 38] Invariant0.invariant' ( ^ tl) }
    ensures { [#"/Users/xavier/Code/cdsat/src/concrete.rs" 231 14 241 5] match (result) with
      | Type.Cdsat_Concrete_ExtendResult_Satisfied -> true
      | Type.Cdsat_Concrete_ExtendResult_Decision t v -> Acceptable0.acceptable (Type.cdsat_trail_trail_Trail_ghost ( ^ tl)) (Model0.model t) (Model1.model v)
      | Type.Cdsat_Concrete_ExtendResult_Conflict c -> let conflict = AbstractJustification0.abstract_justification ( ^ tl) (Model2.model c) in (forall i : (int) . 0 <= i /\ i < Seq.length (Model2.model c) -> UInt64.to_int (Seq.get (Model2.model c) i) < Seq.length (Model3.model (Type.cdsat_trail_trail_Trail_assignments ( ^ tl)))) /\ (forall m : (Type.cdsat_theory_model) . SatisfySet0.satisfy_set m conflict -> false)
      end }
    ensures { [#"/Users/xavier/Code/cdsat/src/concrete.rs" 242 4 242 44] Impls0.impls (Type.cdsat_trail_trail_Trail_ghost ( * tl)) (Type.cdsat_trail_trail_Trail_ghost ( ^ tl)) }
    
end
module CreusotContracts_Logic_Resolve_Impl1_Resolve_Interface
  type t
  use prelude.Prelude
  predicate resolve (self : borrowed t)
end
module CreusotContracts_Logic_Resolve_Impl1_Resolve
  type t
  use prelude.Prelude
  predicate resolve (self : borrowed t) =
     ^ self =  * self
end
module CreusotContracts_Std1_Vec_Impl3_Resolve_Interface
  type t
  use Type
  predicate resolve (self : Type.alloc_vec_vec t (Type.alloc_alloc_global))
end
module CreusotContracts_Std1_Vec_Impl3_Resolve
  type t
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve_Interface as Resolve0 with type self = t
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = t, type a = Type.alloc_alloc_global,
  axiom .
  predicate resolve (self : Type.alloc_vec_vec t (Type.alloc_alloc_global)) =
    forall i : (int) . 0 <= i /\ i < Seq.length (Model0.model self) -> Resolve0.resolve (Seq.get (Model0.model self) i)
end
module CreusotContracts_Std1_Slice_Impl0_Model_Interface
  type t
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  function model (self : seq t) : Seq.seq t
end
module CreusotContracts_Std1_Slice_Impl0_Model
  type t
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  function model (self : seq t) : Seq.seq t
  axiom model_spec : forall self : seq t . model self = Prelude.id self && Seq.length (model self) <= 18446744073709551615
end
module Alloc_Vec_Impl10_Deref_Interface
  type t
  type a
  use prelude.Prelude
  use Type
  use seq.Seq
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = t, type a = a, axiom .
  clone CreusotContracts_Std1_Slice_Impl0_Model_Interface as Model0 with type t = t, axiom .
  val deref [@cfg:stackify] (self : Type.alloc_vec_vec t a) : seq t
    ensures { Model0.model result = Model1.model self }
    
end
module Cdsat_Theory_Impl4_IsSetLevel_Interface
  use Type
  use set.Fset
  use mach.int.Int
  predicate is_set_level (self : Type.cdsat_theory_trail) (s : Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value)) (m : int)
    
end
module Cdsat_Theory_Impl4_IsSetLevel
  use Type
  use set.Fset
  use mach.int.Int
  use mach.int.Int32
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl4_LevelOf_Interface as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  clone CreusotContracts_Logic_Fset_Impl0_Contains_Interface as Contains0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  predicate is_set_level [#"/Users/xavier/Code/cdsat/src/theory.rs" 191 4 191 69] (self : Type.cdsat_theory_trail) (s : Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value)) (m : int)
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 193 12 195 67] s = Fset.empty  /\ m = 0 \/ (exists i : ((Type.cdsat_theory_term, Type.cdsat_theory_value)) . Contains0.contains s i /\ LevelOf0.level_of self i = m) /\ (forall i : ((Type.cdsat_theory_term, Type.cdsat_theory_value)) . Contains0.contains s i -> LevelOf0.level_of self i <= m)
end
module Core_Slice_Impl0_Len_Interface
  type t
  use seq.Seq
  use mach.int.UInt64
  use prelude.Prelude
  use mach.int.Int
  clone CreusotContracts_Std1_Slice_Impl0_ModelTy as ModelTy0 with type t = t
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = seq t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val len [@cfg:stackify] (self : seq t) : usize
    ensures { Seq.length (Model0.model self) = UInt64.to_int result }
    
end
module Cdsat_Trail_Impl8_Level_Interface
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  val level [@cfg:stackify] (self : Type.cdsat_trail_assignment) : usize
    ensures { [#"/Users/xavier/Code/cdsat/src/trail.rs" 421 14 421 34] result = Type.cdsat_trail_assignment_Assignment_level self }
    
end
module Cdsat_Trail_Impl6_MaxLevel_Interface
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use prelude.Prelude
  use Type
  clone Cdsat_Trail_Impl8_TermValue_Interface as TermValue0
  clone CreusotContracts_Logic_Fset_Impl0_Contains_Interface as Contains0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone CreusotContracts_Std1_Slice_Impl0_ModelTy as ModelTy0 with type t = usize
  clone Cdsat_Theory_Impl4_IsSetLevel_Interface as IsSetLevel0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.cdsat_trail_assignment,
  type a = Type.alloc_alloc_global, axiom .
  clone Cdsat_Trail_Impl6_AbstractJustification_Interface as AbstractJustification0 with function Model0.model = Model1.model,
  predicate Contains0.contains = Contains0.contains, function TermValue0.term_value = TermValue0.term_value, axiom .
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = seq usize,
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone Cdsat_Trail_Impl6_Invariant_Interface as Invariant0
  val max_level [@cfg:stackify] (self : Type.cdsat_trail_trail) (assignments : seq usize) : usize
    requires {[#"/Users/xavier/Code/cdsat/src/trail.rs" 378 15 378 31] Invariant0.invariant' self}
    requires {[#"/Users/xavier/Code/cdsat/src/trail.rs" 379 4 379 116] forall i : (int) . 0 <= i /\ i < Seq.length (Model0.model assignments) -> UInt64.to_int (Seq.get (Model0.model assignments) i) < Seq.length (Model1.model (Type.cdsat_trail_trail_Trail_assignments self))}
    ensures { [#"/Users/xavier/Code/cdsat/src/trail.rs" 380 4 380 91] IsSetLevel0.is_set_level (Type.cdsat_trail_trail_Trail_ghost self) (AbstractJustification0.abstract_justification self (Model0.model assignments)) (UInt64.to_int result) }
    
end
module CreusotContracts_Std1_Vec_Impl2_Model_Interface
  type t
  type a
  use Type
  use seq.Seq
  function model (self : Type.alloc_vec_intoiter_intoiter t a) : Seq.seq t
end
module CreusotContracts_Std1_Vec_Impl2_Model
  type t
  type a
  use Type
  use seq.Seq
  function model (self : Type.alloc_vec_intoiter_intoiter t a) : Seq.seq t
end
module CreusotContracts_Std1_Vec_Impl1_Produces_Interface
  type t
  type a
  use Type
  use seq.Seq
  predicate produces (self : Type.alloc_vec_intoiter_intoiter t a) (visited : Seq.seq t) (rhs : Type.alloc_vec_intoiter_intoiter t a)
    
end
module CreusotContracts_Std1_Vec_Impl1_Produces
  type t
  type a
  use Type
  use seq.Seq
  use mach.int.Int
  use seq_ext.SeqExt
  use mach.int.Int32
  clone CreusotContracts_Std1_Vec_Impl2_Model_Interface as Model0 with type t = t, type a = a
  predicate produces (self : Type.alloc_vec_intoiter_intoiter t a) (visited : Seq.seq t) (rhs : Type.alloc_vec_intoiter_intoiter t a)
    
   =
    Seq.length (Model0.model self) = Seq.length visited + Seq.length (Model0.model rhs) /\ Seq.(==) (SeqExt.subsequence (Model0.model self) (Seq.length visited) (Seq.length (Model0.model self))) (Model0.model rhs) /\ (forall i : (int) . 0 <= i /\ i < Seq.length visited -> Seq.get (Model0.model self) i = Seq.get visited i)
end
module Cdsat_Concrete_Impl2_Model_Interface
  use Type
  use map.Map
  use mach.int.Int
  function model (self : Type.cdsat_concrete_conflictheap) : Map.map int (Type.core_option_option int)
end
module Cdsat_Concrete_Impl2_Model
  use Type
  use map.Map
  use mach.int.Int
  function model [#"/Users/xavier/Code/cdsat/src/concrete.rs" 312 4 312 35] (self : Type.cdsat_concrete_conflictheap) : Map.map int (Type.core_option_option int)
    
end
module CreusotContracts_Logic_Seq_Impl2_Contains_Interface
  type t
  use seq.Seq
  predicate contains (self : Seq.seq t) (e : t)
end
module CreusotContracts_Logic_Seq_Impl2_Contains
  type t
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  predicate contains (self : Seq.seq t) (e : t) =
    exists i : (int) . 0 <= i /\ i < Seq.length self /\ Seq.get self i = e
end
module Cdsat_Theory_Impl6_Invariant_Interface
  use Type
  predicate invariant' (self : Type.cdsat_theory_conflict)
end
module Cdsat_Theory_Impl6_Invariant
  use Type
  use mach.int.Int
  use mach.int.Int32
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl4_LevelOf_Interface as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_Contains_Interface as Contains1 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, axiom .
  clone CreusotContracts_Logic_Fset_Impl0_Contains_Interface as Contains0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_Invariant_Interface as Invariant0
  clone Cdsat_Theory_Impl4_SetLevel_Interface as SetLevel0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  predicate invariant' [#"/Users/xavier/Code/cdsat/src/theory.rs" 646 4 646 34] (self : Type.cdsat_theory_conflict) =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 647 8 647 131] SetLevel0.set_level (Type.cdsat_theory_conflict_Conflict_0 self) (Type.cdsat_theory_conflict_Conflict_1 self) > 0 /\ Invariant0.invariant' (Type.cdsat_theory_conflict_Conflict_0 self) /\ (forall a : ((Type.cdsat_theory_term, Type.cdsat_theory_value)) . Contains0.contains (Type.cdsat_theory_conflict_Conflict_1 self) a -> Contains1.contains (Type.cdsat_theory_conflict_Conflict_0 self) a)
end
module Cdsat_Theory_Impl6_Sound_Interface
  use Type
  predicate sound [@inline:trivial] (self : Type.cdsat_theory_conflict)
end
module Cdsat_Theory_Impl6_Sound
  use Type
  clone Cdsat_Theory_Impl3_SatisfySet_Interface as SatisfySet0
  clone Cdsat_Theory_Impl3_Invariant_Interface as Invariant0
  clone Cdsat_Theory_Impl4_Sound_Interface as Sound0
  predicate sound [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 652 4 652 30] (self : Type.cdsat_theory_conflict)
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 653 8 653 109] Sound0.sound (Type.cdsat_theory_conflict_Conflict_0 self) /\ (forall m : (Type.cdsat_theory_model) . Invariant0.invariant' m -> SatisfySet0.satisfy_set m (Type.cdsat_theory_conflict_Conflict_1 self) -> false)
end
module Cdsat_Theory_Impl6_ConflictSize_Interface
  use Type
  function conflict_size (self : Type.cdsat_theory_conflict) : ()
end
module Cdsat_Theory_Impl6_ConflictSize
  use Type
  function conflict_size [#"/Users/xavier/Code/cdsat/src/theory.rs" 669 4 669 36] (self : Type.cdsat_theory_conflict) : ()
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 665 4 665 12] ()
end
module Cdsat_Theory_Impl4_RestrictSound_Interface
  use Type
  use mach.int.Int
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_SatisfiedBy_Interface as SatisfiedBy0
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_LevelOf_Interface as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_Contains_Interface as Contains0 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_Invariant_Interface as Invariant0
  clone Cdsat_Theory_Impl4_Restrict_Interface as Restrict0 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  function Len0.len = Len0.len, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, axiom .
  clone Cdsat_Theory_Impl4_Sound_Interface as Sound0
  function restrict_sound (self : Type.cdsat_theory_trail) (level : int) : ()
end
module Cdsat_Theory_Impl4_RestrictSound
  use Type
  use mach.int.Int
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_SatisfiedBy_Interface as SatisfiedBy0
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_LevelOf_Interface as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_Contains_Interface as Contains0 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_Invariant_Interface as Invariant0
  clone Cdsat_Theory_Impl4_Restrict_Interface as Restrict0 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  function Len0.len = Len0.len, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, axiom .
  clone Cdsat_Theory_Impl4_Sound_Interface as Sound0
  function restrict_sound [#"/Users/xavier/Code/cdsat/src/theory.rs" 457 4 457 43] (self : Type.cdsat_theory_trail) (level : int) : ()
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 458 8 463 9] match (self) with
      | Type.Cdsat_Theory_Trail_Empty -> ()
      | Type.Cdsat_Theory_Trail_Assign a l tl -> let _ = restrict_sound tl level in ()
      end
  axiom restrict_sound_spec : forall self : Type.cdsat_theory_trail, level : int . ([#"/Users/xavier/Code/cdsat/src/theory.rs" 455 15 455 27] Sound0.sound self) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 456 14 456 42] Sound0.sound (Restrict0.restrict self level))
end
module Cdsat_Theory_Impl4_RestrictSound_Impl
  use Type
  use mach.int.Int
  clone CreusotContracts_Logic_Fset_Impl0_Remove as Remove0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl1_Sort as Sort1
  clone Cdsat_Theory_Impl1_IsBool as IsBool0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl1_Negate as Negate0 with predicate IsBool0.is_bool = IsBool0.is_bool, axiom .
  clone Cdsat_Theory_Impl4_Len as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl0_Sort as Sort0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl2_Invariant as Invariant2 with function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_InvariantAssign as InvariantAssign0 with predicate Invariant0.invariant' = Invariant2.invariant'
  clone Cdsat_Theory_Impl2_ToPair as ToPair0
  clone Cdsat_Theory_Impl4_InvariantNonneg as InvariantNonneg0 with function Level0.level = Level0.level,
  function Len0.len = Len0.len
  clone Cdsat_Theory_Impl4_Find as Find0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_LevelOf as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, axiom .
  clone CreusotContracts_Logic_Fset_Impl0_Contains as Contains1 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_SetLevel as SetLevel0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, function Len0.len = Len0.len, function Remove0.remove = Remove0.remove, axiom .
  clone Cdsat_Theory_Impl3_Invariant as Invariant1 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl3_Interp as Interp0 with predicate Invariant0.invariant' = Invariant1.invariant',
  function Sort0.sort = Sort1.sort, function Sort1.sort = Sort0.sort, axiom .
  clone Cdsat_Theory_Impl4_Contains as Contains0 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_TrailUnique as TrailUnique0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate Contains0.contains = Contains0.contains, predicate IsBool0.is_bool = IsBool0.is_bool,
  function Negate0.negate = Negate0.negate,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_InvariantContains as InvariantContains0 with predicate Contains0.contains = Contains1.contains,
  predicate Contains1.contains = Contains0.contains,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_InvariantLevel as InvariantLevel0 with function Level0.level = Level0.level,
  function SetLevel0.set_level = SetLevel0.set_level, function Len0.len = Len0.len,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of
  clone Cdsat_Theory_Impl3_Satisfies as Satisfies0 with function Interp0.interp = Interp0.interp,
  predicate Invariant0.invariant' = Invariant1.invariant', function Sort0.sort = Sort1.sort,
  function Sort1.sort = Sort0.sort
  clone Cdsat_Theory_Impl3_SatisfySet as SatisfySet0 with predicate Contains0.contains = Contains1.contains,
  predicate Satisfies0.satisfies = Satisfies0.satisfies
  clone Cdsat_Theory_Impl4_Invariant as Invariant0 with predicate InvariantLevel0.invariant_level = InvariantLevel0.invariant_level,
  predicate InvariantContains0.invariant_contains = InvariantContains0.invariant_contains,
  predicate TrailUnique0.trail_unique = TrailUnique0.trail_unique,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign
  clone Cdsat_Theory_Impl4_CountBounds as CountBounds0 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_SatisfiedBy as SatisfiedBy0 with predicate Contains0.contains = Contains0.contains,
  predicate Satisfies0.satisfies = Satisfies0.satisfies,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl2_JustifiedSound as JustifiedSound0 with predicate Invariant0.invariant' = Invariant1.invariant',
  predicate SatisfySet0.satisfy_set = SatisfySet0.satisfy_set, predicate Satisfies0.satisfies = Satisfies0.satisfies
  clone Cdsat_Theory_Impl4_Restrict as Restrict0 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  function Len0.len = Len0.len, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function CountBounds0.count_bounds = CountBounds0.count_bounds, axiom .
  clone Cdsat_Theory_Impl4_Sound as Sound0 with predicate JustifiedSound0.justified_sound = JustifiedSound0.justified_sound
  let rec ghost function restrict_sound (self : Type.cdsat_theory_trail) (level : int) : ()
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 455 15 455 27] Sound0.sound self}
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 456 14 456 42] Sound0.sound (Restrict0.restrict self level) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 458 8 463 9] match (self) with
      | Type.Cdsat_Theory_Trail_Empty -> ()
      | Type.Cdsat_Theory_Trail_Assign a l tl -> let _ = restrict_sound tl level in ()
      end
end
module Cdsat_Theory_Impl4_RestrictTooBig_Interface
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Cdsat_Theory_Impl4_SatisfiedBy_Interface as SatisfiedBy0
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone Cdsat_Theory_Impl4_LevelOf_Interface as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_Contains_Interface as Contains0 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_Invariant_Interface as Invariant0
  clone Cdsat_Theory_Impl4_Restrict_Interface as Restrict0 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  function Len0.len = Len0.len, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, axiom .
  function restrict_too_big (self : Type.cdsat_theory_trail) (level : int) (d : (Type.cdsat_theory_term, Type.cdsat_theory_value)) : ()
    
end
module Cdsat_Theory_Impl4_RestrictTooBig
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Cdsat_Theory_Impl4_SatisfiedBy_Interface as SatisfiedBy0
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone Cdsat_Theory_Impl4_LevelOf_Interface as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_Contains_Interface as Contains0 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_Invariant_Interface as Invariant0
  clone Cdsat_Theory_Impl4_Restrict_Interface as Restrict0 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  function Len0.len = Len0.len, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, axiom .
  clone Cdsat_Theory_Impl2_ToPair_Interface as ToPair0
  function restrict_too_big [#"/Users/xavier/Code/cdsat/src/theory.rs" 484 4 484 59] (self : Type.cdsat_theory_trail) (level : int) (d : (Type.cdsat_theory_term, Type.cdsat_theory_value)) : ()
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 485 8 494 9] match (self) with
      | Type.Cdsat_Theory_Trail_Empty -> ()
      | Type.Cdsat_Theory_Trail_Assign a l tl -> if ToPair0.to_pair a = d then
        ()
      else
        let _ = restrict_too_big tl level d in ()
      
      end
  axiom restrict_too_big_spec : forall self : Type.cdsat_theory_trail, level : int, d : (Type.cdsat_theory_term, Type.cdsat_theory_value) . ([#"/Users/xavier/Code/cdsat/src/theory.rs" 479 15 479 25] level >= 0) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 480 15 480 31] Invariant0.invariant' self) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 481 15 481 31] Contains0.contains self d) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 482 15 482 39] level < LevelOf0.level_of self d) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 483 14 483 47] not Contains0.contains (Restrict0.restrict self level) d)
end
module Cdsat_Theory_Impl4_RestrictTooBig_Impl
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Cdsat_Theory_Impl1_Sort as Sort1
  clone Cdsat_Theory_Impl3_Invariant as Invariant2 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl0_Sort as Sort0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl3_Interp as Interp0 with predicate Invariant0.invariant' = Invariant2.invariant',
  function Sort0.sort = Sort1.sort, function Sort1.sort = Sort0.sort, axiom .
  clone CreusotContracts_Logic_Fset_Impl0_Remove as Remove0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl3_Satisfies as Satisfies0 with function Interp0.interp = Interp0.interp,
  predicate Invariant0.invariant' = Invariant2.invariant', function Sort0.sort = Sort1.sort,
  function Sort1.sort = Sort0.sort
  clone Cdsat_Theory_Impl2_Invariant as Invariant1 with function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl1_IsBool as IsBool0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl1_Negate as Negate0 with predicate IsBool0.is_bool = IsBool0.is_bool, axiom .
  clone CreusotContracts_Logic_Fset_Impl0_Contains as Contains1 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_Len as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantAssign as InvariantAssign0 with predicate Invariant0.invariant' = Invariant1.invariant'
  clone Cdsat_Theory_Impl2_ToPair as ToPair0
  clone Cdsat_Theory_Impl4_InvariantNonneg as InvariantNonneg0 with function Level0.level = Level0.level,
  function Len0.len = Len0.len
  clone Cdsat_Theory_Impl4_Find as Find0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_LevelOf as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_SetLevel as SetLevel0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, function Len0.len = Len0.len, function Remove0.remove = Remove0.remove, axiom .
  clone Cdsat_Theory_Impl4_Contains as Contains0 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_TrailUnique as TrailUnique0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate Contains0.contains = Contains0.contains, predicate IsBool0.is_bool = IsBool0.is_bool,
  function Negate0.negate = Negate0.negate,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_InvariantContains as InvariantContains0 with predicate Contains0.contains = Contains1.contains,
  predicate Contains1.contains = Contains0.contains,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_InvariantLevel as InvariantLevel0 with function Level0.level = Level0.level,
  function SetLevel0.set_level = SetLevel0.set_level, function Len0.len = Len0.len,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of
  clone Cdsat_Theory_Impl4_Invariant as Invariant0 with predicate InvariantLevel0.invariant_level = InvariantLevel0.invariant_level,
  predicate InvariantContains0.invariant_contains = InvariantContains0.invariant_contains,
  predicate TrailUnique0.trail_unique = TrailUnique0.trail_unique,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign
  clone Cdsat_Theory_Impl4_CountBounds as CountBounds0 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_SatisfiedBy as SatisfiedBy0 with predicate Contains0.contains = Contains0.contains,
  predicate Satisfies0.satisfies = Satisfies0.satisfies,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_Restrict as Restrict0 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  function Len0.len = Len0.len, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function CountBounds0.count_bounds = CountBounds0.count_bounds, axiom .
  let rec ghost function restrict_too_big (self : Type.cdsat_theory_trail) (level : int) (d : (Type.cdsat_theory_term, Type.cdsat_theory_value)) : ()
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 479 15 479 25] level >= 0}
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 480 15 480 31] Invariant0.invariant' self}
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 481 15 481 31] Contains0.contains self d}
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 482 15 482 39] level < LevelOf0.level_of self d}
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 483 14 483 47] not Contains0.contains (Restrict0.restrict self level) d }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 485 8 494 9] match (self) with
      | Type.Cdsat_Theory_Trail_Empty -> ()
      | Type.Cdsat_Theory_Trail_Assign a l tl -> if let a = ToPair0.to_pair a in pure {a = d} then
        ()
      else
        let _ = restrict_too_big tl level d in ()
      
      end
end
module Cdsat_Theory_Impl4_TrailPlausible_Interface
  use Type
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone Cdsat_Theory_Impl1_IsBool_Interface as IsBool0
  clone Cdsat_Theory_Impl1_Negate_Interface as Negate0 with predicate IsBool0.is_bool = IsBool0.is_bool, axiom .
  clone Cdsat_Theory_Impl4_Contains_Interface as Contains0 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_Invariant_Interface as Invariant0
  function trail_plausible (self : Type.cdsat_theory_trail) (d : (Type.cdsat_theory_term, Type.cdsat_theory_value)) : ()
end
module Cdsat_Theory_Impl4_TrailPlausible
  use Type
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone Cdsat_Theory_Impl1_IsBool_Interface as IsBool0
  clone Cdsat_Theory_Impl1_Negate_Interface as Negate0 with predicate IsBool0.is_bool = IsBool0.is_bool, axiom .
  clone Cdsat_Theory_Impl4_Contains_Interface as Contains0 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_Invariant_Interface as Invariant0
  clone Cdsat_Theory_Impl2_ToPair_Interface as ToPair0
  function trail_plausible [#"/Users/xavier/Code/cdsat/src/theory.rs" 514 4 514 46] (self : Type.cdsat_theory_trail) (d : (Type.cdsat_theory_term, Type.cdsat_theory_value)) : ()
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 515 8 524 9] match (self) with
      | Type.Cdsat_Theory_Trail_Empty -> ()
      | Type.Cdsat_Theory_Trail_Assign a l tl -> if ToPair0.to_pair a = d then
        ()
      else
        let _ = trail_plausible tl d in ()
      
      end
  axiom trail_plausible_spec : forall self : Type.cdsat_theory_trail, d : (Type.cdsat_theory_term, Type.cdsat_theory_value) . ([#"/Users/xavier/Code/cdsat/src/theory.rs" 510 15 510 31] Invariant0.invariant' self) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 511 15 511 31] Contains0.contains self d) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 512 4 512 30] IsBool0.is_bool (let (_, a) = d in a)) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 513 14 513 49] not Contains0.contains self (let (a, _) = d in a, Negate0.negate (let (_, a) = d in a)))
end
module Cdsat_Theory_Impl4_TrailPlausible_Impl
  use Type
  clone CreusotContracts_Logic_Fset_Impl0_Remove as Remove0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl1_Sort as Sort1
  clone Cdsat_Theory_Impl0_Sort as Sort0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl2_Invariant as Invariant1 with function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_InvariantAssign as InvariantAssign0 with predicate Invariant0.invariant' = Invariant1.invariant'
  clone Cdsat_Theory_Impl2_ToPair as ToPair0
  clone Cdsat_Theory_Impl4_Len as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg as InvariantNonneg0 with function Level0.level = Level0.level,
  function Len0.len = Len0.len
  clone Cdsat_Theory_Impl4_Find as Find0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_LevelOf as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, axiom .
  clone CreusotContracts_Logic_Fset_Impl0_Contains as Contains1 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_SetLevel as SetLevel0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, function Len0.len = Len0.len, function Remove0.remove = Remove0.remove, axiom .
  clone Cdsat_Theory_Impl1_IsBool as IsBool0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl1_Negate as Negate0 with predicate IsBool0.is_bool = IsBool0.is_bool, axiom .
  clone Cdsat_Theory_Impl4_Contains as Contains0 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_TrailUnique as TrailUnique0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate Contains0.contains = Contains0.contains, predicate IsBool0.is_bool = IsBool0.is_bool,
  function Negate0.negate = Negate0.negate,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_InvariantContains as InvariantContains0 with predicate Contains0.contains = Contains1.contains,
  predicate Contains1.contains = Contains0.contains,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_InvariantLevel as InvariantLevel0 with function Level0.level = Level0.level,
  function SetLevel0.set_level = SetLevel0.set_level, function Len0.len = Len0.len,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of
  clone Cdsat_Theory_Impl4_Invariant as Invariant0 with predicate InvariantLevel0.invariant_level = InvariantLevel0.invariant_level,
  predicate InvariantContains0.invariant_contains = InvariantContains0.invariant_contains,
  predicate TrailUnique0.trail_unique = TrailUnique0.trail_unique,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign
  let rec ghost function trail_plausible (self : Type.cdsat_theory_trail) (d : (Type.cdsat_theory_term, Type.cdsat_theory_value)) : ()
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 510 15 510 31] Invariant0.invariant' self}
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 511 15 511 31] Contains0.contains self d}
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 512 4 512 30] IsBool0.is_bool (let (_, a) = d in a)}
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 513 14 513 49] not Contains0.contains self (let (a, _) = d in a, Negate0.negate (let (_, a) = d in a)) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 515 8 524 9] match (self) with
      | Type.Cdsat_Theory_Trail_Empty -> ()
      | Type.Cdsat_Theory_Trail_Assign a l tl -> if let a = ToPair0.to_pair a in pure {a = d} then
        ()
      else
        let _ = trail_plausible tl d in ()
      
      end
end
module Cdsat_Theory_Impl4_RestrictIdempotent_Interface
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_SatisfiedBy_Interface as SatisfiedBy0
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_LevelOf_Interface as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_Contains_Interface as Contains0 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_Invariant_Interface as Invariant0
  clone Cdsat_Theory_Impl4_Restrict_Interface as Restrict0 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  function Len0.len = Len0.len, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, axiom .
  function restrict_idempotent (self : Type.cdsat_theory_trail) (l1 : int) (l2 : int) : ()
end
module Cdsat_Theory_Impl4_RestrictIdempotent
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_SatisfiedBy_Interface as SatisfiedBy0
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_LevelOf_Interface as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_Contains_Interface as Contains0 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_Invariant_Interface as Invariant0
  clone Cdsat_Theory_Impl4_Restrict_Interface as Restrict0 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  function Len0.len = Len0.len, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, axiom .
  function restrict_idempotent [#"/Users/xavier/Code/cdsat/src/theory.rs" 502 4 502 54] (self : Type.cdsat_theory_trail) (l1 : int) (l2 : int) : ()
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 503 8 506 9] match (self) with
      | Type.Cdsat_Theory_Trail_Empty -> ()
      | Type.Cdsat_Theory_Trail_Assign _ _ tl -> restrict_idempotent tl l1 l2
      end
  axiom restrict_idempotent_spec : forall self : Type.cdsat_theory_trail, l1 : int, l2 : int . ([#"/Users/xavier/Code/cdsat/src/theory.rs" 498 15 498 31] Invariant0.invariant' self) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 499 15 499 33] l1 >= 0 /\ l2 >= 0) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 500 15 500 23] l1 <= l2) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 501 14 501 65] Restrict0.restrict self l1 = Restrict0.restrict (Restrict0.restrict self l2) l1)
end
module Cdsat_Theory_Impl4_RestrictIdempotent_Impl
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Cdsat_Theory_Impl1_Sort as Sort1
  clone Cdsat_Theory_Impl3_Invariant as Invariant2 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl0_Sort as Sort0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl3_Interp as Interp0 with predicate Invariant0.invariant' = Invariant2.invariant',
  function Sort0.sort = Sort1.sort, function Sort1.sort = Sort0.sort, axiom .
  clone CreusotContracts_Logic_Fset_Impl0_Remove as Remove0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl3_Satisfies as Satisfies0 with function Interp0.interp = Interp0.interp,
  predicate Invariant0.invariant' = Invariant2.invariant', function Sort0.sort = Sort1.sort,
  function Sort1.sort = Sort0.sort
  clone Cdsat_Theory_Impl4_Len as Len0 with axiom .
  clone Cdsat_Theory_Impl2_Invariant as Invariant1 with function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_InvariantAssign as InvariantAssign0 with predicate Invariant0.invariant' = Invariant1.invariant'
  clone Cdsat_Theory_Impl4_Level as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg as InvariantNonneg0 with function Level0.level = Level0.level,
  function Len0.len = Len0.len
  clone Cdsat_Theory_Impl2_ToPair as ToPair0
  clone Cdsat_Theory_Impl4_Find as Find0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl1_IsBool as IsBool0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl1_Negate as Negate0 with predicate IsBool0.is_bool = IsBool0.is_bool, axiom .
  clone CreusotContracts_Logic_Fset_Impl0_Contains as Contains1 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_LevelOf as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_SetLevel as SetLevel0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, function Len0.len = Len0.len, function Remove0.remove = Remove0.remove, axiom .
  clone Cdsat_Theory_Impl4_Contains as Contains0 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_TrailUnique as TrailUnique0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate Contains0.contains = Contains0.contains, predicate IsBool0.is_bool = IsBool0.is_bool,
  function Negate0.negate = Negate0.negate,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_InvariantContains as InvariantContains0 with predicate Contains0.contains = Contains1.contains,
  predicate Contains1.contains = Contains0.contains,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_InvariantLevel as InvariantLevel0 with function Level0.level = Level0.level,
  function SetLevel0.set_level = SetLevel0.set_level, function Len0.len = Len0.len,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of
  clone Cdsat_Theory_Impl4_Invariant as Invariant0 with predicate InvariantLevel0.invariant_level = InvariantLevel0.invariant_level,
  predicate InvariantContains0.invariant_contains = InvariantContains0.invariant_contains,
  predicate TrailUnique0.trail_unique = TrailUnique0.trail_unique,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign
  clone Cdsat_Theory_Impl4_CountBounds as CountBounds0 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_SatisfiedBy as SatisfiedBy0 with predicate Contains0.contains = Contains0.contains,
  predicate Satisfies0.satisfies = Satisfies0.satisfies,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_Restrict as Restrict0 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  function Len0.len = Len0.len, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function CountBounds0.count_bounds = CountBounds0.count_bounds, axiom .
  let rec ghost function restrict_idempotent (self : Type.cdsat_theory_trail) (l1 : int) (l2 : int) : ()
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 498 15 498 31] Invariant0.invariant' self}
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 499 15 499 33] l1 >= 0 /\ l2 >= 0}
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 500 15 500 23] l1 <= l2}
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 501 14 501 65] Restrict0.restrict self l1 = Restrict0.restrict (Restrict0.restrict self l2) l1 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 503 8 506 9] match (self) with
      | Type.Cdsat_Theory_Trail_Empty -> ()
      | Type.Cdsat_Theory_Trail_Assign _ _ tl -> restrict_idempotent tl l1 l2
      end
end
module Cdsat_Theory_Impl1_NegateInvolutive_Interface
  use Type
  clone Cdsat_Theory_Impl1_IsBool_Interface as IsBool0
  clone Cdsat_Theory_Impl1_Negate_Interface as Negate0 with predicate IsBool0.is_bool = IsBool0.is_bool, axiom .
  function negate_involutive (self : Type.cdsat_theory_value) : ()
end
module Cdsat_Theory_Impl1_NegateInvolutive
  use Type
  clone Cdsat_Theory_Impl1_IsBool_Interface as IsBool0
  clone Cdsat_Theory_Impl1_Negate_Interface as Negate0 with predicate IsBool0.is_bool = IsBool0.is_bool, axiom .
  function negate_involutive [#"/Users/xavier/Code/cdsat/src/theory.rs" 71 4 71 30] (self : Type.cdsat_theory_value) : ()
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 68 4 68 12] ()
  axiom negate_involutive_spec : forall self : Type.cdsat_theory_value . ([#"/Users/xavier/Code/cdsat/src/theory.rs" 69 15 69 29] IsBool0.is_bool self) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 70 14 70 44] Negate0.negate (Negate0.negate self) = self)
end
module Cdsat_Theory_Impl1_NegateInvolutive_Impl
  use Type
  clone Cdsat_Theory_Impl1_Sort as Sort0
  clone Cdsat_Theory_Impl1_IsBool as IsBool0 with function Sort0.sort = Sort0.sort
  clone Cdsat_Theory_Impl1_Negate as Negate0 with predicate IsBool0.is_bool = IsBool0.is_bool, axiom .
  let rec ghost function negate_involutive (self : Type.cdsat_theory_value) : ()
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 69 15 69 29] IsBool0.is_bool self}
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 70 14 70 44] Negate0.negate (Negate0.negate self) = self }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 68 4 68 12] ()
end
module Cdsat_Theory_Impl3_Lemma_Interface
  use Type
  clone Cdsat_Theory_Impl1_IsBool_Interface as IsBool0
  clone Cdsat_Theory_Impl1_Negate_Interface as Negate0 with predicate IsBool0.is_bool = IsBool0.is_bool, axiom .
  clone Cdsat_Theory_Impl3_Satisfies_Interface as Satisfies0
  clone Cdsat_Theory_Impl3_Invariant_Interface as Invariant0
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort0
  function lemma' (self : Type.cdsat_theory_model) (t : Type.cdsat_theory_term) (v : Type.cdsat_theory_value) : ()
end
module Cdsat_Theory_Impl3_Lemma
  use Type
  clone Cdsat_Theory_Impl1_IsBool_Interface as IsBool0
  clone Cdsat_Theory_Impl1_Negate_Interface as Negate0 with predicate IsBool0.is_bool = IsBool0.is_bool, axiom .
  clone Cdsat_Theory_Impl3_Satisfies_Interface as Satisfies0
  clone Cdsat_Theory_Impl3_Invariant_Interface as Invariant0
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl3_Interp_Interface as Interp0 with predicate Invariant0.invariant' = Invariant0.invariant',
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, axiom .
  function lemma' [#"/Users/xavier/Code/cdsat/src/theory.rs" 167 4 167 37] (self : Type.cdsat_theory_model) (t : Type.cdsat_theory_term) (v : Type.cdsat_theory_value) : ()
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 168 8 171 9] match (Interp0.interp self t) with
      | Type.Cdsat_Theory_Value_Bool _ -> ()
      | _ -> ()
      end
  axiom lemma'_spec : forall self : Type.cdsat_theory_model, t : Type.cdsat_theory_term, v : Type.cdsat_theory_value . ([#"/Users/xavier/Code/cdsat/src/theory.rs" 163 15 163 40] Sort0.sort v = Type.Cdsat_Theory_Sort_Boolean) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 164 15 164 40] Sort1.sort t = Type.Cdsat_Theory_Sort_Boolean) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 165 15 165 31] Invariant0.invariant' self) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 166 14 166 71] Satisfies0.satisfies self (t, v) \/ Satisfies0.satisfies self (t, Negate0.negate v))
end
module Cdsat_Theory_Impl3_Lemma_Impl
  use Type
  clone Cdsat_Theory_Impl1_Sort as Sort0
  clone Cdsat_Theory_Impl1_IsBool as IsBool0 with function Sort0.sort = Sort0.sort
  clone Cdsat_Theory_Impl0_Sort as Sort1 with function Sort0.sort = Sort0.sort
  clone Cdsat_Theory_Impl3_Invariant as Invariant0 with function Sort0.sort = Sort0.sort
  clone Cdsat_Theory_Impl3_Interp as Interp0 with predicate Invariant0.invariant' = Invariant0.invariant',
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl1_Negate as Negate0 with predicate IsBool0.is_bool = IsBool0.is_bool, axiom .
  clone Cdsat_Theory_Impl3_Satisfies as Satisfies0 with function Interp0.interp = Interp0.interp,
  predicate Invariant0.invariant' = Invariant0.invariant', function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  let rec ghost function lemma' (self : Type.cdsat_theory_model) (t : Type.cdsat_theory_term) (v : Type.cdsat_theory_value) : ()
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 163 15 163 40] Sort0.sort v = Type.Cdsat_Theory_Sort_Boolean}
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 164 15 164 40] Sort1.sort t = Type.Cdsat_Theory_Sort_Boolean}
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 165 15 165 31] Invariant0.invariant' self}
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 166 14 166 71] Satisfies0.satisfies self (t, v) \/ Satisfies0.satisfies self (t, Negate0.negate v) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 168 8 171 9] match (Interp0.interp self t) with
      | Type.Cdsat_Theory_Value_Bool _ -> ()
      | _ -> ()
      end
end
module Cdsat_Theory_Impl0_IsBool_Interface
  use Type
  predicate is_bool (self : Type.cdsat_theory_term)
end
module Cdsat_Theory_Impl0_IsBool
  use Type
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  predicate is_bool [#"/Users/xavier/Code/cdsat/src/theory.rs" 25 4 25 28] (self : Type.cdsat_theory_term) =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 26 8 26 36] Sort0.sort self = Type.Cdsat_Theory_Sort_Boolean
end
module Cdsat_Theory_Impl6_Backjump_Interface
  use Type
  clone Cdsat_Theory_Impl4_Unsat_Interface as Unsat0
  clone Cdsat_Theory_Impl4_Impls_Interface as Impls0 with predicate Unsat0.unsat = Unsat0.unsat, axiom .
  clone Cdsat_Theory_Impl5_Sound_Interface as Sound1
  clone Cdsat_Theory_Impl4_Invariant_Interface as Invariant1
  clone Cdsat_Theory_Impl6_Sound_Interface as Sound0
  clone Cdsat_Theory_Impl6_Invariant_Interface as Invariant0
  predicate backjump (self : Type.cdsat_theory_conflict) (l : (Type.cdsat_theory_term, Type.cdsat_theory_value)) (tgt : Type.cdsat_theory_normal)
    
end
module Cdsat_Theory_Impl6_Backjump
  use Type
  clone Cdsat_Theory_Impl4_Unsat_Interface as Unsat0
  clone Cdsat_Theory_Impl4_Impls_Interface as Impls0 with predicate Unsat0.unsat = Unsat0.unsat, axiom .
  clone Cdsat_Theory_Impl5_Sound_Interface as Sound1
  clone Cdsat_Theory_Impl4_Invariant_Interface as Invariant1
  clone Cdsat_Theory_Impl6_Sound_Interface as Sound0
  clone Cdsat_Theory_Impl6_Invariant_Interface as Invariant0
  use mach.int.Int
  use mach.int.Int32
  use map.Const
  clone Cdsat_Theory_Impl3_Satisfies_Interface as Satisfies0
  clone Cdsat_Theory_Impl3_Invariant_Interface as Invariant2
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone Cdsat_Theory_Impl4_SatisfiedBy_Interface as SatisfiedBy0
  clone Cdsat_Theory_Impl4_Contains_Interface as Contains1 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_Sound_Interface as Sound2
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl1_IsBool_Interface as IsBool0
  clone Cdsat_Theory_Impl1_Negate_Interface as Negate0 with predicate IsBool0.is_bool = IsBool0.is_bool, axiom .
  clone Cdsat_Theory_Impl4_LevelOf_Interface as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl0_IsBool_Interface as IsBool1
  clone CreusotContracts_Logic_Fset_Impl0_Contains_Interface as Contains0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_Restrict_Interface as Restrict0 with predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  function Len0.len = Len0.len, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, axiom .
  clone Cdsat_Theory_Impl3_Lemma_Interface as Lemma0 with function Sort0.sort = Sort1.sort,
  function Sort1.sort = Sort0.sort, predicate Invariant0.invariant' = Invariant2.invariant',
  predicate Satisfies0.satisfies = Satisfies0.satisfies, function Negate0.negate = Negate0.negate,
  predicate IsBool0.is_bool = IsBool0.is_bool, axiom .
  clone Cdsat_Theory_Impl1_NegateInvolutive_Interface as NegateInvolutive0 with predicate IsBool0.is_bool = IsBool0.is_bool,
  function Negate0.negate = Negate0.negate, axiom .
  clone Cdsat_Theory_Impl4_RestrictIdempotent_Interface as RestrictIdempotent0 with predicate Invariant0.invariant' = Invariant1.invariant',
  function Restrict0.restrict = Restrict0.restrict, predicate Contains0.contains = Contains1.contains,
  function LevelOf0.level_of = LevelOf0.level_of, function Level0.level = Level0.level,
  predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by, function Len0.len = Len0.len,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  axiom .
  clone Cdsat_Theory_Impl4_TrailPlausible_Interface as TrailPlausible0 with predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Contains0.contains = Contains1.contains, predicate IsBool0.is_bool = IsBool0.is_bool,
  function Negate0.negate = Negate0.negate,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_RestrictTooBig_Interface as RestrictTooBig0 with predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Restrict0.restrict = Restrict0.restrict,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len,
  predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by, axiom .
  clone Cdsat_Theory_Impl4_RestrictSound_Interface as RestrictSound0 with predicate Sound0.sound = Sound2.sound,
  function Restrict0.restrict = Restrict0.restrict, predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  function Len0.len = Len0.len, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, axiom .
  clone Cdsat_Theory_Impl4_SetLevel_Interface as SetLevel0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  clone CreusotContracts_Logic_Fset_Impl0_Remove_Interface as Remove0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  predicate backjump [#"/Users/xavier/Code/cdsat/src/theory.rs" 695 4 695 64] (self : Type.cdsat_theory_conflict) (l : (Type.cdsat_theory_term, Type.cdsat_theory_value)) (tgt : Type.cdsat_theory_normal)
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 689 4 689 16] let e = Remove0.remove (Type.cdsat_theory_conflict_Conflict_1 self) l in let _ = RestrictSound0.restrict_sound (Type.cdsat_theory_conflict_Conflict_0 self) (SetLevel0.set_level (Type.cdsat_theory_conflict_Conflict_0 self) e) in let _ = RestrictTooBig0.restrict_too_big (Type.cdsat_theory_conflict_Conflict_0 self) (SetLevel0.set_level (Type.cdsat_theory_conflict_Conflict_0 self) e) l in let _ = TrailPlausible0.trail_plausible (Type.cdsat_theory_conflict_Conflict_0 self) l in let _ = RestrictIdempotent0.restrict_idempotent (Type.cdsat_theory_conflict_Conflict_0 self) 0 (SetLevel0.set_level (Type.cdsat_theory_conflict_Conflict_0 self) e) in let _ = NegateInvolutive0.negate_involutive (let (_, a) = l in a) in let _ = Lemma0.lemma' (Type.Cdsat_Theory_Model (Const.const (Type.Cdsat_Theory_Value_Bool false))) (let (a, _) = l in a) (let (_, a) = l in a) in let restricted = Restrict0.restrict (Type.cdsat_theory_conflict_Conflict_0 self) (SetLevel0.set_level (Type.cdsat_theory_conflict_Conflict_0 self) e) in Contains0.contains (Type.cdsat_theory_conflict_Conflict_1 self) l /\ IsBool0.is_bool (let (_, a) = l in a) /\ IsBool1.is_bool (let (a, _) = l in a) /\ LevelOf0.level_of (Type.cdsat_theory_conflict_Conflict_0 self) l > SetLevel0.set_level (Type.cdsat_theory_conflict_Conflict_0 self) e /\ Type.cdsat_theory_normal_Normal_0 tgt = Type.Cdsat_Theory_Trail_Assign (Type.Cdsat_Theory_Assign_Justified e (let (a, _) = l in a) (Negate0.negate (let (_, a) = l in a))) (SetLevel0.set_level restricted e) restricted
  axiom backjump_spec : forall self : Type.cdsat_theory_conflict, l : (Type.cdsat_theory_term, Type.cdsat_theory_value), tgt : Type.cdsat_theory_normal . ([#"/Users/xavier/Code/cdsat/src/theory.rs" 690 15 690 31] Invariant0.invariant' self) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 691 15 691 27] Sound0.sound self) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 694 4 694 46] backjump self l tgt -> Impls0.impls (Type.cdsat_theory_conflict_Conflict_0 self) (Type.cdsat_theory_normal_Normal_0 tgt)) && ([#"/Users/xavier/Code/cdsat/src/theory.rs" 693 4 693 38] backjump self l tgt -> Sound1.sound tgt) && ([#"/Users/xavier/Code/cdsat/src/theory.rs" 692 4 692 44] backjump self l tgt -> Invariant1.invariant' (Type.cdsat_theory_normal_Normal_0 tgt))
end
module Cdsat_Theory_Impl6_Backjump_Impl
  use Type
  use mach.int.Int
  use mach.int.Int32
  use map.Const
  clone Cdsat_Theory_Impl1_Sort as Sort1
  clone Cdsat_Theory_Impl0_Sort as Sort0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl3_Invariant as Invariant2 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl3_Interp as Interp0 with predicate Invariant0.invariant' = Invariant2.invariant',
  function Sort0.sort = Sort1.sort, function Sort1.sort = Sort0.sort, axiom .
  clone Cdsat_Theory_Impl3_Satisfies as Satisfies0 with function Interp0.interp = Interp0.interp,
  predicate Invariant0.invariant' = Invariant2.invariant', function Sort0.sort = Sort1.sort,
  function Sort1.sort = Sort0.sort
  clone CreusotContracts_Logic_Fset_Impl0_Contains as Contains0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl3_SatisfySet as SatisfySet0 with predicate Contains0.contains = Contains0.contains,
  predicate Satisfies0.satisfies = Satisfies0.satisfies
  clone Cdsat_Theory_Impl2_JustifiedSound as JustifiedSound0 with predicate Invariant0.invariant' = Invariant2.invariant',
  predicate SatisfySet0.satisfy_set = SatisfySet0.satisfy_set, predicate Satisfies0.satisfies = Satisfies0.satisfies
  clone Cdsat_Theory_Impl2_Invariant as Invariant3 with function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_Len as Len0 with axiom .
  clone Cdsat_Theory_Impl4_InvariantAssign as InvariantAssign0 with predicate Invariant0.invariant' = Invariant3.invariant'
  clone Cdsat_Theory_Impl4_Level as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg as InvariantNonneg0 with function Level0.level = Level0.level,
  function Len0.len = Len0.len
  clone Cdsat_Theory_Impl2_ToPair as ToPair0
  clone Cdsat_Theory_Impl4_Find as Find0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_LevelOf as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_Contains as Contains1 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl1_IsBool as IsBool0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl1_Negate as Negate0 with predicate IsBool0.is_bool = IsBool0.is_bool, axiom .
  clone Cdsat_Theory_Impl4_TrailUnique as TrailUnique0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate Contains0.contains = Contains1.contains, predicate IsBool0.is_bool = IsBool0.is_bool,
  function Negate0.negate = Negate0.negate,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_InvariantContains as InvariantContains0 with predicate Contains0.contains = Contains0.contains,
  predicate Contains1.contains = Contains1.contains,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone CreusotContracts_Logic_Fset_Impl0_Remove as Remove0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_SetLevel as SetLevel0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, function Len0.len = Len0.len, function Remove0.remove = Remove0.remove, axiom .
  clone Cdsat_Theory_Impl4_InvariantLevel as InvariantLevel0 with function Level0.level = Level0.level,
  function SetLevel0.set_level = SetLevel0.set_level, function Len0.len = Len0.len,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of
  clone Cdsat_Theory_Impl4_Invariant as Invariant1 with predicate InvariantLevel0.invariant_level = InvariantLevel0.invariant_level,
  predicate InvariantContains0.invariant_contains = InvariantContains0.invariant_contains,
  predicate TrailUnique0.trail_unique = TrailUnique0.trail_unique,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign
  clone Cdsat_Theory_Impl4_CountBounds as CountBounds0 with predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_SatisfiedBy as SatisfiedBy0 with predicate Contains0.contains = Contains1.contains,
  predicate Satisfies0.satisfies = Satisfies0.satisfies,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_Restrict as Restrict0 with predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  function Len0.len = Len0.len, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function CountBounds0.count_bounds = CountBounds0.count_bounds, axiom .
  clone Cdsat_Theory_Impl4_Unsat as Unsat0 with predicate Invariant0.invariant' = Invariant2.invariant',
  function Restrict0.restrict = Restrict0.restrict, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  predicate Invariant1.invariant' = Invariant1.invariant', predicate Contains0.contains = Contains1.contains,
  function LevelOf0.level_of = LevelOf0.level_of, function Level0.level = Level0.level, function Len0.len = Len0.len,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg
  clone Cdsat_Theory_Impl4_Sound as Sound2 with predicate JustifiedSound0.justified_sound = JustifiedSound0.justified_sound
  clone Cdsat_Theory_Impl0_IsBool as IsBool1 with function Sort0.sort = Sort0.sort
  clone Cdsat_Theory_Impl3_Lemma as Lemma0 with function Sort0.sort = Sort1.sort, function Sort1.sort = Sort0.sort,
  predicate Invariant0.invariant' = Invariant2.invariant', predicate Satisfies0.satisfies = Satisfies0.satisfies,
  function Negate0.negate = Negate0.negate, predicate IsBool0.is_bool = IsBool0.is_bool,
  function Interp0.interp = Interp0.interp, axiom .
  clone Cdsat_Theory_Impl1_NegateInvolutive as NegateInvolutive0 with predicate IsBool0.is_bool = IsBool0.is_bool,
  function Negate0.negate = Negate0.negate, axiom .
  clone Cdsat_Theory_Impl4_RestrictIdempotent as RestrictIdempotent0 with predicate Invariant0.invariant' = Invariant1.invariant',
  function Restrict0.restrict = Restrict0.restrict, predicate Contains0.contains = Contains1.contains,
  function LevelOf0.level_of = LevelOf0.level_of, function Level0.level = Level0.level,
  predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by, function Len0.len = Len0.len,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  axiom .
  clone Cdsat_Theory_Impl4_TrailPlausible as TrailPlausible0 with predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Contains0.contains = Contains1.contains, predicate IsBool0.is_bool = IsBool0.is_bool,
  function Negate0.negate = Negate0.negate,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function ToPair0.to_pair = ToPair0.to_pair, axiom .
  clone Cdsat_Theory_Impl4_RestrictTooBig as RestrictTooBig0 with predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Restrict0.restrict = Restrict0.restrict,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len,
  predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by, function ToPair0.to_pair = ToPair0.to_pair, axiom .
  clone Cdsat_Theory_Impl4_RestrictSound as RestrictSound0 with predicate Sound0.sound = Sound2.sound,
  function Restrict0.restrict = Restrict0.restrict, predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  function Len0.len = Len0.len, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, axiom .
  clone Cdsat_Theory_Impl4_Impls as Impls0 with predicate Unsat0.unsat = Unsat0.unsat,
  predicate Invariant0.invariant' = Invariant2.invariant', function Restrict0.restrict = Restrict0.restrict,
  predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  predicate Invariant1.invariant' = Invariant1.invariant', predicate Contains0.contains = Contains1.contains,
  function LevelOf0.level_of = LevelOf0.level_of, function Level0.level = Level0.level, function Len0.len = Len0.len,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  axiom .
  clone Cdsat_Theory_Impl5_Sound as Sound1 with predicate Sound0.sound = Sound2.sound
  clone Cdsat_Theory_Impl6_Sound as Sound0 with predicate Sound0.sound = Sound2.sound,
  predicate Invariant0.invariant' = Invariant2.invariant', predicate SatisfySet0.satisfy_set = SatisfySet0.satisfy_set
  clone Cdsat_Theory_Impl6_Invariant as Invariant0 with function SetLevel0.set_level = SetLevel0.set_level,
  predicate Invariant0.invariant' = Invariant1.invariant', predicate Contains0.contains = Contains0.contains,
  predicate Contains1.contains = Contains1.contains,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function LevelOf0.level_of = LevelOf0.level_of, function Level0.level = Level0.level, function Len0.len = Len0.len,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  let rec ghost function backjump (self : Type.cdsat_theory_conflict) (l : (Type.cdsat_theory_term, Type.cdsat_theory_value)) (tgt : Type.cdsat_theory_normal) : bool
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 690 15 690 31] Invariant0.invariant' self}
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 691 15 691 27] Sound0.sound self}
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 692 4 692 44] result -> Invariant1.invariant' (Type.cdsat_theory_normal_Normal_0 tgt) }
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 693 4 693 38] result -> Sound1.sound tgt }
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 694 4 694 46] result -> Impls0.impls (Type.cdsat_theory_conflict_Conflict_0 self) (Type.cdsat_theory_normal_Normal_0 tgt) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 689 4 689 16] let e = let a' = Type.cdsat_theory_conflict_Conflict_1 self in Remove0.remove a' l in let _ = let a' = Type.cdsat_theory_conflict_Conflict_0 self in let b' = let a' = Type.cdsat_theory_conflict_Conflict_0 self in SetLevel0.set_level a' e in RestrictSound0.restrict_sound a' b' in let _ = let a' = Type.cdsat_theory_conflict_Conflict_0 self in let b' = let a' = Type.cdsat_theory_conflict_Conflict_0 self in SetLevel0.set_level a' e in RestrictTooBig0.restrict_too_big a' b' l in let _ = let a' = Type.cdsat_theory_conflict_Conflict_0 self in TrailPlausible0.trail_plausible a' l in let _ = let a' = Type.cdsat_theory_conflict_Conflict_0 self in let c' = let a' = Type.cdsat_theory_conflict_Conflict_0 self in SetLevel0.set_level a' e in RestrictIdempotent0.restrict_idempotent a' 0 c' in let _ = NegateInvolutive0.negate_involutive (let (_, a) = l in a) in let _ = Lemma0.lemma' (Type.Cdsat_Theory_Model (Const.const (Type.Cdsat_Theory_Value_Bool false))) (let (a, _) = l in a) (let (_, a) = l in a) in let restricted = let a' = Type.cdsat_theory_conflict_Conflict_0 self in let b' = let a' = Type.cdsat_theory_conflict_Conflict_0 self in SetLevel0.set_level a' e in Restrict0.restrict a' b' in (let a' = Type.cdsat_theory_conflict_Conflict_1 self in Contains0.contains a' l) && IsBool0.is_bool (let (_, a) = l in a) && IsBool1.is_bool (let (a, _) = l in a) && (let a' = Type.cdsat_theory_conflict_Conflict_0 self in LevelOf0.level_of a' l) > (let a' = Type.cdsat_theory_conflict_Conflict_0 self in SetLevel0.set_level a' e) && (let b = Type.Cdsat_Theory_Trail_Assign (Type.Cdsat_Theory_Assign_Justified e (let (a, _) = l in a) (Negate0.negate (let (_, a) = l in a))) (SetLevel0.set_level restricted e) restricted in let a = Type.cdsat_theory_normal_Normal_0 tgt in pure {a = b})
end
module Cdsat_Theory_Impl6_Level_Interface
  use Type
  use mach.int.Int
  function level (self : Type.cdsat_theory_conflict) : int
end
module Cdsat_Theory_Impl6_Level
  use Type
  use mach.int.Int
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl4_LevelOf_Interface as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  clone CreusotContracts_Logic_Fset_Impl0_Contains_Interface as Contains0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_SetLevel_Interface as SetLevel0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  function level [#"/Users/xavier/Code/cdsat/src/theory.rs" 657 4 657 25] (self : Type.cdsat_theory_conflict) : int =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 656 4 656 12] SetLevel0.set_level (Type.cdsat_theory_conflict_Conflict_0 self) (Type.cdsat_theory_conflict_Conflict_1 self)
end
module Cdsat_Theory_Impl6_UndoClear_Interface
  use Type
  clone Cdsat_Theory_Impl4_Unsat_Interface as Unsat0
  clone Cdsat_Theory_Impl4_Impls_Interface as Impls0 with predicate Unsat0.unsat = Unsat0.unsat, axiom .
  clone Cdsat_Theory_Impl5_Sound_Interface as Sound1
  clone Cdsat_Theory_Impl4_Invariant_Interface as Invariant1
  clone Cdsat_Theory_Impl6_Sound_Interface as Sound0
  clone Cdsat_Theory_Impl6_Invariant_Interface as Invariant0
  predicate undo_clear (self : Type.cdsat_theory_conflict) (a : (Type.cdsat_theory_term, Type.cdsat_theory_value)) (tgt : Type.cdsat_theory_normal)
    
end
module Cdsat_Theory_Impl6_UndoClear
  use Type
  clone Cdsat_Theory_Impl4_Unsat_Interface as Unsat0
  clone Cdsat_Theory_Impl4_Impls_Interface as Impls0 with predicate Unsat0.unsat = Unsat0.unsat, axiom .
  clone Cdsat_Theory_Impl5_Sound_Interface as Sound1
  clone Cdsat_Theory_Impl4_Invariant_Interface as Invariant1
  clone Cdsat_Theory_Impl6_Sound_Interface as Sound0
  clone Cdsat_Theory_Impl6_Invariant_Interface as Invariant0
  use mach.int.Int
  use mach.int.Int32
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_SatisfiedBy_Interface as SatisfiedBy0
  clone Cdsat_Theory_Impl4_Level_Interface as Level1 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_LevelOf_Interface as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level1.level, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_Contains_Interface as Contains1 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_Sound_Interface as Sound2
  clone Cdsat_Theory_Impl4_Restrict_Interface as Restrict0 with predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level1.level, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  function Len0.len = Len0.len, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, axiom .
  clone Cdsat_Theory_Impl4_IsSetLevel_Interface as IsSetLevel0
  clone Cdsat_Theory_Impl1_IsBool_Interface as IsBool0
  clone CreusotContracts_Logic_Fset_Impl0_Contains_Interface as Contains0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone CreusotContracts_Logic_Fset_Impl0_Remove_Interface as Remove0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_RestrictIdempotent_Interface as RestrictIdempotent0 with predicate Invariant0.invariant' = Invariant1.invariant',
  function Restrict0.restrict = Restrict0.restrict, predicate Contains0.contains = Contains1.contains,
  function LevelOf0.level_of = LevelOf0.level_of, function Level0.level = Level1.level,
  predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by, function Len0.len = Len0.len,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  axiom .
  clone Cdsat_Theory_Impl4_RestrictSound_Interface as RestrictSound0 with predicate Sound0.sound = Sound2.sound,
  function Restrict0.restrict = Restrict0.restrict, predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level1.level, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  function Len0.len = Len0.len, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, axiom .
  clone Cdsat_Theory_Impl6_Level_Interface as Level0
  predicate undo_clear [#"/Users/xavier/Code/cdsat/src/theory.rs" 745 4 745 66] (self : Type.cdsat_theory_conflict) (a : (Type.cdsat_theory_term, Type.cdsat_theory_value)) (tgt : Type.cdsat_theory_normal)
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 746 8 752 11] let _ = RestrictSound0.restrict_sound (Type.cdsat_theory_conflict_Conflict_0 self) (Level0.level self - 1) in let _ = RestrictIdempotent0.restrict_idempotent (Type.cdsat_theory_conflict_Conflict_0 self) 0 (Level0.level self - 1) in let e = Remove0.remove (Type.cdsat_theory_conflict_Conflict_1 self) a in Contains0.contains (Type.cdsat_theory_conflict_Conflict_1 self) a /\ not IsBool0.is_bool (let (_, a) = a in a) /\ (exists l : (int) . l >= 0 /\ Level0.level self > l /\ IsSetLevel0.is_set_level (Type.cdsat_theory_conflict_Conflict_0 self) e l) /\ Type.cdsat_theory_normal_Normal_0 tgt = Restrict0.restrict (Type.cdsat_theory_conflict_Conflict_0 self) (Level0.level self - 1)
  axiom undo_clear_spec : forall self : Type.cdsat_theory_conflict, a : (Type.cdsat_theory_term, Type.cdsat_theory_value), tgt : Type.cdsat_theory_normal . ([#"/Users/xavier/Code/cdsat/src/theory.rs" 740 15 740 31] Invariant0.invariant' self) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 741 15 741 27] Sound0.sound self) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 744 4 744 46] undo_clear self a tgt -> Impls0.impls (Type.cdsat_theory_conflict_Conflict_0 self) (Type.cdsat_theory_normal_Normal_0 tgt)) && ([#"/Users/xavier/Code/cdsat/src/theory.rs" 743 4 743 38] undo_clear self a tgt -> Sound1.sound tgt) && ([#"/Users/xavier/Code/cdsat/src/theory.rs" 742 4 742 44] undo_clear self a tgt -> Invariant1.invariant' (Type.cdsat_theory_normal_Normal_0 tgt))
end
module Cdsat_Theory_Impl6_UndoClear_Impl
  use Type
  use mach.int.Int
  use mach.int.Int32
  clone Cdsat_Theory_Impl1_Sort as Sort1
  clone Cdsat_Theory_Impl0_Sort as Sort0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl3_Invariant as Invariant2 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl3_Interp as Interp0 with predicate Invariant0.invariant' = Invariant2.invariant',
  function Sort0.sort = Sort1.sort, function Sort1.sort = Sort0.sort, axiom .
  clone Cdsat_Theory_Impl1_IsBool as IsBool0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl1_Negate as Negate0 with predicate IsBool0.is_bool = IsBool0.is_bool, axiom .
  clone Cdsat_Theory_Impl3_Satisfies as Satisfies0 with function Interp0.interp = Interp0.interp,
  predicate Invariant0.invariant' = Invariant2.invariant', function Sort0.sort = Sort1.sort,
  function Sort1.sort = Sort0.sort
  clone CreusotContracts_Logic_Fset_Impl0_Contains as Contains0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl3_SatisfySet as SatisfySet0 with predicate Contains0.contains = Contains0.contains,
  predicate Satisfies0.satisfies = Satisfies0.satisfies
  clone Cdsat_Theory_Impl2_JustifiedSound as JustifiedSound0 with predicate Invariant0.invariant' = Invariant2.invariant',
  predicate SatisfySet0.satisfy_set = SatisfySet0.satisfy_set, predicate Satisfies0.satisfies = Satisfies0.satisfies
  clone Cdsat_Theory_Impl2_Invariant as Invariant3 with function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl2_ToPair as ToPair0
  clone Cdsat_Theory_Impl4_Len as Len0 with axiom .
  clone Cdsat_Theory_Impl4_InvariantAssign as InvariantAssign0 with predicate Invariant0.invariant' = Invariant3.invariant'
  clone Cdsat_Theory_Impl4_Level as Level1 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg as InvariantNonneg0 with function Level0.level = Level1.level,
  function Len0.len = Len0.len
  clone Cdsat_Theory_Impl4_Find as Find0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level1.level,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_LevelOf as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level1.level, function Len0.len = Len0.len, function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_Contains as Contains1 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level1.level,
  function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_TrailUnique as TrailUnique0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate Contains0.contains = Contains1.contains, predicate IsBool0.is_bool = IsBool0.is_bool,
  function Negate0.negate = Negate0.negate,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_InvariantContains as InvariantContains0 with predicate Contains0.contains = Contains0.contains,
  predicate Contains1.contains = Contains1.contains,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone CreusotContracts_Logic_Fset_Impl0_Remove as Remove0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_SetLevel as SetLevel0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level1.level, function Len0.len = Len0.len, function Remove0.remove = Remove0.remove, axiom .
  clone Cdsat_Theory_Impl4_InvariantLevel as InvariantLevel0 with function Level0.level = Level1.level,
  function SetLevel0.set_level = SetLevel0.set_level, function Len0.len = Len0.len,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of
  clone Cdsat_Theory_Impl4_Invariant as Invariant1 with predicate InvariantLevel0.invariant_level = InvariantLevel0.invariant_level,
  predicate InvariantContains0.invariant_contains = InvariantContains0.invariant_contains,
  predicate TrailUnique0.trail_unique = TrailUnique0.trail_unique,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign
  clone Cdsat_Theory_Impl4_CountBounds as CountBounds0 with predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level1.level, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_SatisfiedBy as SatisfiedBy0 with predicate Contains0.contains = Contains1.contains,
  predicate Satisfies0.satisfies = Satisfies0.satisfies,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_Restrict as Restrict0 with predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level1.level, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  function Len0.len = Len0.len, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function CountBounds0.count_bounds = CountBounds0.count_bounds, axiom .
  clone Cdsat_Theory_Impl4_Unsat as Unsat0 with predicate Invariant0.invariant' = Invariant2.invariant',
  function Restrict0.restrict = Restrict0.restrict, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  predicate Invariant1.invariant' = Invariant1.invariant', predicate Contains0.contains = Contains1.contains,
  function LevelOf0.level_of = LevelOf0.level_of, function Level0.level = Level1.level, function Len0.len = Len0.len,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg
  clone Cdsat_Theory_Impl4_Sound as Sound2 with predicate JustifiedSound0.justified_sound = JustifiedSound0.justified_sound
  clone Cdsat_Theory_Impl4_IsSetLevel as IsSetLevel0 with predicate Contains0.contains = Contains0.contains,
  function LevelOf0.level_of = LevelOf0.level_of,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level1.level,
  function Len0.len = Len0.len
  clone Cdsat_Theory_Impl4_RestrictIdempotent as RestrictIdempotent0 with predicate Invariant0.invariant' = Invariant1.invariant',
  function Restrict0.restrict = Restrict0.restrict, predicate Contains0.contains = Contains1.contains,
  function LevelOf0.level_of = LevelOf0.level_of, function Level0.level = Level1.level,
  predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by, function Len0.len = Len0.len,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  axiom .
  clone Cdsat_Theory_Impl4_RestrictSound as RestrictSound0 with predicate Sound0.sound = Sound2.sound,
  function Restrict0.restrict = Restrict0.restrict, predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level1.level, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  function Len0.len = Len0.len, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, axiom .
  clone Cdsat_Theory_Impl6_Level as Level0 with function SetLevel0.set_level = SetLevel0.set_level,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level1.level, function Len0.len = Len0.len
  clone Cdsat_Theory_Impl4_Impls as Impls0 with predicate Unsat0.unsat = Unsat0.unsat,
  predicate Invariant0.invariant' = Invariant2.invariant', function Restrict0.restrict = Restrict0.restrict,
  predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  predicate Invariant1.invariant' = Invariant1.invariant', predicate Contains0.contains = Contains1.contains,
  function LevelOf0.level_of = LevelOf0.level_of, function Level0.level = Level1.level, function Len0.len = Len0.len,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  axiom .
  clone Cdsat_Theory_Impl5_Sound as Sound1 with predicate Sound0.sound = Sound2.sound
  clone Cdsat_Theory_Impl6_Sound as Sound0 with predicate Sound0.sound = Sound2.sound,
  predicate Invariant0.invariant' = Invariant2.invariant', predicate SatisfySet0.satisfy_set = SatisfySet0.satisfy_set
  clone Cdsat_Theory_Impl6_Invariant as Invariant0 with function SetLevel0.set_level = SetLevel0.set_level,
  predicate Invariant0.invariant' = Invariant1.invariant', predicate Contains0.contains = Contains0.contains,
  predicate Contains1.contains = Contains1.contains,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function LevelOf0.level_of = LevelOf0.level_of, function Level0.level = Level1.level, function Len0.len = Len0.len,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  let rec ghost function undo_clear (self : Type.cdsat_theory_conflict) (a : (Type.cdsat_theory_term, Type.cdsat_theory_value)) (tgt : Type.cdsat_theory_normal) : bool
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 740 15 740 31] Invariant0.invariant' self}
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 741 15 741 27] Sound0.sound self}
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 742 4 742 44] result -> Invariant1.invariant' (Type.cdsat_theory_normal_Normal_0 tgt) }
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 743 4 743 38] result -> Sound1.sound tgt }
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 744 4 744 46] result -> Impls0.impls (Type.cdsat_theory_conflict_Conflict_0 self) (Type.cdsat_theory_normal_Normal_0 tgt) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 746 8 752 11] let _ = let a' = Type.cdsat_theory_conflict_Conflict_0 self in let b' = Level0.level self - 1 in RestrictSound0.restrict_sound a' b' in let _ = let a' = Type.cdsat_theory_conflict_Conflict_0 self in let c' = Level0.level self - 1 in RestrictIdempotent0.restrict_idempotent a' 0 c' in let e = let a' = Type.cdsat_theory_conflict_Conflict_1 self in Remove0.remove a' a in (let a' = Type.cdsat_theory_conflict_Conflict_1 self in Contains0.contains a' a) && not IsBool0.is_bool (let (_, a) = a in a) && pure {exists l : (int) . l >= 0 /\ Level0.level self > l /\ IsSetLevel0.is_set_level (Type.cdsat_theory_conflict_Conflict_0 self) e l} && (let b = let a' = Type.cdsat_theory_conflict_Conflict_0 self in let b' = Level0.level self - 1 in Restrict0.restrict a' b' in let a = Type.cdsat_theory_normal_Normal_0 tgt in pure {a = b})
end
module Cdsat_Theory_Impl4_IsJustified_Interface
  use Type
  predicate is_justified (self : Type.cdsat_theory_trail) (d : (Type.cdsat_theory_term, Type.cdsat_theory_value))
end
module Cdsat_Theory_Impl4_IsJustified
  use Type
  use mach.int.Int
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl2_ToPair_Interface as ToPair0
  clone Cdsat_Theory_Impl4_Find_Interface as Find0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function Len0.len = Len0.len, axiom .
  predicate is_justified [#"/Users/xavier/Code/cdsat/src/theory.rs" 357 4 357 51] (self : Type.cdsat_theory_trail) (d : (Type.cdsat_theory_term, Type.cdsat_theory_value))
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 358 8 361 9] match (Find0.find self d) with
      | Type.Core_Option_Option_Some (Type.Cdsat_Theory_Assign_Justified _ _ _, _) -> true
      | _ -> false
      end
end
module Cdsat_Theory_Impl4_FindJustified_Interface
  use mach.int.Int
  use Type
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl2_ToPair_Interface as ToPair0
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone Cdsat_Theory_Impl2_JustifiedSound_Interface as JustifiedSound0
  clone Cdsat_Theory_Impl4_Find_Interface as Find0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_Contains_Interface as Contains0 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_Sound_Interface as Sound0
  function find_justified (self : Type.cdsat_theory_trail) (kv : (Type.cdsat_theory_term, Type.cdsat_theory_value)) : ()
end
module Cdsat_Theory_Impl4_FindJustified
  use mach.int.Int
  use Type
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl2_ToPair_Interface as ToPair0
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone Cdsat_Theory_Impl2_JustifiedSound_Interface as JustifiedSound0
  clone Cdsat_Theory_Impl4_Find_Interface as Find0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_Contains_Interface as Contains0 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_Sound_Interface as Sound0
  function find_justified [#"/Users/xavier/Code/cdsat/src/theory.rs" 417 4 417 46] (self : Type.cdsat_theory_trail) (kv : (Type.cdsat_theory_term, Type.cdsat_theory_value)) : ()
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 418 8 427 9] match (self) with
      | Type.Cdsat_Theory_Trail_Empty -> ()
      | Type.Cdsat_Theory_Trail_Assign a l tl -> if ToPair0.to_pair a = kv then () else find_justified tl kv
      end
  axiom find_justified_spec : forall self : Type.cdsat_theory_trail, kv : (Type.cdsat_theory_term, Type.cdsat_theory_value) . ([#"/Users/xavier/Code/cdsat/src/theory.rs" 414 15 414 27] Sound0.sound self) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 415 15 415 32] Contains0.contains self kv) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 416 4 416 90] forall l : (int) . forall a : (Type.cdsat_theory_assign) . Find0.find self kv = Type.Core_Option_Option_Some (a, l) -> JustifiedSound0.justified_sound a)
end
module Cdsat_Theory_Impl4_FindJustified_Impl
  use mach.int.Int
  use Type
  clone Cdsat_Theory_Impl1_Sort as Sort1
  clone Cdsat_Theory_Impl0_Sort as Sort0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl3_Invariant as Invariant0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl3_Interp as Interp0 with predicate Invariant0.invariant' = Invariant0.invariant',
  function Sort0.sort = Sort1.sort, function Sort1.sort = Sort0.sort, axiom .
  clone CreusotContracts_Logic_Fset_Impl0_Contains as Contains1 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl2_Invariant as Invariant1 with function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl3_Satisfies as Satisfies0 with function Interp0.interp = Interp0.interp,
  predicate Invariant0.invariant' = Invariant0.invariant', function Sort0.sort = Sort1.sort,
  function Sort1.sort = Sort0.sort
  clone Cdsat_Theory_Impl3_SatisfySet as SatisfySet0 with predicate Contains0.contains = Contains1.contains,
  predicate Satisfies0.satisfies = Satisfies0.satisfies
  clone Cdsat_Theory_Impl4_Len as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg as InvariantNonneg0 with function Level0.level = Level0.level,
  function Len0.len = Len0.len
  clone Cdsat_Theory_Impl4_InvariantAssign as InvariantAssign0 with predicate Invariant0.invariant' = Invariant1.invariant'
  clone Cdsat_Theory_Impl2_ToPair as ToPair0
  clone Cdsat_Theory_Impl2_JustifiedSound as JustifiedSound0 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate SatisfySet0.satisfy_set = SatisfySet0.satisfy_set, predicate Satisfies0.satisfies = Satisfies0.satisfies
  clone Cdsat_Theory_Impl4_Find as Find0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_Contains as Contains0 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_Sound as Sound0 with predicate JustifiedSound0.justified_sound = JustifiedSound0.justified_sound
  let rec ghost function find_justified (self : Type.cdsat_theory_trail) (kv : (Type.cdsat_theory_term, Type.cdsat_theory_value)) : ()
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 414 15 414 27] Sound0.sound self}
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 415 15 415 32] Contains0.contains self kv}
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 416 4 416 90] forall l : (int) . forall a : (Type.cdsat_theory_assign) . Find0.find self kv = Type.Core_Option_Option_Some (a, l) -> JustifiedSound0.justified_sound a }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 418 8 427 9] match (self) with
      | Type.Cdsat_Theory_Trail_Empty -> ()
      | Type.Cdsat_Theory_Trail_Assign a l tl -> if let a = ToPair0.to_pair a in pure {a = kv} then
        ()
      else
        find_justified tl kv
      
      end
end
module Cdsat_Theory_Impl4_Justification_Interface
  use Type
  use set.Fset
  clone Cdsat_Theory_Impl3_Satisfies_Interface as Satisfies0
  clone Cdsat_Theory_Impl3_SatisfySet_Interface as SatisfySet0
  clone Cdsat_Theory_Impl3_Invariant_Interface as Invariant0
  clone Cdsat_Theory_Impl4_Sound_Interface as Sound0
  clone Cdsat_Theory_Impl4_IsJustified_Interface as IsJustified0
  function justification (self : Type.cdsat_theory_trail) (d : (Type.cdsat_theory_term, Type.cdsat_theory_value)) : Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value)
    
end
module Cdsat_Theory_Impl4_Justification
  use Type
  use set.Fset
  clone Cdsat_Theory_Impl3_Satisfies_Interface as Satisfies0
  clone Cdsat_Theory_Impl3_SatisfySet_Interface as SatisfySet0
  clone Cdsat_Theory_Impl3_Invariant_Interface as Invariant0
  clone Cdsat_Theory_Impl4_Sound_Interface as Sound0
  clone Cdsat_Theory_Impl4_IsJustified_Interface as IsJustified0
  use mach.int.Int
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl2_ToPair_Interface as ToPair0
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone Cdsat_Theory_Impl2_JustifiedSound_Interface as JustifiedSound0
  clone Cdsat_Theory_Impl4_Contains_Interface as Contains0 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_Find_Interface as Find0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_FindJustified_Interface as FindJustified0 with predicate Sound0.sound = Sound0.sound,
  predicate Contains0.contains = Contains0.contains, function Find0.find = Find0.find,
  predicate JustifiedSound0.justified_sound = JustifiedSound0.justified_sound,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  function Len0.len = Len0.len, axiom .
  function justification [#"/Users/xavier/Code/cdsat/src/theory.rs" 348 4 348 67] (self : Type.cdsat_theory_trail) (d : (Type.cdsat_theory_term, Type.cdsat_theory_value)) : Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value)
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 349 8 349 30] let _ = FindJustified0.find_justified self d in match (Find0.find self d) with
      | Type.Core_Option_Option_Some (Type.Cdsat_Theory_Assign_Justified j _ _, _) -> j
      | _ -> Fset.empty 
      end
  axiom justification_spec : forall self : Type.cdsat_theory_trail, d : (Type.cdsat_theory_term, Type.cdsat_theory_value) . ([#"/Users/xavier/Code/cdsat/src/theory.rs" 345 15 345 35] IsJustified0.is_justified self d) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 346 15 346 27] Sound0.sound self) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 347 4 347 92] forall m : (Type.cdsat_theory_model) . Invariant0.invariant' m -> SatisfySet0.satisfy_set m (justification self d) -> Satisfies0.satisfies m d)
end
module Cdsat_Theory_Impl4_Justification_Impl
  use Type
  use set.Fset
  use mach.int.Int
  clone Cdsat_Theory_Impl1_Sort as Sort1
  clone Cdsat_Theory_Impl0_Sort as Sort0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl2_Invariant as Invariant1 with function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_Len as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg as InvariantNonneg0 with function Level0.level = Level0.level,
  function Len0.len = Len0.len
  clone Cdsat_Theory_Impl2_ToPair as ToPair0
  clone Cdsat_Theory_Impl4_InvariantAssign as InvariantAssign0 with predicate Invariant0.invariant' = Invariant1.invariant'
  clone Cdsat_Theory_Impl4_Find as Find0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_Contains as Contains1 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl3_Invariant as Invariant0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl3_Interp as Interp0 with predicate Invariant0.invariant' = Invariant0.invariant',
  function Sort0.sort = Sort1.sort, function Sort1.sort = Sort0.sort, axiom .
  clone CreusotContracts_Logic_Fset_Impl0_Contains as Contains0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl3_Satisfies as Satisfies0 with function Interp0.interp = Interp0.interp,
  predicate Invariant0.invariant' = Invariant0.invariant', function Sort0.sort = Sort1.sort,
  function Sort1.sort = Sort0.sort
  clone Cdsat_Theory_Impl3_SatisfySet as SatisfySet0 with predicate Contains0.contains = Contains0.contains,
  predicate Satisfies0.satisfies = Satisfies0.satisfies
  clone Cdsat_Theory_Impl2_JustifiedSound as JustifiedSound0 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate SatisfySet0.satisfy_set = SatisfySet0.satisfy_set, predicate Satisfies0.satisfies = Satisfies0.satisfies
  clone Cdsat_Theory_Impl4_Sound as Sound0 with predicate JustifiedSound0.justified_sound = JustifiedSound0.justified_sound
  clone Cdsat_Theory_Impl4_FindJustified as FindJustified0 with predicate Sound0.sound = Sound0.sound,
  predicate Contains0.contains = Contains1.contains, function Find0.find = Find0.find,
  predicate JustifiedSound0.justified_sound = JustifiedSound0.justified_sound,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_IsJustified as IsJustified0 with function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function Len0.len = Len0.len
  let rec ghost function justification (self : Type.cdsat_theory_trail) (d : (Type.cdsat_theory_term, Type.cdsat_theory_value)) : Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value)
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 345 15 345 35] IsJustified0.is_justified self d}
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 346 15 346 27] Sound0.sound self}
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 347 4 347 92] forall m : (Type.cdsat_theory_model) . Invariant0.invariant' m -> SatisfySet0.satisfy_set m result -> Satisfies0.satisfies m d }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 349 8 349 30] let _ = FindJustified0.find_justified self d in match (Find0.find self d) with
      | Type.Core_Option_Option_Some (Type.Cdsat_Theory_Assign_Justified j _ _, _) -> j
      | _ -> Fset.empty 
      end
end
module Cdsat_Theory_Impl6_UndoDecide_Interface
  use Type
  clone Cdsat_Theory_Impl4_Unsat_Interface as Unsat0
  clone Cdsat_Theory_Impl4_Impls_Interface as Impls0 with predicate Unsat0.unsat = Unsat0.unsat, axiom .
  clone Cdsat_Theory_Impl5_Sound_Interface as Sound1
  clone Cdsat_Theory_Impl4_Invariant_Interface as Invariant1
  clone Cdsat_Theory_Impl6_Sound_Interface as Sound0
  clone Cdsat_Theory_Impl6_Invariant_Interface as Invariant0
  predicate undo_decide (self : Type.cdsat_theory_conflict) (l : (Type.cdsat_theory_term, Type.cdsat_theory_value)) (tgt : Type.cdsat_theory_normal)
    
end
module Cdsat_Theory_Impl6_UndoDecide
  use Type
  clone Cdsat_Theory_Impl4_Unsat_Interface as Unsat0
  clone Cdsat_Theory_Impl4_Impls_Interface as Impls0 with predicate Unsat0.unsat = Unsat0.unsat, axiom .
  clone Cdsat_Theory_Impl5_Sound_Interface as Sound1
  clone Cdsat_Theory_Impl4_Invariant_Interface as Invariant1
  clone Cdsat_Theory_Impl6_Sound_Interface as Sound0
  clone Cdsat_Theory_Impl6_Invariant_Interface as Invariant0
  use mach.int.Int
  use mach.int.Int32
  clone Cdsat_Theory_Impl3_Satisfies_Interface as Satisfies0
  clone Cdsat_Theory_Impl3_SatisfySet_Interface as SatisfySet0
  clone Cdsat_Theory_Impl3_Invariant_Interface as Invariant2
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_SatisfiedBy_Interface as SatisfiedBy0
  clone Cdsat_Theory_Impl4_Contains_Interface as Contains1 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_Sound_Interface as Sound2
  clone Cdsat_Theory_Impl4_Level_Interface as Level1 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl1_IsBool_Interface as IsBool0
  clone Cdsat_Theory_Impl1_Negate_Interface as Negate0 with predicate IsBool0.is_bool = IsBool0.is_bool, axiom .
  clone Cdsat_Theory_Impl4_LevelOf_Interface as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level1.level, function Len0.len = Len0.len, axiom .
  clone CreusotContracts_Logic_Fset_Impl0_Contains_Interface as Contains0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_IsJustified_Interface as IsJustified0
  clone Cdsat_Theory_Impl4_Restrict_Interface as Restrict0 with predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level1.level, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  function Len0.len = Len0.len, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, axiom .
  clone CreusotContracts_Logic_Fset_Impl0_Remove_Interface as Remove0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_Justification_Interface as Justification0 with predicate IsJustified0.is_justified = IsJustified0.is_justified,
  predicate Sound0.sound = Sound2.sound, predicate Invariant0.invariant' = Invariant2.invariant',
  predicate SatisfySet0.satisfy_set = SatisfySet0.satisfy_set, predicate Satisfies0.satisfies = Satisfies0.satisfies,
  axiom .
  clone Cdsat_Theory_Impl1_NegateInvolutive_Interface as NegateInvolutive0 with predicate IsBool0.is_bool = IsBool0.is_bool,
  function Negate0.negate = Negate0.negate, axiom .
  clone Cdsat_Theory_Impl4_TrailPlausible_Interface as TrailPlausible0 with predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Contains0.contains = Contains1.contains, predicate IsBool0.is_bool = IsBool0.is_bool,
  function Negate0.negate = Negate0.negate,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_RestrictTooBig_Interface as RestrictTooBig0 with predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Restrict0.restrict = Restrict0.restrict,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level1.level, function Len0.len = Len0.len,
  predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by, axiom .
  clone Cdsat_Theory_Impl4_RestrictSound_Interface as RestrictSound0 with predicate Sound0.sound = Sound2.sound,
  function Restrict0.restrict = Restrict0.restrict, predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level1.level, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  function Len0.len = Len0.len, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, axiom .
  clone Cdsat_Theory_Impl6_Level_Interface as Level0
  predicate undo_decide [#"/Users/xavier/Code/cdsat/src/theory.rs" 762 4 762 67] (self : Type.cdsat_theory_conflict) (l : (Type.cdsat_theory_term, Type.cdsat_theory_value)) (tgt : Type.cdsat_theory_normal)
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 763 8 775 11] let _ = RestrictSound0.restrict_sound (Type.cdsat_theory_conflict_Conflict_0 self) (Level0.level self - 1) in let _ = RestrictTooBig0.restrict_too_big (Type.cdsat_theory_conflict_Conflict_0 self) (Level0.level self - 1) l in let _ = TrailPlausible0.trail_plausible (Type.cdsat_theory_conflict_Conflict_0 self) l in let _ = NegateInvolutive0.negate_involutive (let (_, a) = l in a) in let just = Justification0.justification (Type.cdsat_theory_conflict_Conflict_0 self) l in let e = Remove0.remove (Type.cdsat_theory_conflict_Conflict_1 self) l in let restr = Restrict0.restrict (Type.cdsat_theory_conflict_Conflict_0 self) (Level0.level self - 1) in IsJustified0.is_justified (Type.cdsat_theory_conflict_Conflict_0 self) l /\ IsBool0.is_bool (let (_, a) = l in a) /\ (exists a : ((Type.cdsat_theory_term, Type.cdsat_theory_value)) . Contains0.contains just a /\ not IsBool0.is_bool (let (_, a) = a in a) /\ LevelOf0.level_of (Type.cdsat_theory_conflict_Conflict_0 self) a = Level0.level self) /\ Level0.level self = LevelOf0.level_of (Type.cdsat_theory_conflict_Conflict_0 self) l /\ Type.cdsat_theory_normal_Normal_0 tgt = Type.Cdsat_Theory_Trail_Assign (Type.Cdsat_Theory_Assign_Decision (let (a, _) = l in a) (Negate0.negate (let (_, a) = l in a))) (Level1.level restr + 1) restr
  axiom undo_decide_spec : forall self : Type.cdsat_theory_conflict, l : (Type.cdsat_theory_term, Type.cdsat_theory_value), tgt : Type.cdsat_theory_normal . ([#"/Users/xavier/Code/cdsat/src/theory.rs" 757 15 757 31] Invariant0.invariant' self) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 758 15 758 27] Sound0.sound self) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 761 4 761 46] undo_decide self l tgt -> Impls0.impls (Type.cdsat_theory_conflict_Conflict_0 self) (Type.cdsat_theory_normal_Normal_0 tgt)) && ([#"/Users/xavier/Code/cdsat/src/theory.rs" 760 4 760 38] undo_decide self l tgt -> Sound1.sound tgt) && ([#"/Users/xavier/Code/cdsat/src/theory.rs" 759 4 759 44] undo_decide self l tgt -> Invariant1.invariant' (Type.cdsat_theory_normal_Normal_0 tgt))
end
module Cdsat_Theory_Impl6_UndoDecide_Impl
  use Type
  use mach.int.Int
  use mach.int.Int32
  clone Cdsat_Theory_Impl1_Sort as Sort1
  clone Cdsat_Theory_Impl0_Sort as Sort0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl3_Invariant as Invariant2 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl3_Interp as Interp0 with predicate Invariant0.invariant' = Invariant2.invariant',
  function Sort0.sort = Sort1.sort, function Sort1.sort = Sort0.sort, axiom .
  clone Cdsat_Theory_Impl2_Invariant as Invariant3 with function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_Len as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level as Level1 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg as InvariantNonneg0 with function Level0.level = Level1.level,
  function Len0.len = Len0.len
  clone Cdsat_Theory_Impl4_InvariantAssign as InvariantAssign0 with predicate Invariant0.invariant' = Invariant3.invariant'
  clone Cdsat_Theory_Impl2_ToPair as ToPair0
  clone Cdsat_Theory_Impl4_Find as Find0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level1.level,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_LevelOf as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level1.level, function Len0.len = Len0.len, function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_Contains as Contains1 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level1.level,
  function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl1_IsBool as IsBool0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl1_Negate as Negate0 with predicate IsBool0.is_bool = IsBool0.is_bool, axiom .
  clone Cdsat_Theory_Impl4_TrailUnique as TrailUnique0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate Contains0.contains = Contains1.contains, predicate IsBool0.is_bool = IsBool0.is_bool,
  function Negate0.negate = Negate0.negate,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone CreusotContracts_Logic_Fset_Impl0_Contains as Contains0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_InvariantContains as InvariantContains0 with predicate Contains0.contains = Contains0.contains,
  predicate Contains1.contains = Contains1.contains,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone CreusotContracts_Logic_Fset_Impl0_Remove as Remove0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_SetLevel as SetLevel0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level1.level, function Len0.len = Len0.len, function Remove0.remove = Remove0.remove, axiom .
  clone Cdsat_Theory_Impl4_InvariantLevel as InvariantLevel0 with function Level0.level = Level1.level,
  function SetLevel0.set_level = SetLevel0.set_level, function Len0.len = Len0.len,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of
  clone Cdsat_Theory_Impl4_Invariant as Invariant1 with predicate InvariantLevel0.invariant_level = InvariantLevel0.invariant_level,
  predicate InvariantContains0.invariant_contains = InvariantContains0.invariant_contains,
  predicate TrailUnique0.trail_unique = TrailUnique0.trail_unique,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign
  clone Cdsat_Theory_Impl4_CountBounds as CountBounds0 with predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level1.level, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl3_Satisfies as Satisfies0 with function Interp0.interp = Interp0.interp,
  predicate Invariant0.invariant' = Invariant2.invariant', function Sort0.sort = Sort1.sort,
  function Sort1.sort = Sort0.sort
  clone Cdsat_Theory_Impl3_SatisfySet as SatisfySet0 with predicate Contains0.contains = Contains0.contains,
  predicate Satisfies0.satisfies = Satisfies0.satisfies
  clone Cdsat_Theory_Impl2_JustifiedSound as JustifiedSound0 with predicate Invariant0.invariant' = Invariant2.invariant',
  predicate SatisfySet0.satisfy_set = SatisfySet0.satisfy_set, predicate Satisfies0.satisfies = Satisfies0.satisfies
  clone Cdsat_Theory_Impl4_Sound as Sound2 with predicate JustifiedSound0.justified_sound = JustifiedSound0.justified_sound
  clone Cdsat_Theory_Impl4_FindJustified as FindJustified0 with predicate Sound0.sound = Sound2.sound,
  predicate Contains0.contains = Contains1.contains, function Find0.find = Find0.find,
  predicate JustifiedSound0.justified_sound = JustifiedSound0.justified_sound,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level1.level,
  function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_SatisfiedBy as SatisfiedBy0 with predicate Contains0.contains = Contains1.contains,
  predicate Satisfies0.satisfies = Satisfies0.satisfies,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_Restrict as Restrict0 with predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level1.level, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  function Len0.len = Len0.len, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function CountBounds0.count_bounds = CountBounds0.count_bounds, axiom .
  clone Cdsat_Theory_Impl4_Unsat as Unsat0 with predicate Invariant0.invariant' = Invariant2.invariant',
  function Restrict0.restrict = Restrict0.restrict, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  predicate Invariant1.invariant' = Invariant1.invariant', predicate Contains0.contains = Contains1.contains,
  function LevelOf0.level_of = LevelOf0.level_of, function Level0.level = Level1.level, function Len0.len = Len0.len,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg
  clone Cdsat_Theory_Impl4_IsJustified as IsJustified0 with function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level1.level,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function Len0.len = Len0.len
  clone Cdsat_Theory_Impl4_Justification as Justification0 with predicate IsJustified0.is_justified = IsJustified0.is_justified,
  predicate Sound0.sound = Sound2.sound, predicate Invariant0.invariant' = Invariant2.invariant',
  predicate SatisfySet0.satisfy_set = SatisfySet0.satisfy_set, predicate Satisfies0.satisfies = Satisfies0.satisfies,
  function FindJustified0.find_justified = FindJustified0.find_justified, function Find0.find = Find0.find,
  predicate Contains0.contains = Contains1.contains,
  predicate JustifiedSound0.justified_sound = JustifiedSound0.justified_sound,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level1.level,
  function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl1_NegateInvolutive as NegateInvolutive0 with predicate IsBool0.is_bool = IsBool0.is_bool,
  function Negate0.negate = Negate0.negate, axiom .
  clone Cdsat_Theory_Impl4_TrailPlausible as TrailPlausible0 with predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Contains0.contains = Contains1.contains, predicate IsBool0.is_bool = IsBool0.is_bool,
  function Negate0.negate = Negate0.negate,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function ToPair0.to_pair = ToPair0.to_pair, axiom .
  clone Cdsat_Theory_Impl4_RestrictTooBig as RestrictTooBig0 with predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Restrict0.restrict = Restrict0.restrict,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level1.level, function Len0.len = Len0.len,
  predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by, function ToPair0.to_pair = ToPair0.to_pair, axiom .
  clone Cdsat_Theory_Impl4_RestrictSound as RestrictSound0 with predicate Sound0.sound = Sound2.sound,
  function Restrict0.restrict = Restrict0.restrict, predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level1.level, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  function Len0.len = Len0.len, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, axiom .
  clone Cdsat_Theory_Impl6_Level as Level0 with function SetLevel0.set_level = SetLevel0.set_level,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level1.level, function Len0.len = Len0.len
  clone Cdsat_Theory_Impl4_Impls as Impls0 with predicate Unsat0.unsat = Unsat0.unsat,
  predicate Invariant0.invariant' = Invariant2.invariant', function Restrict0.restrict = Restrict0.restrict,
  predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  predicate Invariant1.invariant' = Invariant1.invariant', predicate Contains0.contains = Contains1.contains,
  function LevelOf0.level_of = LevelOf0.level_of, function Level0.level = Level1.level, function Len0.len = Len0.len,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  axiom .
  clone Cdsat_Theory_Impl5_Sound as Sound1 with predicate Sound0.sound = Sound2.sound
  clone Cdsat_Theory_Impl6_Sound as Sound0 with predicate Sound0.sound = Sound2.sound,
  predicate Invariant0.invariant' = Invariant2.invariant', predicate SatisfySet0.satisfy_set = SatisfySet0.satisfy_set
  clone Cdsat_Theory_Impl6_Invariant as Invariant0 with function SetLevel0.set_level = SetLevel0.set_level,
  predicate Invariant0.invariant' = Invariant1.invariant', predicate Contains0.contains = Contains0.contains,
  predicate Contains1.contains = Contains1.contains,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function LevelOf0.level_of = LevelOf0.level_of, function Level0.level = Level1.level, function Len0.len = Len0.len,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  let rec ghost function undo_decide (self : Type.cdsat_theory_conflict) (l : (Type.cdsat_theory_term, Type.cdsat_theory_value)) (tgt : Type.cdsat_theory_normal) : bool
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 757 15 757 31] Invariant0.invariant' self}
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 758 15 758 27] Sound0.sound self}
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 759 4 759 44] result -> Invariant1.invariant' (Type.cdsat_theory_normal_Normal_0 tgt) }
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 760 4 760 38] result -> Sound1.sound tgt }
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 761 4 761 46] result -> Impls0.impls (Type.cdsat_theory_conflict_Conflict_0 self) (Type.cdsat_theory_normal_Normal_0 tgt) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 763 8 775 11] let _ = let a' = Type.cdsat_theory_conflict_Conflict_0 self in let b' = Level0.level self - 1 in RestrictSound0.restrict_sound a' b' in let _ = let a' = Type.cdsat_theory_conflict_Conflict_0 self in let b' = Level0.level self - 1 in RestrictTooBig0.restrict_too_big a' b' l in let _ = let a' = Type.cdsat_theory_conflict_Conflict_0 self in TrailPlausible0.trail_plausible a' l in let _ = NegateInvolutive0.negate_involutive (let (_, a) = l in a) in let just = let a' = Type.cdsat_theory_conflict_Conflict_0 self in Justification0.justification a' l in let e = let a' = Type.cdsat_theory_conflict_Conflict_1 self in Remove0.remove a' l in let restr = let a' = Type.cdsat_theory_conflict_Conflict_0 self in let b' = Level0.level self - 1 in Restrict0.restrict a' b' in (let a' = Type.cdsat_theory_conflict_Conflict_0 self in IsJustified0.is_justified a' l) && IsBool0.is_bool (let (_, a) = l in a) && pure {exists a : ((Type.cdsat_theory_term, Type.cdsat_theory_value)) . Contains0.contains just a /\ not IsBool0.is_bool (let (_, a) = a in a) /\ LevelOf0.level_of (Type.cdsat_theory_conflict_Conflict_0 self) a = Level0.level self} && (let b = let a' = Type.cdsat_theory_conflict_Conflict_0 self in LevelOf0.level_of a' l in let a = Level0.level self in pure {a = b}) && (let b = Type.Cdsat_Theory_Trail_Assign (Type.Cdsat_Theory_Assign_Decision (let (a, _) = l in a) (Negate0.negate (let (_, a) = l in a))) (Level1.level restr + 1) restr in let a = Type.cdsat_theory_normal_Normal_0 tgt in pure {a = b})
end
module CreusotContracts_Std1_Vec_Impl1
  type t
  type a
end
module Cdsat_Concrete_Impl2_ModelTy
  use map.Map
  use mach.int.Int
  use Type
  type modelTy  =
    Map.map int (Type.core_option_option int)
end
module Cdsat_Concrete_Impl2
  use Type
  clone Cdsat_Concrete_Impl2_ModelTy as ModelTy0
  clone Cdsat_Concrete_Impl2_Model as Model0
  clone CreusotContracts_Logic_Model_Model_Model_Interface as Model1 with type self = Type.cdsat_concrete_conflictheap,
  function model = Model0.model, type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy1 with type self = Type.cdsat_concrete_conflictheap,
  type modelTy = ModelTy0.modelTy
end
module CreusotContracts_Std1_Vec_Impl2
  type t
  type a
end
module CreusotContracts_Std1_Vec_Impl1_ProducesRefl_Interface
  type t
  type a
  use seq.Seq
  use Type
  clone CreusotContracts_Std1_Vec_Impl1_Produces_Interface as Produces0 with type t = t, type a = a
  function produces_refl (a : Type.alloc_vec_intoiter_intoiter t a) : ()
end
module CreusotContracts_Std1_Vec_Impl1_ProducesRefl
  type t
  type a
  use seq.Seq
  use Type
  clone CreusotContracts_Std1_Vec_Impl1_Produces_Interface as Produces0 with type t = t, type a = a
  function produces_refl (a : Type.alloc_vec_intoiter_intoiter t a) : () =
    ()
  axiom produces_refl_spec : forall a : Type.alloc_vec_intoiter_intoiter t a . Produces0.produces a (Seq.empty ) a
end
module CreusotContracts_Std1_Vec_Impl1_ProducesTrans_Interface
  type t
  type a
  use seq.Seq
  use Type
  clone CreusotContracts_Std1_Vec_Impl1_Produces_Interface as Produces0 with type t = t, type a = a
  function produces_trans (a : Type.alloc_vec_intoiter_intoiter t a) (ab : Seq.seq t) (b : Type.alloc_vec_intoiter_intoiter t a) (bc : Seq.seq t) (c : Type.alloc_vec_intoiter_intoiter t a) : ()
    
end
module CreusotContracts_Std1_Vec_Impl1_ProducesTrans
  type t
  type a
  use seq.Seq
  use Type
  clone CreusotContracts_Std1_Vec_Impl1_Produces_Interface as Produces0 with type t = t, type a = a
  function produces_trans (a : Type.alloc_vec_intoiter_intoiter t a) (ab : Seq.seq t) (b : Type.alloc_vec_intoiter_intoiter t a) (bc : Seq.seq t) (c : Type.alloc_vec_intoiter_intoiter t a) : ()
    
   =
    ()
  axiom produces_trans_spec : forall a : Type.alloc_vec_intoiter_intoiter t a, ab : Seq.seq t, b : Type.alloc_vec_intoiter_intoiter t a, bc : Seq.seq t, c : Type.alloc_vec_intoiter_intoiter t a . Produces0.produces a ab b -> Produces0.produces b bc c -> Produces0.produces a (Seq.(++) ab bc) c
end
module CreusotContracts_Logic_Int_Impl20_ModelTy
  use mach.int.Int
  type modelTy  =
    int
end
module CreusotContracts_Logic_Int_Impl20
  
end
module CreusotContracts_Logic_Int_Impl20_Model_Interface
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  function model (self : usize) : int
end
module CreusotContracts_Logic_Int_Impl20_Model
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  function model (self : usize) : int =
    UInt64.to_int self
end
module Cdsat_Concrete_Impl3_New_Interface
  use Type
  use map.Const
  clone Cdsat_Concrete_Impl2_Model_Interface as Model0
  val new [@cfg:stackify] (_ : ()) : Type.cdsat_concrete_conflictheap
    ensures { [#"/Users/xavier/Code/cdsat/src/concrete.rs" 319 14 319 43] Model0.model result = Const.const (Type.Core_Option_Option_None) }
    
end
module Alloc_Vec_Impl19_IntoIter_Interface
  type t
  type a
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = t, type a = a, axiom .
  clone CreusotContracts_Std1_Vec_Impl2_Model_Interface as Model0 with type t = t, type a = a
  val into_iter [@cfg:stackify] (self : Type.alloc_vec_vec t a) : Type.alloc_vec_intoiter_intoiter t a
    ensures { Model0.model result = Model1.model self }
    
end
module CreusotContracts_Std1_Iter_IteratorSpec_Completed_Interface
  type self
  predicate completed (self : self)
end
module CreusotContracts_Std1_Iter_IteratorSpec_Completed
  type self
  predicate completed (self : self)
end
module Core_Iter_Traits_Iterator_Iterator_Item
  type self
  type item
end
module CreusotContracts_Std1_Iter_IteratorSpec_Produces_Interface
  type self
  use seq.Seq
  clone Core_Iter_Traits_Iterator_Iterator_Item as Item0 with type self = self
  predicate produces (self : self) (visited : Seq.seq Item0.item) (_3' : self)
end
module CreusotContracts_Std1_Iter_IteratorSpec_Produces
  type self
  use seq.Seq
  clone Core_Iter_Traits_Iterator_Iterator_Item as Item0 with type self = self
  predicate produces (self : self) (visited : Seq.seq Item0.item) (_3' : self)
end
module Alloc_Vec_IntoIter_Impl5_Item
  type t
  type a
  type item  =
    t
end
module Alloc_Vec_IntoIter_Impl5_Next_Interface
  type t
  type a
  use Type
  use prelude.Prelude
  use seq.Seq
  clone Alloc_Vec_IntoIter_Impl5_Item as Item0 with type t = t, type a = a
  clone CreusotContracts_Std1_Iter_IteratorSpec_Produces_Interface as Produces0 with type self = Type.alloc_vec_intoiter_intoiter t a,
  type Item0.item = Item0.item
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve_Interface as Resolve0 with type t = Type.alloc_vec_intoiter_intoiter t a
  clone CreusotContracts_Std1_Iter_IteratorSpec_Completed_Interface as Completed0 with type self = Type.alloc_vec_intoiter_intoiter t a
  val next [@cfg:stackify] (self : borrowed (Type.alloc_vec_intoiter_intoiter t a)) : Type.core_option_option t
    ensures { match (result) with
      | Type.Core_Option_Option_None -> Completed0.completed ( * self) /\ Resolve0.resolve self
      | Type.Core_Option_Option_Some v -> Produces0.produces ( * self) (Seq.singleton v) ( ^ self) /\ not Completed0.completed ( * self)
      end }
    
end
module CreusotContracts_Logic_Model_Impl1_Model_Interface
  type t
  use prelude.Prelude
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy0 with type self = t
  function model (self : borrowed t) : ModelTy0.modelTy
end
module CreusotContracts_Logic_Model_Impl1_Model
  type t
  use prelude.Prelude
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy0 with type self = t
  clone CreusotContracts_Logic_Model_Model_Model_Interface as Model0 with type self = t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  function model (self : borrowed t) : ModelTy0.modelTy =
    Model0.model ( * self)
end
module Cdsat_Concrete_Impl3_Push_Interface
  use prelude.Prelude
  use mach.int.UInt64
  use Type
  use map.Map
  use mach.int.Int
  clone Cdsat_Concrete_Impl2_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl1_Model_Interface as Model1 with type t = Type.cdsat_concrete_conflictheap,
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone Cdsat_Concrete_Impl2_Model_Interface as Model0
  val push [@cfg:stackify] (self : borrowed (Type.cdsat_concrete_conflictheap)) (e : usize) (prio : usize) : Type.core_option_option usize
    ensures { [#"/Users/xavier/Code/cdsat/src/concrete.rs" 325 14 325 54] Model0.model ( ^ self) = Map.set (Model1.model self) (UInt64.to_int e) (Type.Core_Option_Option_Some (UInt64.to_int prio)) }
    
end
module Cdsat_Concrete_Impl3_Peek_Interface
  use Type
  use map.Const
  use prelude.Prelude
  use mach.int.Int
  use mach.int.UInt64
  use map.Map
  clone CreusotContracts_Logic_Int_Impl20_ModelTy as ModelTy1
  clone Cdsat_Concrete_Impl2_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model1 with type t = usize,
  type ModelTy0.modelTy = ModelTy1.modelTy
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.cdsat_concrete_conflictheap,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val peek [@cfg:stackify] (self : Type.cdsat_concrete_conflictheap) : Type.core_option_option (usize, usize)
    ensures { [#"/Users/xavier/Code/cdsat/src/concrete.rs" 331 4 331 64] result = Type.Core_Option_Option_None -> Model0.model self = Const.const (Type.Core_Option_Option_None) }
    ensures { [#"/Users/xavier/Code/cdsat/src/concrete.rs" 332 4 332 91] forall l : (usize) . forall e : (usize) . result = Type.Core_Option_Option_Some (e, l) -> Map.get (Model0.model self) (Model1.model e) = Type.Core_Option_Option_Some (Model1.model l) }
    ensures { [#"/Users/xavier/Code/cdsat/src/concrete.rs" 333 4 333 138] forall l : (usize) . forall e : (usize) . result = Type.Core_Option_Option_Some (e, l) -> (forall l2 : (usize) . forall e2 : (usize) . Map.get (Model0.model self) (UInt64.to_int e2) = Type.Core_Option_Option_Some (UInt64.to_int l2) -> UInt64.to_int l2 <= Model1.model l) }
    
end
module Core_Option_Impl0_Unwrap_Interface
  type t
  use Type
  val unwrap [@cfg:stackify] (self : Type.core_option_option t) : t
    requires {self <> Type.Core_Option_Option_None}
    ensures { Type.Core_Option_Option_Some result = self }
    
end
module Cdsat_Concrete_Impl3_Pop_Interface
  use Type
  use map.Const
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use map.Map
  clone Cdsat_Concrete_Impl2_ModelTy as ModelTy0
  clone Cdsat_Concrete_Impl2_Model_Interface as Model1
  clone CreusotContracts_Logic_Model_Impl1_Model_Interface as Model0 with type t = Type.cdsat_concrete_conflictheap,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val pop [@cfg:stackify] (self : borrowed (Type.cdsat_concrete_conflictheap)) : Type.core_option_option (usize, usize)
    ensures { [#"/Users/xavier/Code/cdsat/src/concrete.rs" 339 4 339 64] result = Type.Core_Option_Option_None -> Model0.model self = Const.const (Type.Core_Option_Option_None) }
    ensures { [#"/Users/xavier/Code/cdsat/src/concrete.rs" 340 4 340 129] forall l : (usize) . forall e : (usize) . result = Type.Core_Option_Option_Some (e, l) -> Map.get (Model0.model self) (UInt64.to_int e) = Type.Core_Option_Option_Some (UInt64.to_int l) /\ Model1.model ( ^ self) = Map.set (Model1.model ( * self)) (UInt64.to_int e) (Type.Core_Option_Option_None) }
    
end
module Alloc_Boxed_Impl12_Clone_Interface
  type t
  type a
  use prelude.Prelude
  val clone' [@cfg:stackify] (self : t) : t
    ensures { result = self }
    
end
module Core_Clone_Impls_Impl9_Clone_Interface
  use prelude.Prelude
  use mach.int.Int
  use mach.int.UInt64
  val clone' [@cfg:stackify] (self : uint64) : uint64
    ensures { result = self }
    
end
module Core_Clone_Impls_Impl19_Clone_Interface
  use prelude.Prelude
  val clone' [@cfg:stackify] (self : bool) : bool
    ensures { result = self }
    
end
module Core_Clone_Impls_Impl9
  
end
module Core_Clone_Impls_Impl19
  
end
module Cdsat_Trail_Impl25_Clone_Interface
  use prelude.Prelude
  use Type
  val clone' [@cfg:stackify] (self : Type.cdsat_trail_value) : Type.cdsat_trail_value
    ensures { [#"/Users/xavier/Code/cdsat/src/trail.rs" 111 9 111 14] result = self }
    
end
module Core_Clone_Impls_Impl5_Clone_Interface
  use prelude.Prelude
  use mach.int.Int
  use mach.int.UInt64
  val clone' [@cfg:stackify] (self : usize) : usize
    ensures { result = self }
    
end
module Cdsat_Trail_Impl17_Clone_Interface
  use prelude.Prelude
  use Type
  val clone' [@cfg:stackify] (self : Type.cdsat_trail_sort) : Type.cdsat_trail_sort
    ensures { [#"/Users/xavier/Code/cdsat/src/trail.rs" 67 9 67 14] result = self }
    
end
module Alloc_Boxed_Impl12
  type t
  type a
end
module Core_Clone_Clone_CloneFrom_Interface
  type self
  use prelude.Prelude
  val clone_from [@cfg:stackify] (self : borrowed self) (source : self) : ()
    requires {false}
    
end
module Core_Clone_Clone_Clone_Interface
  type self
  use prelude.Prelude
  val clone' [@cfg:stackify] (self : self) : self
    ensures { result = self }
    
end
module Cdsat_Trail_Impl25
  use Type
  clone Core_Clone_Clone_CloneFrom_Interface as CloneFrom0 with type self = Type.cdsat_trail_value
  clone Cdsat_Trail_Impl25_Clone_Interface as Clone0
  clone Core_Clone_Clone_Clone_Interface as Clone1 with type self = Type.cdsat_trail_value, val clone' = Clone0.clone'
end
module Core_Clone_Impls_Impl5
  
end
module Cdsat_Trail_Impl17
  use Type
  clone Core_Clone_Clone_CloneFrom_Interface as CloneFrom0 with type self = Type.cdsat_trail_sort
  clone Cdsat_Trail_Impl17_Clone_Interface as Clone0
  clone Core_Clone_Clone_Clone_Interface as Clone1 with type self = Type.cdsat_trail_sort, val clone' = Clone0.clone'
end
module Cdsat_Trail_Impl21_Clone_Interface
  use prelude.Prelude
  use Type
  val clone' [@cfg:stackify] (self : Type.cdsat_trail_term) : Type.cdsat_trail_term
    ensures { [#"/Users/xavier/Code/cdsat/src/trail.rs" 84 9 84 14] result = self }
    
end
module Cdsat_Trail_Impl13_Clone_Interface
  use prelude.Prelude
  use Type
  val clone' [@cfg:stackify] (self : Type.cdsat_trail_reason) : Type.cdsat_trail_reason
    ensures { [#"/Users/xavier/Code/cdsat/src/trail.rs" 39 9 39 14] result = self }
    
end
module Cdsat_Trail_Impl21
  use Type
  clone Core_Clone_Clone_CloneFrom_Interface as CloneFrom0 with type self = Type.cdsat_trail_term
  clone Cdsat_Trail_Impl21_Clone_Interface as Clone0
  clone Core_Clone_Clone_Clone_Interface as Clone1 with type self = Type.cdsat_trail_term, val clone' = Clone0.clone'
end
module Cdsat_Trail_Impl13
  use Type
  clone Core_Clone_Clone_CloneFrom_Interface as CloneFrom0 with type self = Type.cdsat_trail_reason
  clone Cdsat_Trail_Impl13_Clone_Interface as Clone0
  clone Core_Clone_Clone_Clone_Interface as Clone1 with type self = Type.cdsat_trail_reason, val clone' = Clone0.clone'
end
module Cdsat_Trail_Impl9_Clone_Interface
  use prelude.Prelude
  use Type
  val clone' [@cfg:stackify] (self : Type.cdsat_trail_assignment) : Type.cdsat_trail_assignment
    ensures { [#"/Users/xavier/Code/cdsat/src/trail.rs" 9 9 9 14] result = self }
    
end
module Alloc_Vec_Impl0_New_Interface
  type t
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = t, type a = Type.alloc_alloc_global,
  axiom .
  val new [@cfg:stackify] (_ : ()) : Type.alloc_vec_vec t (Type.alloc_alloc_global)
    ensures { Seq.length (Model0.model result) = 0 }
    
end
module Alloc_Vec_Impl1_Push_Interface
  type t
  type a
  use prelude.Prelude
  use seq.Seq
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = t, type a = a, axiom .
  val push [@cfg:stackify] (self : borrowed (Type.alloc_vec_vec t a)) (value : t) : ()
    ensures { Model0.model ( ^ self) = Seq.snoc (Model0.model ( * self)) value }
    
end
module Cdsat_Trail_Impl9
  use Type
  clone Core_Clone_Clone_CloneFrom_Interface as CloneFrom0 with type self = Type.cdsat_trail_assignment
  clone Cdsat_Trail_Impl9_Clone_Interface as Clone0
  clone Core_Clone_Clone_Clone_Interface as Clone1 with type self = Type.cdsat_trail_assignment,
  val clone' = Clone0.clone'
end
module CreusotContracts_Std1_Vec_Impl3
  type t
end
module CreusotContracts_Logic_Resolve_Impl1
  type t
end
module Cdsat_Trail_Impl6_Restrict_Interface
  use prelude.Prelude
  use mach.int.UInt64
  use mach.int.Int
  use Type
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_SatisfiedBy_Interface as SatisfiedBy0
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_LevelOf_Interface as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_Contains_Interface as Contains0 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_Invariant_Interface as Invariant1
  clone Cdsat_Theory_Impl4_Restrict_Interface as Restrict0 with predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  function Len0.len = Len0.len, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, axiom .
  clone Cdsat_Trail_Impl6_Invariant_Interface as Invariant0
  val restrict [@cfg:stackify] (self : borrowed (Type.cdsat_trail_trail)) (level : usize) : ()
    requires {[#"/Users/xavier/Code/cdsat/src/trail.rs" 350 15 350 31] Invariant0.invariant' ( * self)}
    requires {[#"/Users/xavier/Code/cdsat/src/trail.rs" 352 15 352 36] UInt64.to_int level <= UInt64.to_int (Type.cdsat_trail_trail_Trail_level ( * self))}
    ensures { [#"/Users/xavier/Code/cdsat/src/trail.rs" 351 14 351 33] Invariant0.invariant' ( ^ self) }
    ensures { [#"/Users/xavier/Code/cdsat/src/trail.rs" 353 14 353 59] Type.cdsat_trail_trail_Trail_ghost ( ^ self) = Restrict0.restrict (Type.cdsat_trail_trail_Trail_ghost ( * self)) (UInt64.to_int level) }
    
end
module Cdsat_Concrete_Impl3_IntoVec_Interface
  use Type
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  val into_vec [@cfg:stackify] (self : Type.cdsat_concrete_conflictheap) : Type.alloc_vec_vec usize (Type.alloc_alloc_global)
    
end
module Cdsat_Trail_Impl5_Negate_Interface
  use prelude.Prelude
  use Type
  clone Cdsat_Trail_Impl4_ModelTy as ModelTy0
  clone Cdsat_Theory_Impl1_IsBool_Interface as IsBool0
  clone Cdsat_Theory_Impl1_Negate_Interface as Negate0 with predicate IsBool0.is_bool = IsBool0.is_bool, axiom .
  clone Cdsat_Trail_Impl4_Model_Interface as Model1
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.cdsat_trail_value,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val negate [@cfg:stackify] (self : Type.cdsat_trail_value) : Type.cdsat_trail_value
    requires {[#"/Users/xavier/Code/cdsat/src/trail.rs" 147 15 147 32] IsBool0.is_bool (Model0.model self)}
    ensures { [#"/Users/xavier/Code/cdsat/src/trail.rs" 148 14 148 41] Model1.model result = Negate0.negate (Model0.model self) }
    
end
module Cdsat_Trail_Impl6_AddJustified_Interface
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  clone Cdsat_Trail_Impl6_Invariant_Interface as Invariant0
  val add_justified [@cfg:stackify] (self : borrowed (Type.cdsat_trail_trail)) (into_vec : Type.alloc_vec_vec usize (Type.alloc_alloc_global)) (term : Type.cdsat_trail_term) (val' : Type.cdsat_trail_value) : ()
    requires {[#"/Users/xavier/Code/cdsat/src/trail.rs" 339 4 339 40] Invariant0.invariant' ( * self)}
    ensures { [#"/Users/xavier/Code/cdsat/src/trail.rs" 339 4 339 40] Invariant0.invariant' ( ^ self) }
    
end
module Cdsat_Trail_Impl8_FirstOrder_Interface
  use prelude.Prelude
  use Type
  clone Cdsat_Theory_Impl1_IsBool_Interface as IsBool0
  clone Cdsat_Trail_Impl4_Model_Interface as Model0
  val first_order [@cfg:stackify] (self : Type.cdsat_trail_assignment) : bool
    ensures { [#"/Users/xavier/Code/cdsat/src/trail.rs" 430 14 430 45] result <> IsBool0.is_bool (Model0.model (Type.cdsat_trail_assignment_Assignment_val self)) }
    
end
module CreusotContracts_Std1_Slice_Impl4_Model_Interface
  type t
  use Type
  use seq.Seq
  function model (self : Type.core_slice_iter_iter t) : Seq.seq t
end
module CreusotContracts_Std1_Slice_Impl4_Model
  type t
  use Type
  use seq.Seq
  function model (self : Type.core_slice_iter_iter t) : Seq.seq t
end
module Core_Slice_Impl0_Iter_Interface
  type t
  use prelude.Prelude
  use seq.Seq
  use Type
  clone CreusotContracts_Std1_Slice_Impl0_ModelTy as ModelTy0 with type t = t
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model1 with type t = seq t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Std1_Slice_Impl4_Model_Interface as Model0 with type t = t
  val iter [@cfg:stackify] (self : seq t) : Type.core_slice_iter_iter t
    ensures { Model0.model result = Model1.model self }
    
end
module Core_Iter_Traits_Collect_Impl0_IntoIter_Interface
  type i
  val into_iter [@cfg:stackify] (self : i) : i
    ensures { result = self }
    
end
module Core_Slice_Iter_Impl173_Item
  type t
  use prelude.Prelude
  type item  =
    t
end
module Core_Slice_Iter_Impl173_Next_Interface
  type t
  use Type
  use prelude.Prelude
  use seq.Seq
  clone Core_Slice_Iter_Impl173_Item as Item0 with type t = t
  clone CreusotContracts_Std1_Iter_IteratorSpec_Produces_Interface as Produces0 with type self = Type.core_slice_iter_iter t,
  type Item0.item = Item0.item
  clone CreusotContracts_Std1_Iter_IteratorSpec_Completed_Interface as Completed0 with type self = Type.core_slice_iter_iter t
  val next [@cfg:stackify] (self : borrowed (Type.core_slice_iter_iter t)) : Type.core_option_option t
    ensures { match (result) with
      | Type.Core_Option_Option_None -> Completed0.completed ( * self)
      | Type.Core_Option_Option_Some v -> Produces0.produces ( * self) (Seq.singleton v) ( ^ self) /\ not Completed0.completed ( * self)
      end }
    
end
module Cdsat_Trail_Impl6_AddDecision_Interface
  use prelude.Prelude
  use Type
  clone Cdsat_Theory_Impl4_Unsat_Interface as Unsat0
  clone Cdsat_Theory_Impl4_Impls_Interface as Impls0 with predicate Unsat0.unsat = Unsat0.unsat, axiom .
  clone Cdsat_Theory_Impl4_Acceptable_Interface as Acceptable0
  clone Cdsat_Trail_Impl4_Model_Interface as Model1
  clone Cdsat_Trail_Impl3_Model_Interface as Model0
  clone Cdsat_Trail_Impl6_Invariant_Interface as Invariant0
  val add_decision [@cfg:stackify] (self : borrowed (Type.cdsat_trail_trail)) (term : Type.cdsat_trail_term) (val' : Type.cdsat_trail_value) : ()
    requires {[#"/Users/xavier/Code/cdsat/src/trail.rs" 288 15 288 31] Invariant0.invariant' ( * self)}
    requires {[#"/Users/xavier/Code/cdsat/src/trail.rs" 290 4 290 51] Acceptable0.acceptable (Type.cdsat_trail_trail_Trail_ghost ( * self)) (Model0.model term) (Model1.model val')}
    ensures { [#"/Users/xavier/Code/cdsat/src/trail.rs" 289 14 289 33] Invariant0.invariant' ( ^ self) }
    ensures { [#"/Users/xavier/Code/cdsat/src/trail.rs" 291 4 291 48] Impls0.impls (Type.cdsat_trail_trail_Trail_ghost ( * self)) (Type.cdsat_trail_trail_Trail_ghost ( ^ self)) }
    
end
module Alloc_Vec_Impl19
  type t
  type a
end
module Alloc_Vec_IntoIter_Impl5
  type t
  type a
end
module Alloc_Vec_Impl10
  type t
  type a
end
module Core_Iter_Traits_Collect_Impl0
  type i
end
module Core_Slice_Iter_Impl173
  type t
end
module CreusotContracts_Std1_Vec_Impl1_Completed_Interface
  type t
  type a
  use Type
  predicate completed (self : Type.alloc_vec_intoiter_intoiter t a)
end
module CreusotContracts_Std1_Vec_Impl1_Completed
  type t
  type a
  use Type
  use seq.Seq
  clone CreusotContracts_Std1_Vec_Impl2_Model_Interface as Model0 with type t = t, type a = a
  predicate completed (self : Type.alloc_vec_intoiter_intoiter t a) =
    Model0.model self = Seq.empty 
end
module CreusotContracts_Logic_Model_Impl1
  type t
end
module CreusotContracts_Std1_Slice_Impl4
  type t
end
module CreusotContracts_Std1_Slice_Impl5_Completed_Interface
  type t
  use Type
  predicate completed (self : Type.core_slice_iter_iter t)
end
module CreusotContracts_Std1_Slice_Impl5_Completed
  type t
  use Type
  use seq.Seq
  clone CreusotContracts_Std1_Slice_Impl4_Model_Interface as Model0 with type t = t
  predicate completed (self : Type.core_slice_iter_iter t) =
    Model0.model self = Seq.empty 
end
module CreusotContracts_Std1_Slice_Impl5
  type t
end
module CreusotContracts_Std1_Slice_Impl5_Produces_Interface
  type t
  use Type
  use seq.Seq
  use prelude.Prelude
  predicate produces (self : Type.core_slice_iter_iter t) (visited : Seq.seq t) (rhs : Type.core_slice_iter_iter t)
end
module CreusotContracts_Std1_Slice_Impl5_Produces
  type t
  use Type
  use seq.Seq
  use prelude.Prelude
  use mach.int.Int
  use seq_ext.SeqExt
  use mach.int.Int32
  clone CreusotContracts_Std1_Slice_Impl4_Model_Interface as Model0 with type t = t
  predicate produces (self : Type.core_slice_iter_iter t) (visited : Seq.seq t) (rhs : Type.core_slice_iter_iter t) =
    Seq.length (Model0.model self) = Seq.length visited + Seq.length (Model0.model rhs) /\ Seq.(==) (SeqExt.subsequence (Model0.model self) (Seq.length visited) (Seq.length (Model0.model self))) (Model0.model rhs) /\ (forall i : (int) . 0 <= i /\ i < Seq.length visited -> Seq.get (Model0.model self) i = Seq.get visited i)
end
module CreusotContracts_Std1_Slice_Impl5_ProducesRefl_Interface
  type t
  use seq.Seq
  use Type
  clone CreusotContracts_Std1_Slice_Impl5_Produces_Interface as Produces0 with type t = t
  function produces_refl (a : Type.core_slice_iter_iter t) : ()
end
module CreusotContracts_Std1_Slice_Impl5_ProducesRefl
  type t
  use seq.Seq
  use Type
  clone CreusotContracts_Std1_Slice_Impl5_Produces_Interface as Produces0 with type t = t
  function produces_refl (a : Type.core_slice_iter_iter t) : () =
    ()
  axiom produces_refl_spec : forall a : Type.core_slice_iter_iter t . Produces0.produces a (Seq.empty ) a
end
module CreusotContracts_Std1_Slice_Impl5_ProducesTrans_Interface
  type t
  use seq.Seq
  use Type
  use prelude.Prelude
  clone CreusotContracts_Std1_Slice_Impl5_Produces_Interface as Produces0 with type t = t
  function produces_trans (a : Type.core_slice_iter_iter t) (ab : Seq.seq t) (b : Type.core_slice_iter_iter t) (bc : Seq.seq t) (c : Type.core_slice_iter_iter t) : ()
    
end
module CreusotContracts_Std1_Slice_Impl5_ProducesTrans
  type t
  use seq.Seq
  use Type
  use prelude.Prelude
  clone CreusotContracts_Std1_Slice_Impl5_Produces_Interface as Produces0 with type t = t
  function produces_trans (a : Type.core_slice_iter_iter t) (ab : Seq.seq t) (b : Type.core_slice_iter_iter t) (bc : Seq.seq t) (c : Type.core_slice_iter_iter t) : ()
    
   =
    ()
  axiom produces_trans_spec : forall a : Type.core_slice_iter_iter t, ab : Seq.seq t, b : Type.core_slice_iter_iter t, bc : Seq.seq t, c : Type.core_slice_iter_iter t . Produces0.produces a ab b -> Produces0.produces b bc c -> Produces0.produces a (Seq.(++) ab bc) c
end
module Cdsat_Concrete_Impl0_ResolveConflict_Interface
  use prelude.Prelude
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  clone Cdsat_Theory_Impl4_Unsat_Interface as Unsat0
  clone Cdsat_Trail_Impl8_TermValue_Interface as TermValue0
  clone CreusotContracts_Logic_Fset_Impl0_Contains_Interface as Contains0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_Impls_Interface as Impls0 with predicate Unsat0.unsat = Unsat0.unsat, axiom .
  clone Cdsat_Theory_Impl3_SatisfySet_Interface as SatisfySet0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.cdsat_trail_assignment,
  type a = Type.alloc_alloc_global, axiom .
  clone Cdsat_Trail_Impl6_AbstractJustification_Interface as AbstractJustification0 with function Model0.model = Model1.model,
  predicate Contains0.contains = Contains0.contains, function TermValue0.term_value = TermValue0.term_value, axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = usize, type a = Type.alloc_alloc_global,
  axiom .
  clone Cdsat_Trail_Impl6_Invariant_Interface as Invariant0
  val resolve_conflict [@cfg:stackify] (self : borrowed (Type.cdsat_concrete_solver)) (trail : borrowed (Type.cdsat_trail_trail)) (conflict : Type.alloc_vec_vec usize (Type.alloc_alloc_global)) : ()
    requires {[#"/Users/xavier/Code/cdsat/src/concrete.rs" 107 4 107 41] Invariant0.invariant' ( * trail)}
    requires {[#"/Users/xavier/Code/cdsat/src/concrete.rs" 109 4 109 111] forall i : (int) . 0 <= i /\ i < Seq.length (Model0.model conflict) -> UInt64.to_int (Seq.get (Model0.model conflict) i) < Seq.length (Model1.model (Type.cdsat_trail_trail_Trail_assignments ( * trail)))}
    requires {[#"/Users/xavier/Code/cdsat/src/concrete.rs" 110 15 110 36] Seq.length (Model0.model conflict) > 0}
    requires {[#"/Users/xavier/Code/cdsat/src/concrete.rs" 111 4 114 7] let conflict = AbstractJustification0.abstract_justification ( * trail) (Model0.model conflict) in forall m : (Type.cdsat_theory_model) . SatisfySet0.satisfy_set m conflict -> false}
    ensures { [#"/Users/xavier/Code/cdsat/src/concrete.rs" 107 4 107 41] Invariant0.invariant' ( ^ trail) }
    ensures { [#"/Users/xavier/Code/cdsat/src/concrete.rs" 108 4 108 50] Impls0.impls (Type.cdsat_trail_trail_Trail_ghost ( * trail)) (Type.cdsat_trail_trail_Trail_ghost ( ^ trail)) }
    
end
module Cdsat_Concrete_Impl0_Solver_Interface
  use prelude.Prelude
  use Type
  clone Cdsat_Theory_Impl4_Unsat_Interface as Unsat1
  clone Cdsat_Trail_Impl6_Unsat_Interface as Unsat0
  clone Cdsat_Theory_Impl4_Impls_Interface as Impls0 with predicate Unsat0.unsat = Unsat1.unsat, axiom .
  clone Cdsat_Trail_Impl6_Invariant_Interface as Invariant0
  val solver [@cfg:stackify] (self : borrowed (Type.cdsat_concrete_solver)) (trail : borrowed (Type.cdsat_trail_trail)) : Type.cdsat_concrete_answer
    requires {[#"/Users/xavier/Code/cdsat/src/concrete.rs" 27 15 27 32] Invariant0.invariant' ( * trail)}
    ensures { [#"/Users/xavier/Code/cdsat/src/concrete.rs" 28 14 28 34] Invariant0.invariant' ( ^ trail) }
    ensures { [#"/Users/xavier/Code/cdsat/src/concrete.rs" 29 4 29 50] Impls0.impls (Type.cdsat_trail_trail_Trail_ghost ( * trail)) (Type.cdsat_trail_trail_Trail_ghost ( ^ trail)) }
    ensures { [#"/Users/xavier/Code/cdsat/src/concrete.rs" 30 14 34 5] match (result) with
      | Type.Cdsat_Concrete_Answer_Unsat -> Unsat0.unsat ( * trail)
      | Type.Cdsat_Concrete_Answer_Sat -> true
      | Type.Cdsat_Concrete_Answer_Unknown -> true
      end }
    
end
module Cdsat_Concrete_Impl1_Eval_Interface
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  val eval [@cfg:stackify] (self : borrowed (Type.cdsat_concrete_booltheory)) (tl : Type.cdsat_trail_trail) (tm : Type.cdsat_trail_term) : Type.core_result_result (Type.alloc_vec_vec usize (Type.alloc_alloc_global), Type.cdsat_trail_value) (Type.alloc_vec_vec (Type.cdsat_trail_term) (Type.alloc_alloc_global))
    
end
module Cdsat_Trail_Impl0_ModelTy
  use Type
  type modelTy  =
    Type.cdsat_trail_assignmentmodel
end
module Cdsat_Trail_Impl0_Model_Interface
  use Type
  function model (self : Type.cdsat_trail_assignment) : Type.cdsat_trail_assignmentmodel
end
module Cdsat_Trail_Impl0_Model
  use Type
  use mach.int.UInt64
  clone Cdsat_Trail_Impl1_Model_Interface as Model2
  clone Cdsat_Trail_Impl4_Model_Interface as Model1
  clone Cdsat_Trail_Impl3_Model_Interface as Model0
  function model [#"/Users/xavier/Code/cdsat/src/trail.rs" 25 4 25 35] (self : Type.cdsat_trail_assignment) : Type.cdsat_trail_assignmentmodel
    
   =
    [#"/Users/xavier/Code/cdsat/src/trail.rs" 26 20 26 113] Type.Cdsat_Trail_AssignmentModel (Model0.model (Type.cdsat_trail_assignment_Assignment_term self)) (Model1.model (Type.cdsat_trail_assignment_Assignment_val self)) (Model2.model (Type.cdsat_trail_assignment_Assignment_reason self)) (UInt64.to_int (Type.cdsat_trail_assignment_Assignment_level self))
end
module Cdsat_Trail_Impl0
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = usize, type a = Type.alloc_alloc_global, axiom .
  clone Cdsat_Trail_Impl2_Model as Model5
  clone Cdsat_Trail_Impl1_Model as Model4 with function Model0.model = Model6.model
  clone Cdsat_Trail_Impl4_Model as Model3
  clone Cdsat_Trail_Impl3_Model as Model2 with function Model0.model = Model5.model,
  function Model1.model = Model3.model
  clone Cdsat_Trail_Impl0_ModelTy as ModelTy0
  clone Cdsat_Trail_Impl0_Model as Model0 with function Model0.model = Model2.model,
  function Model1.model = Model3.model, function Model2.model = Model4.model
  clone CreusotContracts_Logic_Model_Model_Model_Interface as Model1 with type self = Type.cdsat_trail_assignment,
  function model = Model0.model, type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy1 with type self = Type.cdsat_trail_assignment,
  type modelTy = ModelTy0.modelTy
end
module CreusotContracts_Logic_Model_Impl2_ModelTy
  type t
  type a
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy0 with type self = t
  type modelTy  =
    ModelTy0.modelTy
end
module Alloc_Boxed_Impl14_Eq_Interface
  type t
  type a
  use prelude.Prelude
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy2 with type self = t
  clone CreusotContracts_Logic_Model_Impl2_ModelTy as ModelTy1 with type t = t, type a = a,
  type ModelTy0.modelTy = ModelTy2.modelTy
  clone CreusotContracts_Logic_Model_Impl0_ModelTy as ModelTy0 with type t = t, type ModelTy0.modelTy = ModelTy1.modelTy
  clone CreusotContracts_Logic_Model_Model_Model_Interface as Model0 with type self = t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val eq [@cfg:stackify] (self : t) (other : t) : bool
    ensures { result = (Model0.model self = Model0.model other) }
    
end
module CreusotContracts_Logic_Int_Impl16_ModelTy
  use mach.int.Int
  type modelTy  =
    int
end
module Core_Cmp_Impls_Impl25_Eq_Interface
  use prelude.Prelude
  use mach.int.Int
  use mach.int.UInt64
  clone CreusotContracts_Logic_Int_Impl16_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = uint64,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val eq [@cfg:stackify] (self : uint64) (other : uint64) : bool
    ensures { result = (Model0.model self = Model0.model other) }
    
end
module CreusotContracts_Logic_Model_Impl5_ModelTy
  type modelTy  =
    bool
end
module Core_Cmp_Impls_Impl19_Eq_Interface
  use prelude.Prelude
  clone CreusotContracts_Logic_Model_Impl5_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = bool,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val eq [@cfg:stackify] (self : bool) (other : bool) : bool
    ensures { result = (Model0.model self = Model0.model other) }
    
end
module Core_Cmp_Impls_Impl25
  
end
module Core_Cmp_Impls_Impl19
  
end
module CreusotContracts_Logic_Int_Impl16
  
end
module CreusotContracts_Logic_Model_Impl5
  
end
module CreusotContracts_Logic_Int_Impl16_Model_Interface
  use mach.int.Int
  use mach.int.UInt64
  function model (self : uint64) : int
end
module CreusotContracts_Logic_Int_Impl16_Model
  use mach.int.Int
  use mach.int.UInt64
  function model (self : uint64) : int =
    UInt64.to_int self
end
module CreusotContracts_Logic_Model_Impl5_Model_Interface
  function model (self : bool) : bool
end
module CreusotContracts_Logic_Model_Impl5_Model
  function model (self : bool) : bool =
    self
end
module Cdsat_Trail_Impl26_Eq_Interface
  use prelude.Prelude
  use Type
  clone Cdsat_Trail_Impl4_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.cdsat_trail_value,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val eq [@cfg:stackify] (self : Type.cdsat_trail_value) (rhs : Type.cdsat_trail_value) : bool
    ensures { [#"/Users/xavier/Code/cdsat/src/trail.rs" 111 16 111 25] result = (Model0.model self = Model0.model rhs) }
    
end
module Cdsat_Trail_Impl18_Eq_Interface
  use prelude.Prelude
  use Type
  clone Cdsat_Trail_Impl2_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.cdsat_trail_sort,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val eq [@cfg:stackify] (self : Type.cdsat_trail_sort) (rhs : Type.cdsat_trail_sort) : bool
    ensures { [#"/Users/xavier/Code/cdsat/src/trail.rs" 67 16 67 25] result = (Model0.model self = Model0.model rhs) }
    
end
module Core_Cmp_Impls_Impl21_Eq_Interface
  use prelude.Prelude
  use mach.int.Int
  use mach.int.UInt64
  clone CreusotContracts_Logic_Int_Impl20_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = usize,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val eq [@cfg:stackify] (self : usize) (other : usize) : bool
    ensures { result = (Model0.model self = Model0.model other) }
    
end
module Alloc_Boxed_Impl14
  type t
  type a
end
module Cdsat_Trail_Impl26
  use Type
  clone Cdsat_Trail_Impl4_Model as Model1
  clone Cdsat_Trail_Impl4_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = Type.cdsat_trail_value,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model1.model
  clone Core_Cmp_PartialEq_Ne_Interface as Ne0 with type self = Type.cdsat_trail_value,
  type rhs = Type.cdsat_trail_value
  clone Cdsat_Trail_Impl26_Eq_Interface as Eq0 with function Model0.model = Model0.model
  clone Core_Cmp_PartialEq_Eq_Interface as Eq1 with type self = Type.cdsat_trail_value,
  type rhs = Type.cdsat_trail_value, val eq = Eq0.eq, function Model0.model = Model0.model,
  function Model1.model = Model0.model, type ModelTy0.modelTy = ModelTy0.modelTy
end
module Cdsat_Trail_Impl18
  use Type
  clone Cdsat_Trail_Impl2_Model as Model1
  clone Cdsat_Trail_Impl2_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = Type.cdsat_trail_sort,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model1.model
  clone Core_Cmp_PartialEq_Ne_Interface as Ne0 with type self = Type.cdsat_trail_sort, type rhs = Type.cdsat_trail_sort
  clone Cdsat_Trail_Impl18_Eq_Interface as Eq0 with function Model0.model = Model0.model
  clone Core_Cmp_PartialEq_Eq_Interface as Eq1 with type self = Type.cdsat_trail_sort, type rhs = Type.cdsat_trail_sort,
  val eq = Eq0.eq, function Model0.model = Model0.model, function Model1.model = Model0.model,
  type ModelTy0.modelTy = ModelTy0.modelTy
end
module Core_Cmp_Impls_Impl21
  
end
module CreusotContracts_Logic_Model_Impl2
  type t
  type a
end
module CreusotContracts_Logic_Model_Impl2_Model_Interface
  type t
  type a
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy0 with type self = t
  function model (self : t) : ModelTy0.modelTy
end
module CreusotContracts_Logic_Model_Impl2_Model
  type t
  type a
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy0 with type self = t
  clone CreusotContracts_Logic_Model_Model_Model_Interface as Model0 with type self = t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  function model (self : t) : ModelTy0.modelTy =
    Model0.model self
end
module Cdsat_Trail_Impl22_Eq_Interface
  use prelude.Prelude
  use Type
  clone Cdsat_Trail_Impl3_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.cdsat_trail_term,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val eq [@cfg:stackify] (self : Type.cdsat_trail_term) (rhs : Type.cdsat_trail_term) : bool
    ensures { [#"/Users/xavier/Code/cdsat/src/trail.rs" 84 16 84 25] result = (Model0.model self = Model0.model rhs) }
    
end
module Cdsat_Trail_Impl22
  use Type
  clone Cdsat_Trail_Impl4_Model as Model3
  clone Cdsat_Trail_Impl2_Model as Model2
  clone Cdsat_Trail_Impl3_Model as Model1 with function Model0.model = Model2.model,
  function Model1.model = Model3.model
  clone Cdsat_Trail_Impl3_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = Type.cdsat_trail_term,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model1.model
  clone Core_Cmp_PartialEq_Ne_Interface as Ne0 with type self = Type.cdsat_trail_term, type rhs = Type.cdsat_trail_term
  clone Cdsat_Trail_Impl22_Eq_Interface as Eq0 with function Model0.model = Model0.model
  clone Core_Cmp_PartialEq_Eq_Interface as Eq1 with type self = Type.cdsat_trail_term, type rhs = Type.cdsat_trail_term,
  val eq = Eq0.eq, function Model0.model = Model0.model, function Model1.model = Model0.model,
  type ModelTy0.modelTy = ModelTy0.modelTy
end
module Cdsat_Trail_Impl10_Eq_Interface
  use prelude.Prelude
  use Type
  clone Cdsat_Trail_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.cdsat_trail_assignment,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val eq [@cfg:stackify] (self : Type.cdsat_trail_assignment) (rhs : Type.cdsat_trail_assignment) : bool
    ensures { [#"/Users/xavier/Code/cdsat/src/trail.rs" 9 16 9 25] result = (Model0.model self = Model0.model rhs) }
    
end
module Cdsat_Trail_Impl12_AssertReceiverIsTotalEq_Interface
  use prelude.Prelude
  use Type
  val assert_receiver_is_total_eq [@cfg:stackify] (self : Type.cdsat_trail_assignment) : ()
end
module Cdsat_Trail_Impl16_AssertReceiverIsTotalEq_Interface
  use prelude.Prelude
  use Type
  val assert_receiver_is_total_eq [@cfg:stackify] (self : Type.cdsat_trail_reason) : ()
end
module Cdsat_Trail_Impl20_AssertReceiverIsTotalEq_Interface
  use prelude.Prelude
  use Type
  val assert_receiver_is_total_eq [@cfg:stackify] (self : Type.cdsat_trail_sort) : ()
end
module Cdsat_Trail_Impl24_AssertReceiverIsTotalEq_Interface
  use prelude.Prelude
  use Type
  val assert_receiver_is_total_eq [@cfg:stackify] (self : Type.cdsat_trail_term) : ()
end
module Cdsat_Trail_Impl28_AssertReceiverIsTotalEq_Interface
  use prelude.Prelude
  use Type
  val assert_receiver_is_total_eq [@cfg:stackify] (self : Type.cdsat_trail_value) : ()
end
module Cdsat_Trail_Impl5_Bool_Interface
  use prelude.Prelude
  use Type
  clone Cdsat_Trail_Impl4_ModelTy as ModelTy0
  clone Cdsat_Theory_Impl1_IsBool_Interface as IsBool0
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.cdsat_trail_value,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val bool [@cfg:stackify] (self : Type.cdsat_trail_value) : bool
    requires {[#"/Users/xavier/Code/cdsat/src/trail.rs" 131 15 131 32] IsBool0.is_bool (Model0.model self)}
    
end
module Cdsat_Trail_Impl6_New_Interface
  use Type
  clone Cdsat_Theory_Impl4_Sound_Interface as Sound0
  clone Cdsat_Trail_Impl6_Invariant_Interface as Invariant0
  val new [@cfg:stackify] (inputs : Type.alloc_vec_vec (Type.cdsat_trail_term, Type.cdsat_trail_value) (Type.alloc_alloc_global)) : Type.cdsat_trail_trail
    ensures { [#"/Users/xavier/Code/cdsat/src/trail.rs" 169 14 169 32] Invariant0.invariant' result }
    ensures { [#"/Users/xavier/Code/cdsat/src/trail.rs" 170 4 170 36] Sound0.sound (Type.cdsat_trail_trail_Trail_ghost result) }
    
end
module Cdsat_Theory_Impl4_Sat_Interface
  use Type
  predicate sat (self : Type.cdsat_theory_trail)
end
module Cdsat_Theory_Impl4_Sat
  use Type
  clone Cdsat_Theory_Impl4_SatisfiedBy_Interface as SatisfiedBy0
  predicate sat [#"/Users/xavier/Code/cdsat/src/theory.rs" 442 4 442 28] (self : Type.cdsat_theory_trail) =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 443 8 443 56] exists m : (Type.cdsat_theory_model) . SatisfiedBy0.satisfied_by self m
end
module Cdsat_Trail_Impl6_Sat_Interface
  use Type
  predicate sat (self : Type.cdsat_trail_trail)
end
module Cdsat_Trail_Impl6_Sat
  use Type
  clone Cdsat_Theory_Impl4_Sat_Interface as Sat0
  predicate sat [#"/Users/xavier/Code/cdsat/src/trail.rs" 200 4 200 28] (self : Type.cdsat_trail_trail) =
    [#"/Users/xavier/Code/cdsat/src/trail.rs" 199 4 199 16] Sat0.sat (Type.cdsat_trail_trail_Trail_ghost self)
end
module Cdsat_Trail_Impl6_RelateBetween_Interface
  use Type
  use mach.int.Int
  predicate relate_between (self : Type.cdsat_trail_trail) (low : int) (up : int)
end
module Cdsat_Trail_Impl6_RelateBetween
  use Type
  use mach.int.Int
  use seq.Seq
  use mach.int.UInt64
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone Cdsat_Theory_Impl4_LevelOf_Interface as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_Contains_Interface as Contains0 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Trail_Impl8_TermValue_Interface as TermValue0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.cdsat_trail_assignment,
  type a = Type.alloc_alloc_global, axiom .
  predicate relate_between [#"/Users/xavier/Code/cdsat/src/trail.rs" 235 4 235 54] (self : Type.cdsat_trail_trail) (low : int) (up : int)
    
   =
    [#"/Users/xavier/Code/cdsat/src/trail.rs" 237 12 238 142] (forall i : (int) . low <= i /\ i < up -> Contains0.contains (Type.cdsat_trail_trail_Trail_ghost self) (TermValue0.term_value (Seq.get (Model0.model (Type.cdsat_trail_trail_Trail_assignments self)) i))) /\ (forall i : (int) . low <= i /\ i < up -> LevelOf0.level_of (Type.cdsat_trail_trail_Trail_ghost self) (TermValue0.term_value (Seq.get (Model0.model (Type.cdsat_trail_trail_Trail_assignments self)) i)) = UInt64.to_int (Type.cdsat_trail_assignment_Assignment_level (Seq.get (Model0.model (Type.cdsat_trail_trail_Trail_assignments self)) i)))
end
module Cdsat_Trail_Impl6_AbstractAssign_Interface
  use prelude.Prelude
  use Type
  function abstract_assign (self : Type.cdsat_trail_trail) (a : Type.cdsat_trail_assignment) : Type.cdsat_theory_assign
end
module Cdsat_Trail_Impl6_AbstractAssign
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  clone Cdsat_Trail_Impl8_TermValue_Interface as TermValue0
  clone CreusotContracts_Logic_Fset_Impl0_Contains_Interface as Contains0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model3 with type t = Type.cdsat_trail_assignment,
  type a = Type.alloc_alloc_global, axiom .
  clone Cdsat_Trail_Impl6_AbstractJustification_Interface as AbstractJustification0 with function Model0.model = Model3.model,
  predicate Contains0.contains = Contains0.contains, function TermValue0.term_value = TermValue0.term_value, axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = usize, type a = Type.alloc_alloc_global,
  axiom .
  clone Cdsat_Trail_Impl4_Model_Interface as Model1
  clone Cdsat_Trail_Impl3_Model_Interface as Model0
  function abstract_assign [#"/Users/xavier/Code/cdsat/src/trail.rs" 244 4 244 62] (self : Type.cdsat_trail_trail) (a : Type.cdsat_trail_assignment) : Type.cdsat_theory_assign
    
   =
    [#"/Users/xavier/Code/cdsat/src/trail.rs" 245 8 253 9] match (Type.cdsat_trail_assignment_Assignment_reason a) with
      | Type.Cdsat_Trail_Reason_Input -> Type.Cdsat_Theory_Assign_Input (Model0.model (Type.cdsat_trail_assignment_Assignment_term a)) (Model1.model (Type.cdsat_trail_assignment_Assignment_val a))
      | Type.Cdsat_Trail_Reason_Decision -> Type.Cdsat_Theory_Assign_Decision (Model0.model (Type.cdsat_trail_assignment_Assignment_term a)) (Model1.model (Type.cdsat_trail_assignment_Assignment_val a))
      | Type.Cdsat_Trail_Reason_Justified just -> Type.Cdsat_Theory_Assign_Justified (AbstractJustification0.abstract_justification self (Model2.model just)) (Model0.model (Type.cdsat_trail_assignment_Assignment_term a)) (Model1.model (Type.cdsat_trail_assignment_Assignment_val a))
      end
end
module Cdsat_Theory_Impl3_ResolveSound_Interface
  use set.Fset
  use Type
  clone CreusotContracts_Logic_Fset_Impl0_Remove_Interface as Remove0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone CreusotContracts_Logic_Fset_Impl0_Contains_Interface as Contains0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl3_Satisfies_Interface as Satisfies0
  clone Cdsat_Theory_Impl3_SatisfySet_Interface as SatisfySet0
  function resolve_sound (self : Type.cdsat_theory_model) (cflct : Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value)) (just : Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value)) (a : (Type.cdsat_theory_term, Type.cdsat_theory_value)) : ()
    
end
module Cdsat_Theory_Impl3_ResolveSound
  use set.Fset
  use Type
  clone CreusotContracts_Logic_Fset_Impl0_Remove_Interface as Remove0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone CreusotContracts_Logic_Fset_Impl0_Contains_Interface as Contains0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl3_Satisfies_Interface as Satisfies0
  clone Cdsat_Theory_Impl3_SatisfySet_Interface as SatisfySet0
  function resolve_sound [#"/Users/xavier/Code/cdsat/src/theory.rs" 154 4 159 5] (self : Type.cdsat_theory_model) (cflct : Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value)) (just : Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value)) (a : (Type.cdsat_theory_term, Type.cdsat_theory_value)) : ()
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 149 4 149 12] ()
  axiom resolve_sound_spec : forall self : Type.cdsat_theory_model, cflct : Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value), just : Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value), a : (Type.cdsat_theory_term, Type.cdsat_theory_value) . ([#"/Users/xavier/Code/cdsat/src/theory.rs" 150 4 150 61] SatisfySet0.satisfy_set self just -> Satisfies0.satisfies self a) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 151 15 151 39] not SatisfySet0.satisfy_set self cflct) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 152 15 152 32] Contains0.contains cflct a) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 153 14 153 60] not SatisfySet0.satisfy_set self (Fset.union (Remove0.remove cflct a) just))
end
module Cdsat_Theory_Impl3_ResolveSound_Impl
  use set.Fset
  use Type
  clone Cdsat_Theory_Impl1_Sort as Sort0
  clone Cdsat_Theory_Impl0_Sort as Sort1 with function Sort0.sort = Sort0.sort
  clone Cdsat_Theory_Impl3_Invariant as Invariant0 with function Sort0.sort = Sort0.sort
  clone Cdsat_Theory_Impl3_Interp as Interp0 with predicate Invariant0.invariant' = Invariant0.invariant',
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, axiom .
  clone CreusotContracts_Logic_Fset_Impl0_Remove as Remove0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone CreusotContracts_Logic_Fset_Impl0_Contains as Contains0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl3_Satisfies as Satisfies0 with function Interp0.interp = Interp0.interp,
  predicate Invariant0.invariant' = Invariant0.invariant', function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl3_SatisfySet as SatisfySet0 with predicate Contains0.contains = Contains0.contains,
  predicate Satisfies0.satisfies = Satisfies0.satisfies
  let rec ghost function resolve_sound (self : Type.cdsat_theory_model) (cflct : Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value)) (just : Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value)) (a : (Type.cdsat_theory_term, Type.cdsat_theory_value)) : ()
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 150 4 150 61] SatisfySet0.satisfy_set self just -> Satisfies0.satisfies self a}
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 151 15 151 39] not SatisfySet0.satisfy_set self cflct}
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 152 15 152 32] Contains0.contains cflct a}
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 153 14 153 60] not SatisfySet0.satisfy_set self (Fset.union (Remove0.remove cflct a) just) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 149 4 149 12] ()
end
module Cdsat_Theory_Impl5_Decide_Interface
  use Type
  clone Cdsat_Theory_Impl4_Unsat_Interface as Unsat0
  clone Cdsat_Theory_Impl4_Impls_Interface as Impls0 with predicate Unsat0.unsat = Unsat0.unsat, axiom .
  clone Cdsat_Theory_Impl5_Sound_Interface as Sound0
  clone Cdsat_Theory_Impl4_Invariant_Interface as Invariant0
  predicate decide (self : Type.cdsat_theory_normal) (t : Type.cdsat_theory_term) (val' : Type.cdsat_theory_value) (tgt : Type.cdsat_theory_normal)
    
end
module Cdsat_Theory_Impl5_Decide
  use Type
  clone Cdsat_Theory_Impl4_Unsat_Interface as Unsat0
  clone Cdsat_Theory_Impl4_Impls_Interface as Impls0 with predicate Unsat0.unsat = Unsat0.unsat, axiom .
  clone Cdsat_Theory_Impl5_Sound_Interface as Sound0
  clone Cdsat_Theory_Impl4_Invariant_Interface as Invariant0
  use mach.int.Int
  use mach.int.Int32
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_Acceptable_Interface as Acceptable0
  predicate decide [#"/Users/xavier/Code/cdsat/src/theory.rs" 544 4 544 63] (self : Type.cdsat_theory_normal) (t : Type.cdsat_theory_term) (val' : Type.cdsat_theory_value) (tgt : Type.cdsat_theory_normal)
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 538 4 538 16] Acceptable0.acceptable (Type.cdsat_theory_normal_Normal_0 self) t val' /\ Type.cdsat_theory_normal_Normal_0 tgt = Type.Cdsat_Theory_Trail_Assign (Type.Cdsat_Theory_Assign_Decision t val') (Level0.level (Type.cdsat_theory_normal_Normal_0 self) + 1) (Type.cdsat_theory_normal_Normal_0 self)
  axiom decide_spec : forall self : Type.cdsat_theory_normal, t : Type.cdsat_theory_term, val' : Type.cdsat_theory_value, tgt : Type.cdsat_theory_normal . ([#"/Users/xavier/Code/cdsat/src/theory.rs" 539 15 539 35] Invariant0.invariant' (Type.cdsat_theory_normal_Normal_0 self)) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 540 15 540 27] Sound0.sound self) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 543 4 543 46] decide self t val' tgt -> Impls0.impls (Type.cdsat_theory_normal_Normal_0 self) (Type.cdsat_theory_normal_Normal_0 tgt)) && ([#"/Users/xavier/Code/cdsat/src/theory.rs" 542 4 542 38] decide self t val' tgt -> Sound0.sound tgt) && ([#"/Users/xavier/Code/cdsat/src/theory.rs" 541 4 541 46] decide self t val' tgt -> Invariant0.invariant' (Type.cdsat_theory_normal_Normal_0 tgt))
end
module Cdsat_Theory_Impl5_Decide_Impl
  use Type
  use mach.int.Int
  use mach.int.Int32
  clone Cdsat_Theory_Impl1_Sort as Sort1
  clone Cdsat_Theory_Impl0_Sort as Sort0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl3_Invariant as Invariant1 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl3_Interp as Interp0 with predicate Invariant0.invariant' = Invariant1.invariant',
  function Sort0.sort = Sort1.sort, function Sort1.sort = Sort0.sort, axiom .
  clone Cdsat_Theory_Impl3_Satisfies as Satisfies0 with function Interp0.interp = Interp0.interp,
  predicate Invariant0.invariant' = Invariant1.invariant', function Sort0.sort = Sort1.sort,
  function Sort1.sort = Sort0.sort
  clone CreusotContracts_Logic_Fset_Impl0_Contains as Contains1 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl3_SatisfySet as SatisfySet0 with predicate Contains0.contains = Contains1.contains,
  predicate Satisfies0.satisfies = Satisfies0.satisfies
  clone CreusotContracts_Logic_Fset_Impl0_Remove as Remove0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_Len as Len0 with axiom .
  clone Cdsat_Theory_Impl2_Invariant as Invariant2 with function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_InvariantAssign as InvariantAssign0 with predicate Invariant0.invariant' = Invariant2.invariant'
  clone Cdsat_Theory_Impl4_Level as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg as InvariantNonneg0 with function Level0.level = Level0.level,
  function Len0.len = Len0.len
  clone Cdsat_Theory_Impl2_ToPair as ToPair0
  clone Cdsat_Theory_Impl4_Find as Find0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_LevelOf as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_Contains as Contains0 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl1_IsBool as IsBool0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl1_Negate as Negate0 with predicate IsBool0.is_bool = IsBool0.is_bool, axiom .
  clone Cdsat_Theory_Impl4_TrailUnique as TrailUnique0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate Contains0.contains = Contains0.contains, predicate IsBool0.is_bool = IsBool0.is_bool,
  function Negate0.negate = Negate0.negate,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_InvariantContains as InvariantContains0 with predicate Contains0.contains = Contains1.contains,
  predicate Contains1.contains = Contains0.contains,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_SetLevel as SetLevel0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, function Len0.len = Len0.len, function Remove0.remove = Remove0.remove, axiom .
  clone Cdsat_Theory_Impl4_InvariantLevel as InvariantLevel0 with function Level0.level = Level0.level,
  function SetLevel0.set_level = SetLevel0.set_level, function Len0.len = Len0.len,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of
  clone Cdsat_Theory_Impl4_Invariant as Invariant0 with predicate InvariantLevel0.invariant_level = InvariantLevel0.invariant_level,
  predicate InvariantContains0.invariant_contains = InvariantContains0.invariant_contains,
  predicate TrailUnique0.trail_unique = TrailUnique0.trail_unique,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign
  clone Cdsat_Theory_Impl4_CountBounds as CountBounds0 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl2_JustifiedSound as JustifiedSound0 with predicate Invariant0.invariant' = Invariant1.invariant',
  predicate SatisfySet0.satisfy_set = SatisfySet0.satisfy_set, predicate Satisfies0.satisfies = Satisfies0.satisfies
  clone Cdsat_Theory_Impl4_SatisfiedBy as SatisfiedBy0 with predicate Contains0.contains = Contains0.contains,
  predicate Satisfies0.satisfies = Satisfies0.satisfies,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_Restrict as Restrict0 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  function Len0.len = Len0.len, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function CountBounds0.count_bounds = CountBounds0.count_bounds, axiom .
  clone Cdsat_Theory_Impl4_Unsat as Unsat0 with predicate Invariant0.invariant' = Invariant1.invariant',
  function Restrict0.restrict = Restrict0.restrict, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  predicate Invariant1.invariant' = Invariant0.invariant', predicate Contains0.contains = Contains0.contains,
  function LevelOf0.level_of = LevelOf0.level_of, function Level0.level = Level0.level, function Len0.len = Len0.len,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg
  clone Cdsat_Theory_Impl4_Sound as Sound1 with predicate JustifiedSound0.justified_sound = JustifiedSound0.justified_sound
  clone Cdsat_Theory_Impl4_Acceptable as Acceptable0 with predicate Contains0.contains = Contains0.contains,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, predicate IsBool0.is_bool = IsBool0.is_bool,
  function Negate0.negate = Negate0.negate,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign
  clone Cdsat_Theory_Impl4_Impls as Impls0 with predicate Unsat0.unsat = Unsat0.unsat,
  predicate Invariant0.invariant' = Invariant1.invariant', function Restrict0.restrict = Restrict0.restrict,
  predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  predicate Invariant1.invariant' = Invariant0.invariant', predicate Contains0.contains = Contains0.contains,
  function LevelOf0.level_of = LevelOf0.level_of, function Level0.level = Level0.level, function Len0.len = Len0.len,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  axiom .
  clone Cdsat_Theory_Impl5_Sound as Sound0 with predicate Sound0.sound = Sound1.sound
  let rec ghost function decide (self : Type.cdsat_theory_normal) (t : Type.cdsat_theory_term) (val' : Type.cdsat_theory_value) (tgt : Type.cdsat_theory_normal) : bool
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 539 15 539 35] Invariant0.invariant' (Type.cdsat_theory_normal_Normal_0 self)}
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 540 15 540 27] Sound0.sound self}
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 541 4 541 46] result -> Invariant0.invariant' (Type.cdsat_theory_normal_Normal_0 tgt) }
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 542 4 542 38] result -> Sound0.sound tgt }
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 543 4 543 46] result -> Impls0.impls (Type.cdsat_theory_normal_Normal_0 self) (Type.cdsat_theory_normal_Normal_0 tgt) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 538 4 538 16] (let a' = Type.cdsat_theory_normal_Normal_0 self in Acceptable0.acceptable a' t val') && (let b = Type.Cdsat_Theory_Trail_Assign (Type.Cdsat_Theory_Assign_Decision t val') ((let a' = Type.cdsat_theory_normal_Normal_0 self in Level0.level a') + 1) (Type.cdsat_theory_normal_Normal_0 self) in let a = Type.cdsat_theory_normal_Normal_0 tgt in pure {a = b})
end
module Cdsat_Theory_Impl5_Deduce_Interface
  use Type
  use set.Fset
  clone Cdsat_Theory_Impl4_Unsat_Interface as Unsat0
  clone Cdsat_Theory_Impl4_Impls_Interface as Impls0 with predicate Unsat0.unsat = Unsat0.unsat, axiom .
  clone Cdsat_Theory_Impl5_Sound_Interface as Sound0
  clone Cdsat_Theory_Impl4_Invariant_Interface as Invariant0
  predicate deduce (self : Type.cdsat_theory_normal) (just : (Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value), Type.cdsat_theory_term, Type.cdsat_theory_value)) (tgt : Type.cdsat_theory_normal)
    
end
module Cdsat_Theory_Impl5_Deduce
  use Type
  use set.Fset
  clone Cdsat_Theory_Impl4_Unsat_Interface as Unsat0
  clone Cdsat_Theory_Impl4_Impls_Interface as Impls0 with predicate Unsat0.unsat = Unsat0.unsat, axiom .
  clone Cdsat_Theory_Impl5_Sound_Interface as Sound0
  clone Cdsat_Theory_Impl4_Invariant_Interface as Invariant0
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_LevelOf_Interface as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  clone CreusotContracts_Logic_Fset_Impl0_Contains_Interface as Contains0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_SetLevel_Interface as SetLevel0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl3_Satisfies_Interface as Satisfies0
  clone Cdsat_Theory_Impl3_SatisfySet_Interface as SatisfySet0
  clone Cdsat_Theory_Impl4_Contains_Interface as Contains1 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_Acceptable_Interface as Acceptable0
  clone Cdsat_Theory_Impl1_IsBool_Interface as IsBool0
  clone Cdsat_Theory_Impl4_CountBounds_Interface as CountBounds0 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Len0.len = Len0.len, axiom .
  predicate deduce [#"/Users/xavier/Code/cdsat/src/theory.rs" 561 4 561 84] (self : Type.cdsat_theory_normal) (just : (Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value), Type.cdsat_theory_term, Type.cdsat_theory_value)) (tgt : Type.cdsat_theory_normal)
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 562 8 568 11] let _ = CountBounds0.count_bounds (Type.cdsat_theory_normal_Normal_0 self) in IsBool0.is_bool (let (_, _, a) = just in a) /\ Acceptable0.acceptable (Type.cdsat_theory_normal_Normal_0 self) (let (_, a, _) = just in a) (let (_, _, a) = just in a) /\ (forall j : ((Type.cdsat_theory_term, Type.cdsat_theory_value)) . Contains0.contains (let (a, _, _) = just in a) j -> Contains1.contains (Type.cdsat_theory_normal_Normal_0 self) j) /\ (forall m : (Type.cdsat_theory_model) . SatisfySet0.satisfy_set m (let (a, _, _) = just in a) -> Satisfies0.satisfies m (let (_, a, _) = just in a, let (_, _, a) = just in a)) /\ Type.cdsat_theory_normal_Normal_0 tgt = Type.Cdsat_Theory_Trail_Assign (Type.Cdsat_Theory_Assign_Justified (let (a, _, _) = just in a) (let (_, a, _) = just in a) (let (_, _, a) = just in a)) (SetLevel0.set_level (Type.cdsat_theory_normal_Normal_0 self) (let (a, _, _) = just in a)) (Type.cdsat_theory_normal_Normal_0 self)
  axiom deduce_spec : forall self : Type.cdsat_theory_normal, just : (Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value), Type.cdsat_theory_term, Type.cdsat_theory_value), tgt : Type.cdsat_theory_normal . ([#"/Users/xavier/Code/cdsat/src/theory.rs" 556 15 556 35] Invariant0.invariant' (Type.cdsat_theory_normal_Normal_0 self)) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 557 15 557 27] Sound0.sound self) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 560 4 560 46] deduce self just tgt -> Impls0.impls (Type.cdsat_theory_normal_Normal_0 self) (Type.cdsat_theory_normal_Normal_0 tgt)) && ([#"/Users/xavier/Code/cdsat/src/theory.rs" 559 4 559 38] deduce self just tgt -> Sound0.sound tgt) && ([#"/Users/xavier/Code/cdsat/src/theory.rs" 558 4 558 46] deduce self just tgt -> Invariant0.invariant' (Type.cdsat_theory_normal_Normal_0 tgt))
end
module Cdsat_Theory_Impl5_Deduce_Impl
  use Type
  use set.Fset
  clone Cdsat_Theory_Impl1_Sort as Sort1
  clone Cdsat_Theory_Impl0_Sort as Sort0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl3_Invariant as Invariant1 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl3_Interp as Interp0 with predicate Invariant0.invariant' = Invariant1.invariant',
  function Sort0.sort = Sort1.sort, function Sort1.sort = Sort0.sort, axiom .
  clone Cdsat_Theory_Impl3_Satisfies as Satisfies0 with function Interp0.interp = Interp0.interp,
  predicate Invariant0.invariant' = Invariant1.invariant', function Sort0.sort = Sort1.sort,
  function Sort1.sort = Sort0.sort
  clone CreusotContracts_Logic_Fset_Impl0_Contains as Contains0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl3_SatisfySet as SatisfySet0 with predicate Contains0.contains = Contains0.contains,
  predicate Satisfies0.satisfies = Satisfies0.satisfies
  clone Cdsat_Theory_Impl2_JustifiedSound as JustifiedSound0 with predicate Invariant0.invariant' = Invariant1.invariant',
  predicate SatisfySet0.satisfy_set = SatisfySet0.satisfy_set, predicate Satisfies0.satisfies = Satisfies0.satisfies
  clone Cdsat_Theory_Impl2_Invariant as Invariant2 with function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone CreusotContracts_Logic_Fset_Impl0_Remove as Remove0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl2_ToPair as ToPair0
  clone Cdsat_Theory_Impl4_Len as Len0 with axiom .
  clone Cdsat_Theory_Impl4_InvariantAssign as InvariantAssign0 with predicate Invariant0.invariant' = Invariant2.invariant'
  clone Cdsat_Theory_Impl4_Level as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg as InvariantNonneg0 with function Level0.level = Level0.level,
  function Len0.len = Len0.len
  clone Cdsat_Theory_Impl4_Find as Find0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl1_IsBool as IsBool0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl1_Negate as Negate0 with predicate IsBool0.is_bool = IsBool0.is_bool, axiom .
  clone Cdsat_Theory_Impl4_LevelOf as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_Contains as Contains1 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_SatisfiedBy as SatisfiedBy0 with predicate Contains0.contains = Contains1.contains,
  predicate Satisfies0.satisfies = Satisfies0.satisfies,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_TrailUnique as TrailUnique0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate Contains0.contains = Contains1.contains, predicate IsBool0.is_bool = IsBool0.is_bool,
  function Negate0.negate = Negate0.negate,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_InvariantContains as InvariantContains0 with predicate Contains0.contains = Contains0.contains,
  predicate Contains1.contains = Contains1.contains,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_SetLevel as SetLevel0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, function Len0.len = Len0.len, function Remove0.remove = Remove0.remove, axiom .
  clone Cdsat_Theory_Impl4_InvariantLevel as InvariantLevel0 with function Level0.level = Level0.level,
  function SetLevel0.set_level = SetLevel0.set_level, function Len0.len = Len0.len,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of
  clone Cdsat_Theory_Impl4_Invariant as Invariant0 with predicate InvariantLevel0.invariant_level = InvariantLevel0.invariant_level,
  predicate InvariantContains0.invariant_contains = InvariantContains0.invariant_contains,
  predicate TrailUnique0.trail_unique = TrailUnique0.trail_unique,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign
  clone Cdsat_Theory_Impl4_CountBounds as CountBounds0 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_Restrict as Restrict0 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  function Len0.len = Len0.len, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function CountBounds0.count_bounds = CountBounds0.count_bounds, axiom .
  clone Cdsat_Theory_Impl4_Unsat as Unsat0 with predicate Invariant0.invariant' = Invariant1.invariant',
  function Restrict0.restrict = Restrict0.restrict, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  predicate Invariant1.invariant' = Invariant0.invariant', predicate Contains0.contains = Contains1.contains,
  function LevelOf0.level_of = LevelOf0.level_of, function Level0.level = Level0.level, function Len0.len = Len0.len,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg
  clone Cdsat_Theory_Impl4_Sound as Sound1 with predicate JustifiedSound0.justified_sound = JustifiedSound0.justified_sound
  clone Cdsat_Theory_Impl4_Acceptable as Acceptable0 with predicate Contains0.contains = Contains1.contains,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, predicate IsBool0.is_bool = IsBool0.is_bool,
  function Negate0.negate = Negate0.negate,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign
  clone Cdsat_Theory_Impl4_Impls as Impls0 with predicate Unsat0.unsat = Unsat0.unsat,
  predicate Invariant0.invariant' = Invariant1.invariant', function Restrict0.restrict = Restrict0.restrict,
  predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  predicate Invariant1.invariant' = Invariant0.invariant', predicate Contains0.contains = Contains1.contains,
  function LevelOf0.level_of = LevelOf0.level_of, function Level0.level = Level0.level, function Len0.len = Len0.len,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  axiom .
  clone Cdsat_Theory_Impl5_Sound as Sound0 with predicate Sound0.sound = Sound1.sound
  let rec ghost function deduce (self : Type.cdsat_theory_normal) (just : (Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value), Type.cdsat_theory_term, Type.cdsat_theory_value)) (tgt : Type.cdsat_theory_normal) : bool
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 556 15 556 35] Invariant0.invariant' (Type.cdsat_theory_normal_Normal_0 self)}
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 557 15 557 27] Sound0.sound self}
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 558 4 558 46] result -> Invariant0.invariant' (Type.cdsat_theory_normal_Normal_0 tgt) }
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 559 4 559 38] result -> Sound0.sound tgt }
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 560 4 560 46] result -> Impls0.impls (Type.cdsat_theory_normal_Normal_0 self) (Type.cdsat_theory_normal_Normal_0 tgt) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 562 8 568 11] let _ = let a' = Type.cdsat_theory_normal_Normal_0 self in CountBounds0.count_bounds a' in IsBool0.is_bool (let (_, _, a) = just in a) && (let a' = Type.cdsat_theory_normal_Normal_0 self in Acceptable0.acceptable a' (let (_, a, _) = just in a) (let (_, _, a) = just in a)) && pure {forall j : ((Type.cdsat_theory_term, Type.cdsat_theory_value)) . Contains0.contains (let (a, _, _) = just in a) j -> Contains1.contains (Type.cdsat_theory_normal_Normal_0 self) j} && pure {forall m : (Type.cdsat_theory_model) . SatisfySet0.satisfy_set m (let (a, _, _) = just in a) -> Satisfies0.satisfies m (let (_, a, _) = just in a, let (_, _, a) = just in a)} && (let b = Type.Cdsat_Theory_Trail_Assign (Type.Cdsat_Theory_Assign_Justified (let (a, _, _) = just in a) (let (_, a, _) = just in a) (let (_, _, a) = just in a)) (let a' = Type.cdsat_theory_normal_Normal_0 self in SetLevel0.set_level a' (let (a, _, _) = just in a)) (Type.cdsat_theory_normal_Normal_0 self) in let a = Type.cdsat_theory_normal_Normal_0 tgt in pure {a = b})
end
module Cdsat_Theory_Impl5_Fail_Interface
  use Type
  use set.Fset
  clone Cdsat_Theory_Impl4_Unsat_Interface as Unsat0
  clone Cdsat_Theory_Impl5_Sound_Interface as Sound0
  clone Cdsat_Theory_Impl4_Invariant_Interface as Invariant0
  predicate fail (self : Type.cdsat_theory_normal) (just : (Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value), Type.cdsat_theory_term, Type.cdsat_theory_value))
    
end
module Cdsat_Theory_Impl5_Fail
  use Type
  use set.Fset
  clone Cdsat_Theory_Impl4_Unsat_Interface as Unsat0
  clone Cdsat_Theory_Impl5_Sound_Interface as Sound0
  clone Cdsat_Theory_Impl4_Invariant_Interface as Invariant0
  use mach.int.Int
  use mach.int.Int32
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone Cdsat_Theory_Impl1_IsBool_Interface as IsBool0
  clone Cdsat_Theory_Impl4_LevelOf_Interface as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  clone CreusotContracts_Logic_Fset_Impl0_Contains_Interface as Contains0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_SetLevel_Interface as SetLevel0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl3_Satisfies_Interface as Satisfies0
  clone Cdsat_Theory_Impl3_SatisfySet_Interface as SatisfySet0
  clone Cdsat_Theory_Impl4_Contains_Interface as Contains1 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl1_Negate_Interface as Negate0 with predicate IsBool0.is_bool = IsBool0.is_bool, axiom .
  predicate fail [#"/Users/xavier/Code/cdsat/src/theory.rs" 576 4 576 71] (self : Type.cdsat_theory_normal) (just : (Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value), Type.cdsat_theory_term, Type.cdsat_theory_value))
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 577 8 584 11] let not_l = (let (_, a, _) = just in a, Negate0.negate (let (_, _, a) = just in a)) in (forall j : ((Type.cdsat_theory_term, Type.cdsat_theory_value)) . Contains0.contains (let (a, _, _) = just in a) j -> Contains1.contains (Type.cdsat_theory_normal_Normal_0 self) j) /\ not Contains1.contains (Type.cdsat_theory_normal_Normal_0 self) (let (_, a, _) = just in a, let (_, _, a) = just in a) /\ (forall m : (Type.cdsat_theory_model) . SatisfySet0.satisfy_set m (let (a, _, _) = just in a) -> Satisfies0.satisfies m (let (_, a, _) = just in a, let (_, _, a) = just in a)) /\ Contains1.contains (Type.cdsat_theory_normal_Normal_0 self) not_l /\ LevelOf0.level_of (Type.cdsat_theory_normal_Normal_0 self) not_l = 0 /\ SetLevel0.set_level (Type.cdsat_theory_normal_Normal_0 self) (let (a, _, _) = just in a) = 0
  axiom fail_spec : forall self : Type.cdsat_theory_normal, just : (Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value), Type.cdsat_theory_term, Type.cdsat_theory_value) . ([#"/Users/xavier/Code/cdsat/src/theory.rs" 573 15 573 35] Invariant0.invariant' (Type.cdsat_theory_normal_Normal_0 self)) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 574 15 574 27] Sound0.sound self) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 575 4 575 41] fail self just -> Unsat0.unsat (Type.cdsat_theory_normal_Normal_0 self))
end
module Cdsat_Theory_Impl5_Fail_Impl
  use Type
  use set.Fset
  use mach.int.Int
  use mach.int.Int32
  clone Cdsat_Theory_Impl4_Len as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg as InvariantNonneg0 with function Level0.level = Level0.level,
  function Len0.len = Len0.len
  clone Cdsat_Theory_Impl1_Sort as Sort1
  clone Cdsat_Theory_Impl0_Sort as Sort0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl2_Invariant as Invariant2 with function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_InvariantAssign as InvariantAssign0 with predicate Invariant0.invariant' = Invariant2.invariant'
  clone Cdsat_Theory_Impl2_ToPair as ToPair0
  clone Cdsat_Theory_Impl4_Find as Find0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_LevelOf as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_Contains as Contains1 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl1_IsBool as IsBool0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl1_Negate as Negate0 with predicate IsBool0.is_bool = IsBool0.is_bool, axiom .
  clone Cdsat_Theory_Impl4_TrailUnique as TrailUnique0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate Contains0.contains = Contains1.contains, predicate IsBool0.is_bool = IsBool0.is_bool,
  function Negate0.negate = Negate0.negate,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone CreusotContracts_Logic_Fset_Impl0_Contains as Contains0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_InvariantContains as InvariantContains0 with predicate Contains0.contains = Contains0.contains,
  predicate Contains1.contains = Contains1.contains,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone CreusotContracts_Logic_Fset_Impl0_Remove as Remove0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_SetLevel as SetLevel0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, function Len0.len = Len0.len, function Remove0.remove = Remove0.remove, axiom .
  clone Cdsat_Theory_Impl4_InvariantLevel as InvariantLevel0 with function Level0.level = Level0.level,
  function SetLevel0.set_level = SetLevel0.set_level, function Len0.len = Len0.len,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of
  clone Cdsat_Theory_Impl4_Invariant as Invariant0 with predicate InvariantLevel0.invariant_level = InvariantLevel0.invariant_level,
  predicate InvariantContains0.invariant_contains = InvariantContains0.invariant_contains,
  predicate TrailUnique0.trail_unique = TrailUnique0.trail_unique,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign
  clone Cdsat_Theory_Impl4_CountBounds as CountBounds0 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl3_Invariant as Invariant1 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl3_Interp as Interp0 with predicate Invariant0.invariant' = Invariant1.invariant',
  function Sort0.sort = Sort1.sort, function Sort1.sort = Sort0.sort, axiom .
  clone Cdsat_Theory_Impl3_Satisfies as Satisfies0 with function Interp0.interp = Interp0.interp,
  predicate Invariant0.invariant' = Invariant1.invariant', function Sort0.sort = Sort1.sort,
  function Sort1.sort = Sort0.sort
  clone Cdsat_Theory_Impl3_SatisfySet as SatisfySet0 with predicate Contains0.contains = Contains0.contains,
  predicate Satisfies0.satisfies = Satisfies0.satisfies
  clone Cdsat_Theory_Impl2_JustifiedSound as JustifiedSound0 with predicate Invariant0.invariant' = Invariant1.invariant',
  predicate SatisfySet0.satisfy_set = SatisfySet0.satisfy_set, predicate Satisfies0.satisfies = Satisfies0.satisfies
  clone Cdsat_Theory_Impl4_SatisfiedBy as SatisfiedBy0 with predicate Contains0.contains = Contains1.contains,
  predicate Satisfies0.satisfies = Satisfies0.satisfies,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_Restrict as Restrict0 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  function Len0.len = Len0.len, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function CountBounds0.count_bounds = CountBounds0.count_bounds, axiom .
  clone Cdsat_Theory_Impl4_Sound as Sound1 with predicate JustifiedSound0.justified_sound = JustifiedSound0.justified_sound
  clone Cdsat_Theory_Impl4_Unsat as Unsat0 with predicate Invariant0.invariant' = Invariant1.invariant',
  function Restrict0.restrict = Restrict0.restrict, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  predicate Invariant1.invariant' = Invariant0.invariant', predicate Contains0.contains = Contains1.contains,
  function LevelOf0.level_of = LevelOf0.level_of, function Level0.level = Level0.level, function Len0.len = Len0.len,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg
  clone Cdsat_Theory_Impl5_Sound as Sound0 with predicate Sound0.sound = Sound1.sound
  let rec ghost function fail (self : Type.cdsat_theory_normal) (just : (Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value), Type.cdsat_theory_term, Type.cdsat_theory_value)) : bool
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 573 15 573 35] Invariant0.invariant' (Type.cdsat_theory_normal_Normal_0 self)}
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 574 15 574 27] Sound0.sound self}
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 575 4 575 41] result -> Unsat0.unsat (Type.cdsat_theory_normal_Normal_0 self) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 577 8 584 11] let not_l = (let (_, a, _) = just in a, Negate0.negate (let (_, _, a) = just in a)) in pure {forall j : ((Type.cdsat_theory_term, Type.cdsat_theory_value)) . Contains0.contains (let (a, _, _) = just in a) j -> Contains1.contains (Type.cdsat_theory_normal_Normal_0 self) j} && not (let a' = Type.cdsat_theory_normal_Normal_0 self in Contains1.contains a' (let (_, a, _) = just in a, let (_, _, a) = just in a)) && pure {forall m : (Type.cdsat_theory_model) . SatisfySet0.satisfy_set m (let (a, _, _) = just in a) -> Satisfies0.satisfies m (let (_, a, _) = just in a, let (_, _, a) = just in a)} && (let a' = Type.cdsat_theory_normal_Normal_0 self in Contains1.contains a' not_l) && (let a = let a' = Type.cdsat_theory_normal_Normal_0 self in LevelOf0.level_of a' not_l in pure {a = 0}) && (let a = let a' = Type.cdsat_theory_normal_Normal_0 self in SetLevel0.set_level a' (let (a, _, _) = just in a) in pure {a = 0})
end
module Cdsat_Theory_Impl5_ConflictSolve_Interface
  use Type
  use set.Fset
  clone Cdsat_Theory_Impl4_Unsat_Interface as Unsat0
  clone Cdsat_Theory_Impl4_Impls_Interface as Impls0 with predicate Unsat0.unsat = Unsat0.unsat, axiom .
  clone Cdsat_Theory_Impl6_Sound_Interface as Sound1
  clone Cdsat_Theory_Impl5_Sound_Interface as Sound0
  clone Cdsat_Theory_Impl4_Invariant_Interface as Invariant0
  predicate conflict_solve (self : Type.cdsat_theory_normal) (just : (Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value), Type.cdsat_theory_term, Type.cdsat_theory_value)) (tgt : Type.cdsat_theory_conflict)
    
end
module Cdsat_Theory_Impl5_ConflictSolve
  use Type
  use set.Fset
  clone Cdsat_Theory_Impl4_Unsat_Interface as Unsat0
  clone Cdsat_Theory_Impl4_Impls_Interface as Impls0 with predicate Unsat0.unsat = Unsat0.unsat, axiom .
  clone Cdsat_Theory_Impl6_Sound_Interface as Sound1
  clone Cdsat_Theory_Impl5_Sound_Interface as Sound0
  clone Cdsat_Theory_Impl4_Invariant_Interface as Invariant0
  use mach.int.Int
  use mach.int.Int32
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl4_LevelOf_Interface as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone Cdsat_Theory_Impl1_IsBool_Interface as IsBool0
  clone CreusotContracts_Logic_Fset_Impl0_Contains_Interface as Contains1 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_SetLevel_Interface as SetLevel0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl3_Satisfies_Interface as Satisfies0
  clone Cdsat_Theory_Impl3_SatisfySet_Interface as SatisfySet0
  clone Cdsat_Theory_Impl3_Invariant_Interface as Invariant1
  clone Cdsat_Theory_Impl4_Contains_Interface as Contains0 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, axiom .
  clone CreusotContracts_Logic_Fset_Impl0_Insert_Interface as Insert0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl1_Negate_Interface as Negate0 with predicate IsBool0.is_bool = IsBool0.is_bool, axiom .
  predicate conflict_solve [#"/Users/xavier/Code/cdsat/src/theory.rs" 610 4 610 96] (self : Type.cdsat_theory_normal) (just : (Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value), Type.cdsat_theory_term, Type.cdsat_theory_value)) (tgt : Type.cdsat_theory_conflict)
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 8 621 11] let not_l = (let (_, a, _) = just in a, Negate0.negate (let (_, _, a) = just in a)) in let conflict = Insert0.insert (let (a, _, _) = just in a) not_l in Contains0.contains (Type.cdsat_theory_normal_Normal_0 self) not_l /\ (forall j : ((Type.cdsat_theory_term, Type.cdsat_theory_value)) . Contains1.contains (let (a, _, _) = just in a) j -> Contains0.contains (Type.cdsat_theory_normal_Normal_0 self) j) /\ not Contains0.contains (Type.cdsat_theory_normal_Normal_0 self) (let (_, a, _) = just in a, let (_, _, a) = just in a) /\ (forall m : (Type.cdsat_theory_model) . Invariant1.invariant' m -> SatisfySet0.satisfy_set m (let (a, _, _) = just in a) -> Satisfies0.satisfies m (let (_, a, _) = just in a, let (_, _, a) = just in a)) /\ SetLevel0.set_level (Type.cdsat_theory_normal_Normal_0 self) conflict > 0 /\ tgt = Type.Cdsat_Theory_Conflict (Type.cdsat_theory_normal_Normal_0 self) conflict
  axiom conflict_solve_spec : forall self : Type.cdsat_theory_normal, just : (Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value), Type.cdsat_theory_term, Type.cdsat_theory_value), tgt : Type.cdsat_theory_conflict . ([#"/Users/xavier/Code/cdsat/src/theory.rs" 605 15 605 35] Invariant0.invariant' (Type.cdsat_theory_normal_Normal_0 self)) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 606 15 606 27] Sound0.sound self) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 609 4 609 46] conflict_solve self just tgt -> Impls0.impls (Type.cdsat_theory_normal_Normal_0 self) (Type.cdsat_theory_conflict_Conflict_0 tgt)) && ([#"/Users/xavier/Code/cdsat/src/theory.rs" 608 4 608 38] conflict_solve self just tgt -> Sound1.sound tgt) && ([#"/Users/xavier/Code/cdsat/src/theory.rs" 607 4 607 46] conflict_solve self just tgt -> Invariant0.invariant' (Type.cdsat_theory_conflict_Conflict_0 tgt))
end
module Cdsat_Theory_Impl5_ConflictSolve_Impl
  use Type
  use set.Fset
  use mach.int.Int
  use mach.int.Int32
  clone Cdsat_Theory_Impl4_Len as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg as InvariantNonneg0 with function Level0.level = Level0.level,
  function Len0.len = Len0.len
  clone Cdsat_Theory_Impl1_Sort as Sort1
  clone Cdsat_Theory_Impl0_Sort as Sort0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl2_Invariant as Invariant2 with function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_InvariantAssign as InvariantAssign0 with predicate Invariant0.invariant' = Invariant2.invariant'
  clone Cdsat_Theory_Impl2_ToPair as ToPair0
  clone Cdsat_Theory_Impl4_Find as Find0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_LevelOf as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_Contains as Contains0 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl1_IsBool as IsBool0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl1_Negate as Negate0 with predicate IsBool0.is_bool = IsBool0.is_bool, axiom .
  clone Cdsat_Theory_Impl4_TrailUnique as TrailUnique0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate Contains0.contains = Contains0.contains, predicate IsBool0.is_bool = IsBool0.is_bool,
  function Negate0.negate = Negate0.negate,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone CreusotContracts_Logic_Fset_Impl0_Contains as Contains1 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_InvariantContains as InvariantContains0 with predicate Contains0.contains = Contains1.contains,
  predicate Contains1.contains = Contains0.contains,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone CreusotContracts_Logic_Fset_Impl0_Remove as Remove0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_SetLevel as SetLevel0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, function Len0.len = Len0.len, function Remove0.remove = Remove0.remove, axiom .
  clone Cdsat_Theory_Impl4_InvariantLevel as InvariantLevel0 with function Level0.level = Level0.level,
  function SetLevel0.set_level = SetLevel0.set_level, function Len0.len = Len0.len,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of
  clone Cdsat_Theory_Impl4_Invariant as Invariant0 with predicate InvariantLevel0.invariant_level = InvariantLevel0.invariant_level,
  predicate InvariantContains0.invariant_contains = InvariantContains0.invariant_contains,
  predicate TrailUnique0.trail_unique = TrailUnique0.trail_unique,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign
  clone Cdsat_Theory_Impl4_CountBounds as CountBounds0 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl3_Invariant as Invariant1 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl3_Interp as Interp0 with predicate Invariant0.invariant' = Invariant1.invariant',
  function Sort0.sort = Sort1.sort, function Sort1.sort = Sort0.sort, axiom .
  clone Cdsat_Theory_Impl3_Satisfies as Satisfies0 with function Interp0.interp = Interp0.interp,
  predicate Invariant0.invariant' = Invariant1.invariant', function Sort0.sort = Sort1.sort,
  function Sort1.sort = Sort0.sort
  clone Cdsat_Theory_Impl3_SatisfySet as SatisfySet0 with predicate Contains0.contains = Contains1.contains,
  predicate Satisfies0.satisfies = Satisfies0.satisfies
  clone Cdsat_Theory_Impl2_JustifiedSound as JustifiedSound0 with predicate Invariant0.invariant' = Invariant1.invariant',
  predicate SatisfySet0.satisfy_set = SatisfySet0.satisfy_set, predicate Satisfies0.satisfies = Satisfies0.satisfies
  clone Cdsat_Theory_Impl4_SatisfiedBy as SatisfiedBy0 with predicate Contains0.contains = Contains0.contains,
  predicate Satisfies0.satisfies = Satisfies0.satisfies,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_Restrict as Restrict0 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  function Len0.len = Len0.len, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function CountBounds0.count_bounds = CountBounds0.count_bounds, axiom .
  clone Cdsat_Theory_Impl4_Unsat as Unsat0 with predicate Invariant0.invariant' = Invariant1.invariant',
  function Restrict0.restrict = Restrict0.restrict, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  predicate Invariant1.invariant' = Invariant0.invariant', predicate Contains0.contains = Contains0.contains,
  function LevelOf0.level_of = LevelOf0.level_of, function Level0.level = Level0.level, function Len0.len = Len0.len,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg
  clone Cdsat_Theory_Impl4_Sound as Sound2 with predicate JustifiedSound0.justified_sound = JustifiedSound0.justified_sound
  clone CreusotContracts_Logic_Fset_Impl0_Insert as Insert0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_Impls as Impls0 with predicate Unsat0.unsat = Unsat0.unsat,
  predicate Invariant0.invariant' = Invariant1.invariant', function Restrict0.restrict = Restrict0.restrict,
  predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  predicate Invariant1.invariant' = Invariant0.invariant', predicate Contains0.contains = Contains0.contains,
  function LevelOf0.level_of = LevelOf0.level_of, function Level0.level = Level0.level, function Len0.len = Len0.len,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  axiom .
  clone Cdsat_Theory_Impl6_Sound as Sound1 with predicate Sound0.sound = Sound2.sound,
  predicate Invariant0.invariant' = Invariant1.invariant', predicate SatisfySet0.satisfy_set = SatisfySet0.satisfy_set
  clone Cdsat_Theory_Impl5_Sound as Sound0 with predicate Sound0.sound = Sound2.sound
  let rec ghost function conflict_solve (self : Type.cdsat_theory_normal) (just : (Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value), Type.cdsat_theory_term, Type.cdsat_theory_value)) (tgt : Type.cdsat_theory_conflict) : bool
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 605 15 605 35] Invariant0.invariant' (Type.cdsat_theory_normal_Normal_0 self)}
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 606 15 606 27] Sound0.sound self}
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 607 4 607 46] result -> Invariant0.invariant' (Type.cdsat_theory_conflict_Conflict_0 tgt) }
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 608 4 608 38] result -> Sound1.sound tgt }
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 609 4 609 46] result -> Impls0.impls (Type.cdsat_theory_normal_Normal_0 self) (Type.cdsat_theory_conflict_Conflict_0 tgt) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 8 621 11] let not_l = (let (_, a, _) = just in a, Negate0.negate (let (_, _, a) = just in a)) in let conflict = Insert0.insert (let (a, _, _) = just in a) not_l in (let a' = Type.cdsat_theory_normal_Normal_0 self in Contains0.contains a' not_l) && pure {forall j : ((Type.cdsat_theory_term, Type.cdsat_theory_value)) . Contains1.contains (let (a, _, _) = just in a) j -> Contains0.contains (Type.cdsat_theory_normal_Normal_0 self) j} && not (let a' = Type.cdsat_theory_normal_Normal_0 self in Contains0.contains a' (let (_, a, _) = just in a, let (_, _, a) = just in a)) && pure {forall m : (Type.cdsat_theory_model) . Invariant1.invariant' m -> SatisfySet0.satisfy_set m (let (a, _, _) = just in a) -> Satisfies0.satisfies m (let (_, a, _) = just in a, let (_, _, a) = just in a)} && (let a' = Type.cdsat_theory_normal_Normal_0 self in SetLevel0.set_level a' conflict) > 0 && (let b = Type.Cdsat_Theory_Conflict (Type.cdsat_theory_normal_Normal_0 self) conflict in pure {tgt = b})
end
module Cdsat_Theory_Impl5_ConflictSolve2_Interface
  use Type
  use set.Fset
  clone Cdsat_Theory_Impl4_Unsat_Interface as Unsat0
  clone Cdsat_Theory_Impl4_Impls_Interface as Impls0 with predicate Unsat0.unsat = Unsat0.unsat, axiom .
  clone Cdsat_Theory_Impl6_Sound_Interface as Sound1
  clone Cdsat_Theory_Impl5_Sound_Interface as Sound0
  clone Cdsat_Theory_Impl4_Invariant_Interface as Invariant0
  predicate conflict_solve2 (self : Type.cdsat_theory_normal) (conflict : Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value)) (tgt : Type.cdsat_theory_conflict)
    
end
module Cdsat_Theory_Impl5_ConflictSolve2
  use Type
  use set.Fset
  clone Cdsat_Theory_Impl4_Unsat_Interface as Unsat0
  clone Cdsat_Theory_Impl4_Impls_Interface as Impls0 with predicate Unsat0.unsat = Unsat0.unsat, axiom .
  clone Cdsat_Theory_Impl6_Sound_Interface as Sound1
  clone Cdsat_Theory_Impl5_Sound_Interface as Sound0
  clone Cdsat_Theory_Impl4_Invariant_Interface as Invariant0
  use mach.int.Int
  use mach.int.Int32
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl4_LevelOf_Interface as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl1_Sort_Interface as Sort1
  clone Cdsat_Theory_Impl0_Sort_Interface as Sort0
  clone Cdsat_Theory_Impl4_InvariantAssign_Interface as InvariantAssign0
  clone CreusotContracts_Logic_Fset_Impl0_Contains_Interface as Contains0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_SetLevel_Interface as SetLevel0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl3_SatisfySet_Interface as SatisfySet0
  clone Cdsat_Theory_Impl4_Contains_Interface as Contains1 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, axiom .
  predicate conflict_solve2 [#"/Users/xavier/Code/cdsat/src/theory.rs" 632 4 632 86] (self : Type.cdsat_theory_normal) (conflict : Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value)) (tgt : Type.cdsat_theory_conflict)
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 634 10 637 43] (forall j : ((Type.cdsat_theory_term, Type.cdsat_theory_value)) . Contains0.contains conflict j -> Contains1.contains (Type.cdsat_theory_normal_Normal_0 self) j) /\ (forall m : (Type.cdsat_theory_model) . SatisfySet0.satisfy_set m conflict -> false) /\ SetLevel0.set_level (Type.cdsat_theory_normal_Normal_0 self) conflict > 0 /\ tgt = Type.Cdsat_Theory_Conflict (Type.cdsat_theory_normal_Normal_0 self) conflict
  axiom conflict_solve2_spec : forall self : Type.cdsat_theory_normal, conflict : Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value), tgt : Type.cdsat_theory_conflict . ([#"/Users/xavier/Code/cdsat/src/theory.rs" 627 15 627 35] Invariant0.invariant' (Type.cdsat_theory_normal_Normal_0 self)) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 628 15 628 27] Sound0.sound self) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 631 4 631 46] conflict_solve2 self conflict tgt -> Impls0.impls (Type.cdsat_theory_normal_Normal_0 self) (Type.cdsat_theory_conflict_Conflict_0 tgt)) && ([#"/Users/xavier/Code/cdsat/src/theory.rs" 630 4 630 38] conflict_solve2 self conflict tgt -> Sound1.sound tgt) && ([#"/Users/xavier/Code/cdsat/src/theory.rs" 629 4 629 46] conflict_solve2 self conflict tgt -> Invariant0.invariant' (Type.cdsat_theory_conflict_Conflict_0 tgt))
end
module Cdsat_Theory_Impl5_ConflictSolve2_Impl
  use Type
  use set.Fset
  use mach.int.Int
  use mach.int.Int32
  clone Cdsat_Theory_Impl1_Sort as Sort1
  clone Cdsat_Theory_Impl0_Sort as Sort0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl3_Invariant as Invariant1 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl3_Interp as Interp0 with predicate Invariant0.invariant' = Invariant1.invariant',
  function Sort0.sort = Sort1.sort, function Sort1.sort = Sort0.sort, axiom .
  clone Cdsat_Theory_Impl4_Len as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg as InvariantNonneg0 with function Level0.level = Level0.level,
  function Len0.len = Len0.len
  clone Cdsat_Theory_Impl2_Invariant as Invariant2 with function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_InvariantAssign as InvariantAssign0 with predicate Invariant0.invariant' = Invariant2.invariant'
  clone Cdsat_Theory_Impl2_ToPair as ToPair0
  clone Cdsat_Theory_Impl4_Find as Find0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_LevelOf as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, axiom .
  clone Cdsat_Theory_Impl4_Contains as Contains1 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl1_IsBool as IsBool0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl1_Negate as Negate0 with predicate IsBool0.is_bool = IsBool0.is_bool, axiom .
  clone Cdsat_Theory_Impl4_TrailUnique as TrailUnique0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate Contains0.contains = Contains1.contains, predicate IsBool0.is_bool = IsBool0.is_bool,
  function Negate0.negate = Negate0.negate,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone CreusotContracts_Logic_Fset_Impl0_Contains as Contains0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_InvariantContains as InvariantContains0 with predicate Contains0.contains = Contains0.contains,
  predicate Contains1.contains = Contains1.contains,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone CreusotContracts_Logic_Fset_Impl0_Remove as Remove0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_SetLevel as SetLevel0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, function Len0.len = Len0.len, function Remove0.remove = Remove0.remove, axiom .
  clone Cdsat_Theory_Impl4_InvariantLevel as InvariantLevel0 with function Level0.level = Level0.level,
  function SetLevel0.set_level = SetLevel0.set_level, function Len0.len = Len0.len,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of
  clone Cdsat_Theory_Impl4_Invariant as Invariant0 with predicate InvariantLevel0.invariant_level = InvariantLevel0.invariant_level,
  predicate InvariantContains0.invariant_contains = InvariantContains0.invariant_contains,
  predicate TrailUnique0.trail_unique = TrailUnique0.trail_unique,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign
  clone Cdsat_Theory_Impl4_CountBounds as CountBounds0 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl3_Satisfies as Satisfies0 with function Interp0.interp = Interp0.interp,
  predicate Invariant0.invariant' = Invariant1.invariant', function Sort0.sort = Sort1.sort,
  function Sort1.sort = Sort0.sort
  clone Cdsat_Theory_Impl3_SatisfySet as SatisfySet0 with predicate Contains0.contains = Contains0.contains,
  predicate Satisfies0.satisfies = Satisfies0.satisfies
  clone Cdsat_Theory_Impl2_JustifiedSound as JustifiedSound0 with predicate Invariant0.invariant' = Invariant1.invariant',
  predicate SatisfySet0.satisfy_set = SatisfySet0.satisfy_set, predicate Satisfies0.satisfies = Satisfies0.satisfies
  clone Cdsat_Theory_Impl4_SatisfiedBy as SatisfiedBy0 with predicate Contains0.contains = Contains1.contains,
  predicate Satisfies0.satisfies = Satisfies0.satisfies,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_Restrict as Restrict0 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Contains0.contains = Contains1.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  function Len0.len = Len0.len, predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function CountBounds0.count_bounds = CountBounds0.count_bounds, axiom .
  clone Cdsat_Theory_Impl4_Unsat as Unsat0 with predicate Invariant0.invariant' = Invariant1.invariant',
  function Restrict0.restrict = Restrict0.restrict, predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  predicate Invariant1.invariant' = Invariant0.invariant', predicate Contains0.contains = Contains1.contains,
  function LevelOf0.level_of = LevelOf0.level_of, function Level0.level = Level0.level, function Len0.len = Len0.len,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg
  clone Cdsat_Theory_Impl4_Sound as Sound2 with predicate JustifiedSound0.justified_sound = JustifiedSound0.justified_sound
  clone Cdsat_Theory_Impl4_Impls as Impls0 with predicate Unsat0.unsat = Unsat0.unsat,
  predicate Invariant0.invariant' = Invariant1.invariant', function Restrict0.restrict = Restrict0.restrict,
  predicate SatisfiedBy0.satisfied_by = SatisfiedBy0.satisfied_by,
  predicate Invariant1.invariant' = Invariant0.invariant', predicate Contains0.contains = Contains1.contains,
  function LevelOf0.level_of = LevelOf0.level_of, function Level0.level = Level0.level, function Len0.len = Len0.len,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  axiom .
  clone Cdsat_Theory_Impl6_Sound as Sound1 with predicate Sound0.sound = Sound2.sound,
  predicate Invariant0.invariant' = Invariant1.invariant', predicate SatisfySet0.satisfy_set = SatisfySet0.satisfy_set
  clone Cdsat_Theory_Impl5_Sound as Sound0 with predicate Sound0.sound = Sound2.sound
  let rec ghost function conflict_solve2 (self : Type.cdsat_theory_normal) (conflict : Fset.fset (Type.cdsat_theory_term, Type.cdsat_theory_value)) (tgt : Type.cdsat_theory_conflict) : bool
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 627 15 627 35] Invariant0.invariant' (Type.cdsat_theory_normal_Normal_0 self)}
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 628 15 628 27] Sound0.sound self}
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 629 4 629 46] result -> Invariant0.invariant' (Type.cdsat_theory_conflict_Conflict_0 tgt) }
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 630 4 630 38] result -> Sound1.sound tgt }
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 631 4 631 46] result -> Impls0.impls (Type.cdsat_theory_normal_Normal_0 self) (Type.cdsat_theory_conflict_Conflict_0 tgt) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 634 10 637 43] pure {forall j : ((Type.cdsat_theory_term, Type.cdsat_theory_value)) . Contains0.contains conflict j -> Contains1.contains (Type.cdsat_theory_normal_Normal_0 self) j} && pure {forall m : (Type.cdsat_theory_model) . SatisfySet0.satisfy_set m conflict -> false} && (let a' = Type.cdsat_theory_normal_Normal_0 self in SetLevel0.set_level a' conflict) > 0 && (let b = Type.Cdsat_Theory_Conflict (Type.cdsat_theory_normal_Normal_0 self) conflict in pure {tgt = b})
end
module Cdsat_Theory_Impl6_Resolve_Interface
  use Type
  clone Cdsat_Theory_Impl4_Invariant_Interface as Invariant1
  clone Cdsat_Theory_Impl6_Sound_Interface as Sound0
  clone Cdsat_Theory_Impl6_Invariant_Interface as Invariant0
  predicate resolve (self : Type.cdsat_theory_conflict) (a : (Type.cdsat_theory_term, Type.cdsat_theory_value)) (tgt : Type.cdsat_theory_conflict)
    
end
module Cdsat_Theory_Impl6_Resolve
  use Type
  clone Cdsat_Theory_Impl4_Invariant_Interface as Invariant1
  clone Cdsat_Theory_Impl6_Sound_Interface as Sound0
  clone Cdsat_Theory_Impl6_Invariant_Interface as Invariant0
  use map.Const
  use mach.int.Int
  use set.Fset
  clone Cdsat_Theory_Impl4_Len_Interface as Len0 with axiom .
  clone Cdsat_Theory_Impl4_Level_Interface as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg_Interface as InvariantNonneg0
  clone Cdsat_Theory_Impl3_Satisfies_Interface as Satisfies0
  clone Cdsat_Theory_Impl3_SatisfySet_Interface as SatisfySet0
  clone Cdsat_Theory_Impl3_Invariant_Interface as Invariant2
  clone Cdsat_Theory_Impl4_Sound_Interface as Sound1
  clone CreusotContracts_Logic_Fset_Impl0_Remove_Interface as Remove0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_LevelOf_Interface as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  clone CreusotContracts_Logic_Fset_Impl0_Contains_Interface as Contains0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_SetLevel_Interface as SetLevel0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl1_IsBool_Interface as IsBool0
  clone Cdsat_Theory_Impl4_IsJustified_Interface as IsJustified0
  clone Cdsat_Theory_Impl3_ResolveSound_Interface as ResolveSound0 with predicate SatisfySet0.satisfy_set = SatisfySet0.satisfy_set,
  predicate Satisfies0.satisfies = Satisfies0.satisfies, predicate Contains0.contains = Contains0.contains,
  function Remove0.remove = Remove0.remove, axiom .
  clone Cdsat_Theory_Impl4_Justification_Interface as Justification0 with predicate IsJustified0.is_justified = IsJustified0.is_justified,
  predicate Sound0.sound = Sound1.sound, predicate Invariant0.invariant' = Invariant2.invariant',
  predicate SatisfySet0.satisfy_set = SatisfySet0.satisfy_set, predicate Satisfies0.satisfies = Satisfies0.satisfies,
  axiom .
  predicate resolve [#"/Users/xavier/Code/cdsat/src/theory.rs" 677 4 677 61] (self : Type.cdsat_theory_conflict) (a : (Type.cdsat_theory_term, Type.cdsat_theory_value)) (tgt : Type.cdsat_theory_conflict)
    
   =
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 678 8 685 11] let just = Justification0.justification (Type.cdsat_theory_conflict_Conflict_0 self) a in let _ = ResolveSound0.resolve_sound (Type.Cdsat_Theory_Model (Const.const (Type.Cdsat_Theory_Value_Bool false))) (Type.cdsat_theory_conflict_Conflict_1 self) just a in IsJustified0.is_justified (Type.cdsat_theory_conflict_Conflict_0 self) a /\ (forall a : ((Type.cdsat_theory_term, Type.cdsat_theory_value)) . Contains0.contains just a /\ not IsBool0.is_bool (let (_, a) = a in a) -> LevelOf0.level_of (Type.cdsat_theory_conflict_Conflict_0 self) a < SetLevel0.set_level (Type.cdsat_theory_conflict_Conflict_0 self) (Type.cdsat_theory_conflict_Conflict_1 self)) /\ Contains0.contains (Type.cdsat_theory_conflict_Conflict_1 self) a /\ tgt = Type.Cdsat_Theory_Conflict (Type.cdsat_theory_conflict_Conflict_0 self) (Fset.union (Remove0.remove (Type.cdsat_theory_conflict_Conflict_1 self) a) just)
  axiom resolve_spec : forall self : Type.cdsat_theory_conflict, a : (Type.cdsat_theory_term, Type.cdsat_theory_value), tgt : Type.cdsat_theory_conflict . ([#"/Users/xavier/Code/cdsat/src/theory.rs" 673 15 673 31] Invariant0.invariant' self) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 674 15 674 27] Sound0.sound self) -> ([#"/Users/xavier/Code/cdsat/src/theory.rs" 676 4 676 38] resolve self a tgt -> Sound0.sound tgt) && ([#"/Users/xavier/Code/cdsat/src/theory.rs" 675 4 675 44] resolve self a tgt -> Invariant1.invariant' (Type.cdsat_theory_conflict_Conflict_0 tgt))
end
module Cdsat_Theory_Impl6_Resolve_Impl
  use Type
  use map.Const
  use mach.int.Int
  use set.Fset
  clone Cdsat_Theory_Impl1_Sort as Sort1
  clone Cdsat_Theory_Impl0_Sort as Sort0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl3_Invariant as Invariant2 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl3_Interp as Interp0 with predicate Invariant0.invariant' = Invariant2.invariant',
  function Sort0.sort = Sort1.sort, function Sort1.sort = Sort0.sort, axiom .
  clone Cdsat_Theory_Impl1_IsBool as IsBool0 with function Sort0.sort = Sort1.sort
  clone Cdsat_Theory_Impl1_Negate as Negate0 with predicate IsBool0.is_bool = IsBool0.is_bool, axiom .
  clone Cdsat_Theory_Impl2_Invariant as Invariant3 with function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl2_ToPair as ToPair0
  clone Cdsat_Theory_Impl3_Satisfies as Satisfies0 with function Interp0.interp = Interp0.interp,
  predicate Invariant0.invariant' = Invariant2.invariant', function Sort0.sort = Sort1.sort,
  function Sort1.sort = Sort0.sort
  clone CreusotContracts_Logic_Fset_Impl0_Contains as Contains0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl3_SatisfySet as SatisfySet0 with predicate Contains0.contains = Contains0.contains,
  predicate Satisfies0.satisfies = Satisfies0.satisfies
  clone Cdsat_Theory_Impl2_JustifiedSound as JustifiedSound0 with predicate Invariant0.invariant' = Invariant2.invariant',
  predicate SatisfySet0.satisfy_set = SatisfySet0.satisfy_set, predicate Satisfies0.satisfies = Satisfies0.satisfies
  clone Cdsat_Theory_Impl4_Len as Len0 with axiom .
  clone Cdsat_Theory_Impl4_InvariantAssign as InvariantAssign0 with predicate Invariant0.invariant' = Invariant3.invariant'
  clone Cdsat_Theory_Impl4_Level as Level0 with function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_InvariantNonneg as InvariantNonneg0 with function Level0.level = Level0.level,
  function Len0.len = Len0.len
  clone Cdsat_Theory_Impl4_Find as Find0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_Contains as Contains1 with predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign,
  function Sort0.sort = Sort0.sort, function Sort1.sort = Sort1.sort, function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_Sound as Sound1 with predicate JustifiedSound0.justified_sound = JustifiedSound0.justified_sound
  clone Cdsat_Theory_Impl4_FindJustified as FindJustified0 with predicate Sound0.sound = Sound1.sound,
  predicate Contains0.contains = Contains1.contains, function Find0.find = Find0.find,
  predicate JustifiedSound0.justified_sound = JustifiedSound0.justified_sound,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_TrailUnique as TrailUnique0 with function ToPair0.to_pair = ToPair0.to_pair,
  predicate Contains0.contains = Contains1.contains, predicate IsBool0.is_bool = IsBool0.is_bool,
  function Negate0.negate = Negate0.negate,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_InvariantContains as InvariantContains0 with predicate Contains0.contains = Contains0.contains,
  predicate Contains1.contains = Contains1.contains,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  clone Cdsat_Theory_Impl4_LevelOf as LevelOf0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function Level0.level = Level0.level, function Len0.len = Len0.len, function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, axiom .
  clone CreusotContracts_Logic_Fset_Impl0_Remove as Remove0 with type t = (Type.cdsat_theory_term, Type.cdsat_theory_value)
  clone Cdsat_Theory_Impl4_SetLevel as SetLevel0 with predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of,
  function Level0.level = Level0.level, function Len0.len = Len0.len, function Remove0.remove = Remove0.remove, axiom .
  clone Cdsat_Theory_Impl4_InvariantLevel as InvariantLevel0 with function Level0.level = Level0.level,
  function SetLevel0.set_level = SetLevel0.set_level, function Len0.len = Len0.len,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate Contains0.contains = Contains0.contains, function LevelOf0.level_of = LevelOf0.level_of
  clone Cdsat_Theory_Impl4_IsJustified as IsJustified0 with function Find0.find = Find0.find,
  function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function Len0.len = Len0.len
  clone Cdsat_Theory_Impl3_ResolveSound as ResolveSound0 with predicate SatisfySet0.satisfy_set = SatisfySet0.satisfy_set,
  predicate Satisfies0.satisfies = Satisfies0.satisfies, predicate Contains0.contains = Contains0.contains,
  function Remove0.remove = Remove0.remove, axiom .
  clone Cdsat_Theory_Impl4_Justification as Justification0 with predicate IsJustified0.is_justified = IsJustified0.is_justified,
  predicate Sound0.sound = Sound1.sound, predicate Invariant0.invariant' = Invariant2.invariant',
  predicate SatisfySet0.satisfy_set = SatisfySet0.satisfy_set, predicate Satisfies0.satisfies = Satisfies0.satisfies,
  function FindJustified0.find_justified = FindJustified0.find_justified, function Find0.find = Find0.find,
  predicate Contains0.contains = Contains1.contains,
  predicate JustifiedSound0.justified_sound = JustifiedSound0.justified_sound,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort, function ToPair0.to_pair = ToPair0.to_pair,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg, function Level0.level = Level0.level,
  function Len0.len = Len0.len, axiom .
  clone Cdsat_Theory_Impl4_Invariant as Invariant1 with predicate InvariantLevel0.invariant_level = InvariantLevel0.invariant_level,
  predicate InvariantContains0.invariant_contains = InvariantContains0.invariant_contains,
  predicate TrailUnique0.trail_unique = TrailUnique0.trail_unique,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign
  clone Cdsat_Theory_Impl6_Sound as Sound0 with predicate Sound0.sound = Sound1.sound,
  predicate Invariant0.invariant' = Invariant2.invariant', predicate SatisfySet0.satisfy_set = SatisfySet0.satisfy_set
  clone Cdsat_Theory_Impl6_Invariant as Invariant0 with function SetLevel0.set_level = SetLevel0.set_level,
  predicate Invariant0.invariant' = Invariant1.invariant', predicate Contains0.contains = Contains0.contains,
  predicate Contains1.contains = Contains1.contains,
  predicate InvariantNonneg0.invariant_nonneg = InvariantNonneg0.invariant_nonneg,
  function LevelOf0.level_of = LevelOf0.level_of, function Level0.level = Level0.level, function Len0.len = Len0.len,
  predicate InvariantAssign0.invariant_assign = InvariantAssign0.invariant_assign, function Sort0.sort = Sort0.sort,
  function Sort1.sort = Sort1.sort
  let rec ghost function resolve (self : Type.cdsat_theory_conflict) (a : (Type.cdsat_theory_term, Type.cdsat_theory_value)) (tgt : Type.cdsat_theory_conflict) : bool
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 673 15 673 31] Invariant0.invariant' self}
    requires {[#"/Users/xavier/Code/cdsat/src/theory.rs" 674 15 674 27] Sound0.sound self}
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 675 4 675 44] result -> Invariant1.invariant' (Type.cdsat_theory_conflict_Conflict_0 tgt) }
    ensures { [#"/Users/xavier/Code/cdsat/src/theory.rs" 676 4 676 38] result -> Sound0.sound tgt }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"/Users/xavier/Code/cdsat/src/theory.rs" 678 8 685 11] let just = let a' = Type.cdsat_theory_conflict_Conflict_0 self in Justification0.justification a' a in let _ = let b' = Type.cdsat_theory_conflict_Conflict_1 self in ResolveSound0.resolve_sound (Type.Cdsat_Theory_Model (Const.const (Type.Cdsat_Theory_Value_Bool false))) b' just a in (let a' = Type.cdsat_theory_conflict_Conflict_0 self in IsJustified0.is_justified a' a) && pure {forall a : ((Type.cdsat_theory_term, Type.cdsat_theory_value)) . Contains0.contains just a /\ not IsBool0.is_bool (let (_, a) = a in a) -> LevelOf0.level_of (Type.cdsat_theory_conflict_Conflict_0 self) a < SetLevel0.set_level (Type.cdsat_theory_conflict_Conflict_0 self) (Type.cdsat_theory_conflict_Conflict_1 self)} && (let a' = Type.cdsat_theory_conflict_Conflict_1 self in Contains0.contains a' a) && (let b = Type.Cdsat_Theory_Conflict (Type.cdsat_theory_conflict_Conflict_0 self) (let a' = let a' = Type.cdsat_theory_conflict_Conflict_1 self in Remove0.remove a' a in Fset.union a' just) in pure {tgt = b})
end
module Cdsat_Trail_Impl10
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = usize, type a = Type.alloc_alloc_global, axiom .
  clone Cdsat_Trail_Impl2_Model as Model5
  clone Cdsat_Trail_Impl1_Model as Model4 with function Model0.model = Model6.model
  clone Cdsat_Trail_Impl4_Model as Model3
  clone Cdsat_Trail_Impl3_Model as Model2 with function Model0.model = Model5.model,
  function Model1.model = Model3.model
  clone Cdsat_Trail_Impl0_Model as Model1 with function Model0.model = Model2.model,
  function Model1.model = Model3.model, function Model2.model = Model4.model
  clone Cdsat_Trail_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = Type.cdsat_trail_assignment,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model1.model
  clone Core_Cmp_PartialEq_Ne_Interface as Ne0 with type self = Type.cdsat_trail_assignment,
  type rhs = Type.cdsat_trail_assignment
  clone Cdsat_Trail_Impl10_Eq_Interface as Eq0 with function Model0.model = Model0.model
  clone Core_Cmp_PartialEq_Eq_Interface as Eq1 with type self = Type.cdsat_trail_assignment,
  type rhs = Type.cdsat_trail_assignment, val eq = Eq0.eq, function Model0.model = Model0.model,
  function Model1.model = Model0.model, type ModelTy0.modelTy = ModelTy0.modelTy
end
module Cdsat_Trail_Impl11
  
end
module Cdsat_Trail_Impl15
  
end
module Cdsat_Trail_Impl19
  
end
module Cdsat_Trail_Impl23
  
end
module Cdsat_Trail_Impl27
  
end
module Core_Cmp_Eq_AssertReceiverIsTotalEq_Interface
  type self
  use prelude.Prelude
  val assert_receiver_is_total_eq [@cfg:stackify] (self : self) : ()
    requires {false}
    
end
module Cdsat_Trail_Impl12
  use Type
  clone Cdsat_Trail_Impl12_AssertReceiverIsTotalEq_Interface as AssertReceiverIsTotalEq0
  clone Core_Cmp_Eq_AssertReceiverIsTotalEq_Interface as AssertReceiverIsTotalEq1 with type self = Type.cdsat_trail_assignment,
  val assert_receiver_is_total_eq = AssertReceiverIsTotalEq0.assert_receiver_is_total_eq
end
module Cdsat_Trail_Impl16
  use Type
  clone Cdsat_Trail_Impl16_AssertReceiverIsTotalEq_Interface as AssertReceiverIsTotalEq0
  clone Core_Cmp_Eq_AssertReceiverIsTotalEq_Interface as AssertReceiverIsTotalEq1 with type self = Type.cdsat_trail_reason,
  val assert_receiver_is_total_eq = AssertReceiverIsTotalEq0.assert_receiver_is_total_eq
end
module Cdsat_Trail_Impl20
  use Type
  clone Cdsat_Trail_Impl20_AssertReceiverIsTotalEq_Interface as AssertReceiverIsTotalEq0
  clone Core_Cmp_Eq_AssertReceiverIsTotalEq_Interface as AssertReceiverIsTotalEq1 with type self = Type.cdsat_trail_sort,
  val assert_receiver_is_total_eq = AssertReceiverIsTotalEq0.assert_receiver_is_total_eq
end
module Cdsat_Trail_Impl24
  use Type
  clone Cdsat_Trail_Impl24_AssertReceiverIsTotalEq_Interface as AssertReceiverIsTotalEq0
  clone Core_Cmp_Eq_AssertReceiverIsTotalEq_Interface as AssertReceiverIsTotalEq1 with type self = Type.cdsat_trail_term,
  val assert_receiver_is_total_eq = AssertReceiverIsTotalEq0.assert_receiver_is_total_eq
end
module Cdsat_Trail_Impl28
  use Type
  clone Cdsat_Trail_Impl28_AssertReceiverIsTotalEq_Interface as AssertReceiverIsTotalEq0
  clone Core_Cmp_Eq_AssertReceiverIsTotalEq_Interface as AssertReceiverIsTotalEq1 with type self = Type.cdsat_trail_value,
  val assert_receiver_is_total_eq = AssertReceiverIsTotalEq0.assert_receiver_is_total_eq
end
