
module Cdsat_Theory_Sort_Type
  type t_sort  =
    | C_Rational
    | C_Boolean
  
  function any_l (_ : 'b) : 'a
  
  let rec rational (input:t_sort) (ret  )= any
    [ good -> {C_Rational  = input} (! ret) | bad -> {C_Rational  <> input} {false} any ]
    
  
  let rec boolean (input:t_sort) (ret  )= any
    [ good -> {C_Boolean  = input} (! ret) | bad -> {C_Boolean  <> input} {false} any ]
    
end
module Cdsat_Theory_Var_Type
  use Cdsat_Theory_Sort_Type as Sort'0
  
  use prelude.prelude.Int
  
  type t_var  =
    | C_Var int (Sort'0.t_sort)
  
  function any_l (_ : 'b) : 'a
  
  let rec t_var (input:t_var) (ret  (field_0:int) (field_1:Sort'0.t_sort))= any
    [ good (field_0:int) (field_1:Sort'0.t_sort)-> {C_Var field_0 field_1 = input} (! ret {field_0} {field_1})
    | bad (field_0:int) (field_1:Sort'0.t_sort)-> {C_Var field_0 field_1 <> input} {false} any ]
    
  
  function var_1 (self : t_var) : Sort'0.t_sort =
    match self with
      | C_Var _ a -> a
      end
end
module Cdsat_Theory_Value_Type
  use prelude.prelude.Real
  
  type t_value  =
    | C_Bool bool
    | C_Rat (Real.real)
  
  function any_l (_ : 'b) : 'a
  
  let rec bool (input:t_value) (ret  (field_0:bool))= any
    [ good (field_0:bool)-> {C_Bool field_0 = input} (! ret {field_0})
    | bad (field_0:bool)-> {C_Bool field_0 <> input} {false} any ]
    
  
  let rec rat (input:t_value) (ret  (field_0:Real.real))= any
    [ good (field_0:Real.real)-> {C_Rat field_0 = input} (! ret {field_0})
    | bad (field_0:Real.real)-> {C_Rat field_0 <> input} {false} any ]
    
end
module Cdsat_Theory_Term_Type
  use Cdsat_Theory_Value_Type as Value'0
  
  use Cdsat_Theory_Var_Type as Var'0
  
  type t_term  =
    | C_Variable (Var'0.t_var)
    | C_Value (Value'0.t_value)
    | C_Plus (t_term) (t_term)
    | C_Eq (t_term) (t_term)
    | C_Conj (t_term) (t_term)
    | C_Disj (t_term) (t_term)
    | C_Neg (t_term)
  
  function any_l (_ : 'b) : 'a
  
  let rec variable (input:t_term) (ret  (field_0:Var'0.t_var))= any
    [ good (field_0:Var'0.t_var)-> {C_Variable field_0 = input} (! ret {field_0})
    | bad (field_0:Var'0.t_var)-> {C_Variable field_0 <> input} {false} any ]
    
  
  let rec value (input:t_term) (ret  (field_0:Value'0.t_value))= any
    [ good (field_0:Value'0.t_value)-> {C_Value field_0 = input} (! ret {field_0})
    | bad (field_0:Value'0.t_value)-> {C_Value field_0 <> input} {false} any ]
    
  
  let rec plus (input:t_term) (ret  (field_0:t_term) (field_1:t_term))= any
    [ good (field_0:t_term) (field_1:t_term)-> {C_Plus field_0 field_1 = input} (! ret {field_0} {field_1})
    | bad (field_0:t_term) (field_1:t_term)-> {C_Plus field_0 field_1 <> input} {false} any ]
    
  
  let rec eq (input:t_term) (ret  (field_0:t_term) (field_1:t_term))= any
    [ good (field_0:t_term) (field_1:t_term)-> {C_Eq field_0 field_1 = input} (! ret {field_0} {field_1})
    | bad (field_0:t_term) (field_1:t_term)-> {C_Eq field_0 field_1 <> input} {false} any ]
    
  
  let rec conj (input:t_term) (ret  (field_0:t_term) (field_1:t_term))= any
    [ good (field_0:t_term) (field_1:t_term)-> {C_Conj field_0 field_1 = input} (! ret {field_0} {field_1})
    | bad (field_0:t_term) (field_1:t_term)-> {C_Conj field_0 field_1 <> input} {false} any ]
    
  
  let rec disj (input:t_term) (ret  (field_0:t_term) (field_1:t_term))= any
    [ good (field_0:t_term) (field_1:t_term)-> {C_Disj field_0 field_1 = input} (! ret {field_0} {field_1})
    | bad (field_0:t_term) (field_1:t_term)-> {C_Disj field_0 field_1 <> input} {false} any ]
    
  
  let rec neg (input:t_term) (ret  (field_0:t_term))= any
    [ good (field_0:t_term)-> {C_Neg field_0 = input} (! ret {field_0})
    | bad (field_0:t_term)-> {C_Neg field_0 <> input} {false} any ]
    
end
module Cdsat_Theory_Assign_Type
  use Cdsat_Theory_Value_Type as Value'0
  
  use Cdsat_Theory_Term_Type as Term'0
  
  use set.Fset
  
  type t_assign  =
    | C_Decision (Term'0.t_term) (Value'0.t_value)
    | C_Justified (Fset.fset (Term'0.t_term, Value'0.t_value)) (Term'0.t_term) (Value'0.t_value)
    | C_Input (Term'0.t_term) (Value'0.t_value)
  
  function any_l (_ : 'b) : 'a
  
  let rec decision (input:t_assign) (ret  (field_0:Term'0.t_term) (field_1:Value'0.t_value))= any
    [ good (field_0:Term'0.t_term) (field_1:Value'0.t_value)-> {C_Decision field_0 field_1 = input}
      (! ret {field_0} {field_1})
    | bad (field_0:Term'0.t_term) (field_1:Value'0.t_value)-> {C_Decision field_0 field_1 <> input} {false} any ]
    
  
  let rec justified (input:t_assign) (ret  (field_0:Fset.fset (Term'0.t_term, Value'0.t_value)) (field_1:Term'0.t_term) (field_2:Value'0.t_value))= any
    [ good (field_0:Fset.fset (Term'0.t_term, Value'0.t_value)) (field_1:Term'0.t_term) (field_2:Value'0.t_value)-> {C_Justified field_0 field_1 field_2
      = input}
      (! ret {field_0} {field_1} {field_2})
    | bad (field_0:Fset.fset (Term'0.t_term, Value'0.t_value)) (field_1:Term'0.t_term) (field_2:Value'0.t_value)-> {C_Justified field_0 field_1 field_2
      <> input}
      {false}
      any ]
    
  
  let rec input (input:t_assign) (ret  (field_0:Term'0.t_term) (field_1:Value'0.t_value))= any
    [ good (field_0:Term'0.t_term) (field_1:Value'0.t_value)-> {C_Input field_0 field_1 = input}
      (! ret {field_0} {field_1})
    | bad (field_0:Term'0.t_term) (field_1:Value'0.t_value)-> {C_Input field_0 field_1 <> input} {false} any ]
    
end
module Cdsat_Theory_Trail_Type
  use prelude.prelude.Int
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  type t_trail  =
    | C_Empty
    | C_Assign (Assign'0.t_assign) int (t_trail)
  
  function any_l (_ : 'b) : 'a
  
  let rec empty (input:t_trail) (ret  )= any
    [ good -> {C_Empty  = input} (! ret) | bad -> {C_Empty  <> input} {false} any ]
    
  
  let rec assign (input:t_trail) (ret  (field_0:Assign'0.t_assign) (field_1:int) (field_2:t_trail))= any
    [ good (field_0:Assign'0.t_assign) (field_1:int) (field_2:t_trail)-> {C_Assign field_0 field_1 field_2 = input}
      (! ret {field_0} {field_1} {field_2})
    | bad (field_0:Assign'0.t_assign) (field_1:int) (field_2:t_trail)-> {C_Assign field_0 field_1 field_2 <> input}
      {false}
      any ]
    
end
module Cdsat_Theory_Model_Type
  use Cdsat_Theory_Value_Type as Value'0
  
  use Cdsat_Theory_Var_Type as Var'0
  
  use map.Map
  
  type t_model  =
    | C_Model (Map.map (Var'0.t_var) (Value'0.t_value))
  
  function any_l (_ : 'b) : 'a
  
  let rec t_model (input:t_model) (ret  (field_0:Map.map (Var'0.t_var) (Value'0.t_value)))= any
    [ good (field_0:Map.map (Var'0.t_var) (Value'0.t_value))-> {C_Model field_0 = input} (! ret {field_0})
    | bad (field_0:Map.map (Var'0.t_var) (Value'0.t_value))-> {C_Model field_0 <> input} {false} any ]
    
  
  function model_0 (self : t_model) : Map.map (Var'0.t_var) (Value'0.t_value) =
    match self with
      | C_Model a -> a
      end
end
module Cdsat_Theory_Impl5_Len_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  use prelude.prelude.Int
  
  constant self  : Trail'0.t_trail
  
  function len [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int
  
  goal vc_len : match self with
    | Trail'0.C_Empty -> [%#stheory0] 0 >= 0
    | Trail'0.C_Assign _ _ tl -> ([%#stheory0] len tl >= 0)  -> ([%#stheory0] len tl + 1 >= 0)
    end
end
module Cdsat_Theory_Impl5_Level_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span2 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span3 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  use prelude.prelude.Int
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span3] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span2] len'0 self >= 0
  
  constant self  : Trail'0.t_trail
  
  function level [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int
  
  goal vc_level : match self with
    | Trail'0.C_Empty -> let result = 0 in ([%#stheory1] result <= len'0 self) && ([%#stheory0] result >= 0)
    | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> ([%#stheory1] level tl <= len'0 tl)
    && ([%#stheory0] level tl >= 0)
     -> (let result = 1 + level tl in ([%#stheory1] result <= len'0 self) && ([%#stheory0] result >= 0))
    | Trail'0.C_Assign _ _ tl -> ([%#stheory1] level tl <= len'0 tl) && ([%#stheory0] level tl >= 0)
     -> (let result = level tl in ([%#stheory1] result <= len'0 self) && ([%#stheory0] result >= 0))
    end
end
module Cdsat_Theory_Impl5_Find_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 465 14 468 5
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 111
  
  let%span stheory2 = "/Users/xavier/Code/cdsat/src/theory.rs" 470 4 470 104
  
  let%span span3 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span4 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span5 = "/Users/xavier/Code/cdsat/src/theory.rs" 122 8 126 9
  
  let%span span6 = "/Users/xavier/Code/cdsat/src/theory.rs" 346 8 349 9
  
  let%span span7 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span8 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  let%span span9 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span span10 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span11 = "/Users/xavier/Code/cdsat/src/theory.rs" 601 8 605 9
  
  let%span span12 = "/Users/xavier/Code/cdsat/src/theory.rs" 337 8 340 9
  
  let%span span13 = "/Users/xavier/Code/cdsat/src/theory.rs" 132 8 136 9
  
  use Cdsat_Theory_Value_Type as Value'0
  
  use Cdsat_Theory_Term_Type as Term'0
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span3] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span4] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'1 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 121 4 121 34] (self : Assign'0.t_assign) =
    [%#span5] match self with
      | Assign'0.C_Decision t v -> sort'0 t = sort'1 v
      | Assign'0.C_Justified _ t v -> sort'0 t = sort'1 v /\ sort'0 t = Sort'0.C_Boolean
      | Assign'0.C_Input t v -> sort'0 t = sort'1 v
      end
  
  predicate invariant_assign'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 345 4 345 41] (self : Trail'0.t_trail) =
    [%#span6] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_assign'0 tl /\ invariant'0 a
      end
  
  use prelude.prelude.Int
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span8] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span7] len'0 self >= 0
  
  function level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int =
    [%#span11] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> 1 + level'0 tl
      | Trail'0.C_Assign _ _ tl -> level'0 tl
      end
  
  axiom level'0_spec : forall self : Trail'0.t_trail . ([%#span10] level'0 self <= len'0 self)
  && ([%#span9] level'0 self >= 0)
  
  predicate invariant_nonneg'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 336 4 336 41] (self : Trail'0.t_trail) =
    [%#span12] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_nonneg'0 tl /\ l >= 0 /\ l <= level'0 self
      end
  
  function to_pair'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 131 4 131 41] (self : Assign'0.t_assign) : (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span13] match self with
      | Assign'0.C_Decision t val' -> (t, val')
      | Assign'0.C_Input t val' -> (t, val')
      | Assign'0.C_Justified _ t val' -> (t, val')
      end
  
  use prelude.prelude.Int
  
  use Core_Option_Option_Type as Option'0
  
  constant self  : Trail'0.t_trail
  
  constant d  : (Term'0.t_term, Value'0.t_value)
  
  function find [#"/Users/xavier/Code/cdsat/src/theory.rs" 471 4 471 64] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Option'0.t_option (Assign'0.t_assign, int)
    
  
  goal vc_find : match self with
    | Trail'0.C_Empty -> let result = Option'0.C_None in ([%#stheory2] invariant_assign'0 self
     -> (forall p : (Assign'0.t_assign, int) . result = Option'0.C_Some p
     -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)))
    && ([%#stheory1] invariant_nonneg'0 self
     -> (forall p : (Assign'0.t_assign, int) . result = Option'0.C_Some p
     -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
    && ([%#stheory0] match result with
      | Option'0.C_Some (a, l) -> to_pair'0 a = d
      | _ -> true
      end)
    | Trail'0.C_Assign a l tl -> match to_pair'0 a = d with
      | True -> let result = Option'0.C_Some (a, l) in ([%#stheory2] invariant_assign'0 self
       -> (forall p : (Assign'0.t_assign, int) . result = Option'0.C_Some p
       -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)))
      && ([%#stheory1] invariant_nonneg'0 self
       -> (forall p : (Assign'0.t_assign, int) . result = Option'0.C_Some p
       -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
      && ([%#stheory0] match result with
        | Option'0.C_Some (a, l) -> to_pair'0 a = d
        | _ -> true
        end)
      | False -> ([%#stheory2] invariant_assign'0 tl
       -> (forall p : (Assign'0.t_assign, int) . find tl d = Option'0.C_Some p
       -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)))
      && ([%#stheory1] invariant_nonneg'0 tl
       -> (forall p : (Assign'0.t_assign, int) . find tl d = Option'0.C_Some p
       -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 tl))
      && ([%#stheory0] match find tl d with
        | Option'0.C_Some (a, l) -> to_pair'0 a = d
        | _ -> true
        end)
       -> (let result = find tl d in ([%#stheory2] invariant_assign'0 self
       -> (forall p : (Assign'0.t_assign, int) . result = Option'0.C_Some p
       -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)))
      && ([%#stheory1] invariant_nonneg'0 self
       -> (forall p : (Assign'0.t_assign, int) . result = Option'0.C_Some p
       -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
      && ([%#stheory0] match result with
        | Option'0.C_Some (a, l) -> to_pair'0 a = d
        | _ -> true
        end))
      end
    end
end
module Cdsat_Theory_Impl5_LevelOf_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 406 15 406 38
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 407 14 407 51
  
  let%span stheory2 = "/Users/xavier/Code/cdsat/src/theory.rs" 465 14 468 5
  
  let%span stheory3 = "/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 111
  
  let%span stheory4 = "/Users/xavier/Code/cdsat/src/theory.rs" 470 4 470 104
  
  let%span span5 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span6 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span7 = "/Users/xavier/Code/cdsat/src/theory.rs" 122 8 126 9
  
  let%span span8 = "/Users/xavier/Code/cdsat/src/theory.rs" 346 8 349 9
  
  let%span span9 = "/Users/xavier/Code/cdsat/src/theory.rs" 132 8 136 9
  
  let%span span10 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span11 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  let%span span12 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span span13 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span14 = "/Users/xavier/Code/cdsat/src/theory.rs" 601 8 605 9
  
  let%span span15 = "/Users/xavier/Code/cdsat/src/theory.rs" 337 8 340 9
  
  let%span span16 = "/Users/xavier/Code/cdsat/src/theory.rs" 472 8 481 9
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  use Cdsat_Theory_Value_Type as Value'0
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span5] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  use Cdsat_Theory_Term_Type as Term'0
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span6] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'1 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 121 4 121 34] (self : Assign'0.t_assign) =
    [%#span7] match self with
      | Assign'0.C_Decision t v -> sort'0 t = sort'1 v
      | Assign'0.C_Justified _ t v -> sort'0 t = sort'1 v /\ sort'0 t = Sort'0.C_Boolean
      | Assign'0.C_Input t v -> sort'0 t = sort'1 v
      end
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  predicate invariant_assign'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 345 4 345 41] (self : Trail'0.t_trail) =
    [%#span8] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_assign'0 tl /\ invariant'0 a
      end
  
  function to_pair'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 131 4 131 41] (self : Assign'0.t_assign) : (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span9] match self with
      | Assign'0.C_Decision t val' -> (t, val')
      | Assign'0.C_Input t val' -> (t, val')
      | Assign'0.C_Justified _ t val' -> (t, val')
      end
  
  use prelude.prelude.Int
  
  use Core_Option_Option_Type as Option'0
  
  use prelude.prelude.Int
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span11] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span10] len'0 self >= 0
  
  function level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int =
    [%#span14] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> 1 + level'0 tl
      | Trail'0.C_Assign _ _ tl -> level'0 tl
      end
  
  axiom level'0_spec : forall self : Trail'0.t_trail . ([%#span13] level'0 self <= len'0 self)
  && ([%#span12] level'0 self >= 0)
  
  predicate invariant_nonneg'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 336 4 336 41] (self : Trail'0.t_trail) =
    [%#span15] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_nonneg'0 tl /\ l >= 0 /\ l <= level'0 self
      end
  
  function find'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 471 4 471 64] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Option'0.t_option (Assign'0.t_assign, int)
    
   =
    [%#span16] match self with
      | Trail'0.C_Empty -> Option'0.C_None
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then Option'0.C_Some (a, l) else find'0 tl d
      end
  
  axiom find'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#stheory4] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)))
  && ([%#stheory3] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
  && ([%#stheory2] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
  
  constant self  : Trail'0.t_trail
  
  constant d  : (Term'0.t_term, Value'0.t_value)
  
  function level_of [#"/Users/xavier/Code/cdsat/src/theory.rs" 408 4 408 50] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : int
    
  
  goal vc_level_of : ([%#stheory0] invariant_nonneg'0 self)
   -> ([%#stheory4] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)))
  && ([%#stheory3] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
  && ([%#stheory2] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
   -> match find'0 self d with
    | Option'0.C_Some (_, l) -> let result = l in [%#stheory1] result >= 0 /\ result <= level'0 self
    | Option'0.C_None -> let result = 0 in [%#stheory1] result >= 0 /\ result <= level'0 self
    end
end
module Cdsat_Theory_Impl5_SetLevel_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 281 15 281 38
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 282 4 282 74
  
  let%span stheory2 = "/Users/xavier/Code/cdsat/src/theory.rs" 283 4 283 94
  
  let%span stheory3 = "/Users/xavier/Code/cdsat/src/theory.rs" 284 4 284 48
  
  let%span stheory4 = "/Users/xavier/Code/cdsat/src/theory.rs" 285 14 285 25
  
  let%span stheory5 = "/Users/xavier/Code/cdsat/src/theory.rs" 286 14 286 36
  
  let%span stheory6 = "/Users/xavier/Code/cdsat/src/theory.rs" 280 14 280 21
  
  let%span stheory7 = "/Users/xavier/Code/cdsat/src/theory.rs" 406 15 406 38
  
  let%span stheory8 = "/Users/xavier/Code/cdsat/src/theory.rs" 407 14 407 51
  
  let%span span9 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 53 8 53 26
  
  let%span span10 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span11 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  let%span span12 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span span13 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span14 = "/Users/xavier/Code/cdsat/src/theory.rs" 601 8 605 9
  
  let%span span15 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span16 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span17 = "/Users/xavier/Code/cdsat/src/theory.rs" 122 8 126 9
  
  let%span span18 = "/Users/xavier/Code/cdsat/src/theory.rs" 346 8 349 9
  
  let%span span19 = "/Users/xavier/Code/cdsat/src/theory.rs" 337 8 340 9
  
  let%span span20 = "/Users/xavier/Code/cdsat/src/theory.rs" 132 8 136 9
  
  let%span span21 = "/Users/xavier/Code/cdsat/src/theory.rs" 465 14 468 5
  
  let%span span22 = "/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 111
  
  let%span span23 = "/Users/xavier/Code/cdsat/src/theory.rs" 470 4 470 104
  
  let%span span24 = "/Users/xavier/Code/cdsat/src/theory.rs" 472 8 481 9
  
  let%span span25 = "/Users/xavier/Code/cdsat/src/theory.rs" 409 8 412 9
  
  let%span span26 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 16 8 16 26
  
  use set.Fset
  
  use Cdsat_Theory_Value_Type as Value'0
  
  use Cdsat_Theory_Term_Type as Term'0
  
  use set.Fset
  
  function remove'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (a : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span9] Fset.remove a self
  
  use set.Fset
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  use set.Fset
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  use prelude.prelude.Int
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span11] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span10] len'0 self >= 0
  
  function level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int =
    [%#span14] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> 1 + level'0 tl
      | Trail'0.C_Assign _ _ tl -> level'0 tl
      end
  
  axiom level'0_spec : forall self : Trail'0.t_trail . ([%#span13] level'0 self <= len'0 self)
  && ([%#span12] level'0 self >= 0)
  
  use set.Fset
  
  use prelude.prelude.Int
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span15] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span16] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'1 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 121 4 121 34] (self : Assign'0.t_assign) =
    [%#span17] match self with
      | Assign'0.C_Decision t v -> sort'0 t = sort'1 v
      | Assign'0.C_Justified _ t v -> sort'0 t = sort'1 v /\ sort'0 t = Sort'0.C_Boolean
      | Assign'0.C_Input t v -> sort'0 t = sort'1 v
      end
  
  predicate invariant_assign'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 345 4 345 41] (self : Trail'0.t_trail) =
    [%#span18] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_assign'0 tl /\ invariant'0 a
      end
  
  predicate invariant_nonneg'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 336 4 336 41] (self : Trail'0.t_trail) =
    [%#span19] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_nonneg'0 tl /\ l >= 0 /\ l <= level'0 self
      end
  
  function to_pair'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 131 4 131 41] (self : Assign'0.t_assign) : (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span20] match self with
      | Assign'0.C_Decision t val' -> (t, val')
      | Assign'0.C_Input t val' -> (t, val')
      | Assign'0.C_Justified _ t val' -> (t, val')
      end
  
  use Core_Option_Option_Type as Option'0
  
  function find'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 471 4 471 64] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Option'0.t_option (Assign'0.t_assign, int)
    
   =
    [%#span24] match self with
      | Trail'0.C_Empty -> Option'0.C_None
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then Option'0.C_Some (a, l) else find'0 tl d
      end
  
  axiom find'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span23] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)))
  && ([%#span22] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
  && ([%#span21] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
  
  function level_of'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 408 4 408 50] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : int
    
   =
    [%#span25] match find'0 self d with
      | Option'0.C_Some (_, l) -> l
      | Option'0.C_None -> 0
      end
  
  axiom level_of'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#stheory7] invariant_nonneg'0 self)
   -> ([%#stheory8] level_of'0 self d >= 0 /\ level_of'0 self d <= level'0 self)
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (e : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span26] Fset.mem e self
  
  constant self  : Trail'0.t_trail
  
  constant s  : Fset.fset (Term'0.t_term, Value'0.t_value)
  
  function set_level [#"/Users/xavier/Code/cdsat/src/theory.rs" 287 4 287 57] (self : Trail'0.t_trail) (s : Fset.fset (Term'0.t_term, Value'0.t_value)) : int
    
  
  goal vc_set_level : ([%#stheory0] invariant_nonneg'0 self)
   -> match Fset.cardinal s = 0 with
    | True -> let result = 0 in ([%#stheory5] result <= level'0 self)
    && ([%#stheory4] result >= 0)
    && ([%#stheory3] s = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))  -> result = 0)
    && ([%#stheory2] s <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
     -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'0 s i /\ level_of'0 self i = result))
    && ([%#stheory1] forall i : (Term'0.t_term, Value'0.t_value) . contains'0 s i  -> level_of'0 self i <= result)
    | False -> match Fset.cardinal s = 1 with
      | True -> ([%#stheory7] invariant_nonneg'0 self)
      /\ (([%#stheory8] level_of'0 self (Fset.pick s) >= 0 /\ level_of'0 self (Fset.pick s) <= level'0 self)
       -> (let result = level_of'0 self (Fset.pick s) in ([%#stheory5] result <= level'0 self)
      && ([%#stheory4] result >= 0)
      && ([%#stheory3] s = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))  -> result = 0)
      && ([%#stheory2] s <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
       -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'0 s i /\ level_of'0 self i = result))
      && ([%#stheory1] forall i : (Term'0.t_term, Value'0.t_value) . contains'0 s i  -> level_of'0 self i <= result)))
      | False -> let a = Fset.pick s in (([%#stheory0] invariant_nonneg'0 self)
      /\ 0 <= ([%#stheory6] Fset.cardinal s)
      /\ ([%#stheory6] Fset.cardinal (remove'0 s a)) < ([%#stheory6] Fset.cardinal s))
      /\ (([%#stheory5] set_level self (remove'0 s a) <= level'0 self)
      && ([%#stheory4] set_level self (remove'0 s a) >= 0)
      && ([%#stheory3] remove'0 s a = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
       -> set_level self (remove'0 s a) = 0)
      && ([%#stheory2] remove'0 s a <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
       -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'0 (remove'0 s a) i
      /\ level_of'0 self i = set_level self (remove'0 s a)))
      && ([%#stheory1] forall i : (Term'0.t_term, Value'0.t_value) . contains'0 (remove'0 s a) i
       -> level_of'0 self i <= set_level self (remove'0 s a))
       -> (let rec' = set_level self (remove'0 s a) in ([%#stheory7] invariant_nonneg'0 self)
      /\ (([%#stheory8] level_of'0 self a >= 0 /\ level_of'0 self a <= level'0 self)
       -> match level_of'0 self a >= rec' with
        | True -> ([%#stheory7] invariant_nonneg'0 self)
        /\ (([%#stheory8] level_of'0 self a >= 0 /\ level_of'0 self a <= level'0 self)
         -> (let result = level_of'0 self a in ([%#stheory5] result <= level'0 self)
        && ([%#stheory4] result >= 0)
        && ([%#stheory3] s = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))  -> result = 0)
        && ([%#stheory2] s <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
         -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'0 s i /\ level_of'0 self i = result))
        && ([%#stheory1] forall i : (Term'0.t_term, Value'0.t_value) . contains'0 s i  -> level_of'0 self i <= result)))
        | False -> let result = rec' in ([%#stheory5] result <= level'0 self)
        && ([%#stheory4] result >= 0)
        && ([%#stheory3] s = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))  -> result = 0)
        && ([%#stheory2] s <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
         -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'0 s i /\ level_of'0 self i = result))
        && ([%#stheory1] forall i : (Term'0.t_term, Value'0.t_value) . contains'0 s i  -> level_of'0 self i <= result)
        end)))
      end
    end
end
module Cdsat_Theory_Impl5_Contains_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 417 4 417 87
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 465 14 468 5
  
  let%span stheory2 = "/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 111
  
  let%span stheory3 = "/Users/xavier/Code/cdsat/src/theory.rs" 470 4 470 104
  
  let%span span4 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span5 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  let%span span6 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span span7 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span8 = "/Users/xavier/Code/cdsat/src/theory.rs" 601 8 605 9
  
  let%span span9 = "/Users/xavier/Code/cdsat/src/theory.rs" 337 8 340 9
  
  let%span span10 = "/Users/xavier/Code/cdsat/src/theory.rs" 132 8 136 9
  
  let%span span11 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span12 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span13 = "/Users/xavier/Code/cdsat/src/theory.rs" 122 8 126 9
  
  let%span span14 = "/Users/xavier/Code/cdsat/src/theory.rs" 346 8 349 9
  
  let%span span15 = "/Users/xavier/Code/cdsat/src/theory.rs" 472 8 481 9
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  use prelude.prelude.Int
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span5] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span4] len'0 self >= 0
  
  function level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int =
    [%#span8] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> 1 + level'0 tl
      | Trail'0.C_Assign _ _ tl -> level'0 tl
      end
  
  axiom level'0_spec : forall self : Trail'0.t_trail . ([%#span7] level'0 self <= len'0 self)
  && ([%#span6] level'0 self >= 0)
  
  predicate invariant_nonneg'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 336 4 336 41] (self : Trail'0.t_trail) =
    [%#span9] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_nonneg'0 tl /\ l >= 0 /\ l <= level'0 self
      end
  
  use Cdsat_Theory_Value_Type as Value'0
  
  use Cdsat_Theory_Term_Type as Term'0
  
  function to_pair'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 131 4 131 41] (self : Assign'0.t_assign) : (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span10] match self with
      | Assign'0.C_Decision t val' -> (t, val')
      | Assign'0.C_Input t val' -> (t, val')
      | Assign'0.C_Justified _ t val' -> (t, val')
      end
  
  use prelude.prelude.Int
  
  use Core_Option_Option_Type as Option'0
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span11] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span12] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'1 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 121 4 121 34] (self : Assign'0.t_assign) =
    [%#span13] match self with
      | Assign'0.C_Decision t v -> sort'0 t = sort'1 v
      | Assign'0.C_Justified _ t v -> sort'0 t = sort'1 v /\ sort'0 t = Sort'0.C_Boolean
      | Assign'0.C_Input t v -> sort'0 t = sort'1 v
      end
  
  predicate invariant_assign'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 345 4 345 41] (self : Trail'0.t_trail) =
    [%#span14] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_assign'0 tl /\ invariant'0 a
      end
  
  function find'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 471 4 471 64] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Option'0.t_option (Assign'0.t_assign, int)
    
   =
    [%#span15] match self with
      | Trail'0.C_Empty -> Option'0.C_None
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then Option'0.C_Some (a, l) else find'0 tl d
      end
  
  axiom find'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#stheory3] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)))
  && ([%#stheory2] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
  && ([%#stheory1] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
  
  constant self  : Trail'0.t_trail
  
  constant d  : (Term'0.t_term, Value'0.t_value)
  
  predicate contains [#"/Users/xavier/Code/cdsat/src/theory.rs" 418 4 418 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
  
  goal vc_contains : ([%#stheory3] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)))
  && ([%#stheory2] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
  && ([%#stheory1] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
   -> match find'0 self d with
    | Option'0.C_Some ix -> [%#stheory0] invariant_assign'0 self
     -> true = true  -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)
    | Option'0.C_None -> [%#stheory0] invariant_assign'0 self
     -> false = true  -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)
    end
end
module Cdsat_Theory_Impl1_Negate_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 96 15 96 29
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 97 14 97 30
  
  let%span span2 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span3 = "/Users/xavier/Code/cdsat/src/theory.rs" 82 8 82 36
  
  use Cdsat_Theory_Value_Type as Value'0
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span2] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  predicate is_bool'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 81 4 81 32] (self : Value'0.t_value) =
    [%#span3] sort'0 self = Sort'0.C_Boolean
  
  constant self  : Value'0.t_value
  
  function negate [#"/Users/xavier/Code/cdsat/src/theory.rs" 98 4 98 31] (self : Value'0.t_value) : Value'0.t_value
  
  goal vc_negate : ([%#stheory0] is_bool'0 self)
   -> match self with
    | Value'0.C_Bool b -> [%#stheory1] is_bool'0 (Value'0.C_Bool (not b))
    | _ -> [%#stheory1] is_bool'0 self
    end
end
module Cdsat_Theory_Impl5_CountBounds_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 741 15 741 31
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 742 4 742 83
  
  let%span span2 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span3 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  let%span span4 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span span5 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span6 = "/Users/xavier/Code/cdsat/src/theory.rs" 601 8 605 9
  
  let%span span7 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span8 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span9 = "/Users/xavier/Code/cdsat/src/theory.rs" 122 8 126 9
  
  let%span span10 = "/Users/xavier/Code/cdsat/src/theory.rs" 346 8 349 9
  
  let%span span11 = "/Users/xavier/Code/cdsat/src/theory.rs" 337 8 340 9
  
  let%span span12 = "/Users/xavier/Code/cdsat/src/theory.rs" 132 8 136 9
  
  let%span span13 = "/Users/xavier/Code/cdsat/src/theory.rs" 465 14 468 5
  
  let%span span14 = "/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 111
  
  let%span span15 = "/Users/xavier/Code/cdsat/src/theory.rs" 470 4 470 104
  
  let%span span16 = "/Users/xavier/Code/cdsat/src/theory.rs" 472 8 481 9
  
  let%span span17 = "/Users/xavier/Code/cdsat/src/theory.rs" 406 15 406 38
  
  let%span span18 = "/Users/xavier/Code/cdsat/src/theory.rs" 407 14 407 51
  
  let%span span19 = "/Users/xavier/Code/cdsat/src/theory.rs" 409 8 412 9
  
  let%span span20 = "/Users/xavier/Code/cdsat/src/theory.rs" 417 4 417 87
  
  let%span span21 = "/Users/xavier/Code/cdsat/src/theory.rs" 419 8 422 9
  
  let%span span22 = "/Users/xavier/Code/cdsat/src/theory.rs" 82 8 82 36
  
  let%span span23 = "/Users/xavier/Code/cdsat/src/theory.rs" 96 15 96 29
  
  let%span span24 = "/Users/xavier/Code/cdsat/src/theory.rs" 97 14 97 30
  
  let%span span25 = "/Users/xavier/Code/cdsat/src/theory.rs" 99 8 102 9
  
  let%span span26 = "/Users/xavier/Code/cdsat/src/theory.rs" 374 8 382 9
  
  let%span span27 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 16 8 16 26
  
  let%span span28 = "/Users/xavier/Code/cdsat/src/theory.rs" 355 8 368 9
  
  let%span span29 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 53 8 53 26
  
  let%span span30 = "/Users/xavier/Code/cdsat/src/theory.rs" 281 15 281 38
  
  let%span span31 = "/Users/xavier/Code/cdsat/src/theory.rs" 282 4 282 74
  
  let%span span32 = "/Users/xavier/Code/cdsat/src/theory.rs" 283 4 283 94
  
  let%span span33 = "/Users/xavier/Code/cdsat/src/theory.rs" 284 4 284 48
  
  let%span span34 = "/Users/xavier/Code/cdsat/src/theory.rs" 285 14 285 25
  
  let%span span35 = "/Users/xavier/Code/cdsat/src/theory.rs" 286 14 286 36
  
  let%span span36 = "/Users/xavier/Code/cdsat/src/theory.rs" 280 14 280 21
  
  let%span span37 = "/Users/xavier/Code/cdsat/src/theory.rs" 278 4 278 12
  
  let%span span38 = "/Users/xavier/Code/cdsat/src/theory.rs" 321 8 331 9
  
  let%span span39 = "/Users/xavier/Code/cdsat/src/theory.rs" 388 8 392 38
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  use prelude.prelude.Int
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span3] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span2] len'0 self >= 0
  
  function level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int =
    [%#span6] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> 1 + level'0 tl
      | Trail'0.C_Assign _ _ tl -> level'0 tl
      end
  
  axiom level'0_spec : forall self : Trail'0.t_trail . ([%#span5] level'0 self <= len'0 self)
  && ([%#span4] level'0 self >= 0)
  
  use prelude.prelude.Int
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  use Cdsat_Theory_Value_Type as Value'0
  
  use Cdsat_Theory_Term_Type as Term'0
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span7] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span8] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'1 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  predicate invariant'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 121 4 121 34] (self : Assign'0.t_assign) =
    [%#span9] match self with
      | Assign'0.C_Decision t v -> sort'0 t = sort'1 v
      | Assign'0.C_Justified _ t v -> sort'0 t = sort'1 v /\ sort'0 t = Sort'0.C_Boolean
      | Assign'0.C_Input t v -> sort'0 t = sort'1 v
      end
  
  predicate invariant_assign'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 345 4 345 41] (self : Trail'0.t_trail) =
    [%#span10] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_assign'0 tl /\ invariant'1 a
      end
  
  predicate invariant_nonneg'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 336 4 336 41] (self : Trail'0.t_trail) =
    [%#span11] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_nonneg'0 tl /\ l >= 0 /\ l <= level'0 self
      end
  
  function to_pair'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 131 4 131 41] (self : Assign'0.t_assign) : (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span12] match self with
      | Assign'0.C_Decision t val' -> (t, val')
      | Assign'0.C_Input t val' -> (t, val')
      | Assign'0.C_Justified _ t val' -> (t, val')
      end
  
  use Core_Option_Option_Type as Option'0
  
  function find'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 471 4 471 64] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Option'0.t_option (Assign'0.t_assign, int)
    
   =
    [%#span16] match self with
      | Trail'0.C_Empty -> Option'0.C_None
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then Option'0.C_Some (a, l) else find'0 tl d
      end
  
  axiom find'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span15] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)))
  && ([%#span14] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
  && ([%#span13] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
  
  function level_of'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 408 4 408 50] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : int
    
   =
    [%#span19] match find'0 self d with
      | Option'0.C_Some (_, l) -> l
      | Option'0.C_None -> 0
      end
  
  axiom level_of'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span17] invariant_nonneg'0 self)
   -> ([%#span18] level_of'0 self d >= 0 /\ level_of'0 self d <= level'0 self)
  
  predicate contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 418 4 418 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span21] match find'0 self d with
      | Option'0.C_Some ix -> true
      | Option'0.C_None -> false
      end
  
  axiom contains'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . [%#span20] invariant_assign'0 self
   -> contains'0 self d = true  -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)
  
  predicate is_bool'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 81 4 81 32] (self : Value'0.t_value) =
    [%#span22] sort'1 self = Sort'0.C_Boolean
  
  function negate'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 98 4 98 31] (self : Value'0.t_value) : Value'0.t_value =
    [%#span25] match self with
      | Value'0.C_Bool b -> Value'0.C_Bool (not b)
      | _ -> self
      end
  
  axiom negate'0_spec : forall self : Value'0.t_value . ([%#span23] is_bool'0 self)
   -> ([%#span24] is_bool'0 (negate'0 self))
  
  predicate trail_unique'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 373 4 373 37] (self : Trail'0.t_trail) =
    [%#span26] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> let ap = to_pair'0 a in not contains'0 tl ap
      /\ trail_unique'0 tl
      /\ (if is_bool'0 (let (_, a) = ap in a) then
        not contains'0 tl ((let (a, _) = ap in a), negate'0 (let (_, a) = ap in a))
      else
        true
      )
      end
  
  use set.Fset
  
  use set.Fset
  
  predicate contains'1 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (e : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span27] Fset.mem e self
  
  predicate invariant_contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 354 4 354 43] (self : Trail'0.t_trail) =
    [%#span28] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_contains'0 tl
      /\ match a with
        | Assign'0.C_Justified j _ _ -> forall a : (Term'0.t_term, Value'0.t_value) . contains'1 j a  -> contains'0 tl a
        | _ -> true
        end
      end
  
  use set.Fset
  
  function remove'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (a : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span29] Fset.remove a self
  
  use set.Fset
  
  use set.Fset
  
  use set.Fset
  
  function set_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 287 4 287 57] (self : Trail'0.t_trail) (s : Fset.fset (Term'0.t_term, Value'0.t_value)) : int
    
  
  axiom set_level'0_def : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . set_level'0 self s
  = ([%#span37] if Fset.cardinal s = 0 then
    0
  else
    if Fset.cardinal s = 1 then
      level_of'0 self (Fset.pick s)
    else
      let a = Fset.pick s in let rec' = set_level'0 self (remove'0 s a) in if level_of'0 self a >= rec' then
        level_of'0 self a
      else
        rec'
      
    
  )
  
  axiom set_level'0_spec : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . ([%#span30] invariant_nonneg'0 self)
   -> ([%#span35] set_level'0 self s <= level'0 self)
  && ([%#span34] set_level'0 self s >= 0)
  && ([%#span33] s = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))  -> set_level'0 self s = 0)
  && ([%#span32] s <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
   -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'1 s i /\ level_of'0 self i = set_level'0 self s))
  && ([%#span31] forall i : (Term'0.t_term, Value'0.t_value) . contains'1 s i
   -> level_of'0 self i <= set_level'0 self s)
  
  predicate invariant_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 320 4 320 40] (self : Trail'0.t_trail) =
    [%#span38] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_level'0 tl
      /\ match a with
        | Assign'0.C_Input _ _ -> l = 0
        | Assign'0.C_Decision _ _ -> level'0 tl + 1 = l
        | Assign'0.C_Justified j _ _ -> set_level'0 tl j = l
        end
      end
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 387 4 387 34] (self : Trail'0.t_trail) =
    [%#span39] invariant_level'0 self
    /\ invariant_contains'0 self /\ trail_unique'0 self /\ invariant_nonneg'0 self /\ invariant_assign'0 self
  
  constant self  : Trail'0.t_trail
  
  function count_bounds [#"/Users/xavier/Code/cdsat/src/theory.rs" 743 4 743 35] (self : Trail'0.t_trail) : ()
  
  goal vc_count_bounds : ([%#stheory0] invariant'0 self)
   -> match self with
    | Trail'0.C_Empty -> [%#stheory1] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 self a
     -> level_of'0 self a <= level'0 self
    | Trail'0.C_Assign (Assign'0.C_Input _ _) _ tl -> ([%#stheory0] invariant'0 tl)
    /\ (([%#stheory1] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 tl a  -> level_of'0 tl a <= level'0 tl)
     -> ([%#stheory1] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 self a
     -> level_of'0 self a <= level'0 self))
    | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> ([%#stheory0] invariant'0 tl)
    /\ (([%#stheory1] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 tl a  -> level_of'0 tl a <= level'0 tl)
     -> ([%#stheory1] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 self a
     -> level_of'0 self a <= level'0 self))
    | Trail'0.C_Assign (Assign'0.C_Justified _ _ _) _ tl -> ([%#stheory0] invariant'0 tl)
    /\ (([%#stheory1] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 tl a  -> level_of'0 tl a <= level'0 tl)
     -> ([%#stheory1] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 self a
     -> level_of'0 self a <= level'0 self))
    end
end
module Cdsat_Theory_Impl4_Interp_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 167 18 167 22
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 166 4 166 62
  
  let%span span2 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span3 = "/Users/xavier/Code/cdsat/src/theory.rs" 157 8 159 9
  
  let%span span4 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  use Cdsat_Theory_Value_Type as Value'0
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span2] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  use map.Map
  
  use Cdsat_Theory_Model_Type as Cdsat_Theory_Model_Type
  
  use Cdsat_Theory_Var_Type as Var'0
  
  use Cdsat_Theory_Model_Type as Model'0
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 156 4 156 30] (self : Model'0.t_model) =
    [%#span3] forall v : Value'0.t_value . forall k : Var'0.t_var . Map.get (Cdsat_Theory_Model_Type.model_0 self) k = v
     -> Cdsat_Theory_Var_Type.var_1 k = sort'0 v
  
  predicate inv'0 (_x : Model'0.t_model)
  
  axiom inv'0 : forall x : Model'0.t_model . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Model'0.C_Model a_0 -> true
    end)
  
  use prelude.prelude.Real
  
  use prelude.prelude.Int
  
  function from_int'0 (_1 : int) : Real.real
  
  use map.Map
  
  use Cdsat_Theory_Term_Type as Term'0
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span4] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'0 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  constant self  : Model'0.t_model
  
  constant t  : Term'0.t_term
  
  function interp [#"/Users/xavier/Code/cdsat/src/theory.rs" 167 4 167 41] (self : Model'0.t_model) (t : Term'0.t_term) : Value'0.t_value
    
  
  goal vc_interp : ([%#stheory0] inv'0 self)
   -> match t with
    | Term'0.C_Variable v -> [%#stheory1] invariant'0 self
     -> sort'0 (Map.get (Cdsat_Theory_Model_Type.model_0 self) v) = sort'1 t
    | Term'0.C_Value v -> [%#stheory1] invariant'0 self  -> sort'0 v = sort'1 t
    | Term'0.C_Plus l r -> ([%#stheory0] inv'0 self)
    /\ (([%#stheory1] invariant'0 self  -> sort'0 (interp self l) = sort'1 l)
     -> ([%#stheory0] inv'0 self)
    /\ (([%#stheory1] invariant'0 self  -> sort'0 (interp self r) = sort'1 r)
     -> match (interp self l, interp self r) with
      | (Value'0.C_Rat r1, Value'0.C_Rat r2) -> [%#stheory1] invariant'0 self  -> sort'0 (Value'0.C_Rat r1) = sort'1 t
      | _ -> [%#stheory1] invariant'0 self  -> sort'0 (Value'0.C_Rat (from_int'0 (- 1))) = sort'1 t
      end))
    | Term'0.C_Conj l r -> ([%#stheory0] inv'0 self)
    /\ (([%#stheory1] invariant'0 self  -> sort'0 (interp self l) = sort'1 l)
     -> ([%#stheory0] inv'0 self)
    /\ (([%#stheory1] invariant'0 self  -> sort'0 (interp self r) = sort'1 r)
     -> match (interp self l, interp self r) with
      | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> if b1 then
        [%#stheory1] invariant'0 self  -> sort'0 (Value'0.C_Bool b2) = sort'1 t
      else
        [%#stheory1] invariant'0 self  -> sort'0 (Value'0.C_Bool false) = sort'1 t
      
      | _ -> [%#stheory1] invariant'0 self  -> sort'0 (Value'0.C_Bool false) = sort'1 t
      end))
    | Term'0.C_Disj l r -> ([%#stheory0] inv'0 self)
    /\ (([%#stheory1] invariant'0 self  -> sort'0 (interp self l) = sort'1 l)
     -> ([%#stheory0] inv'0 self)
    /\ (([%#stheory1] invariant'0 self  -> sort'0 (interp self r) = sort'1 r)
     -> match (interp self l, interp self r) with
      | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> [%#stheory1] invariant'0 self
       -> sort'0 (Value'0.C_Bool (b1 \/ b2)) = sort'1 t
      | _ -> [%#stheory1] invariant'0 self  -> sort'0 (Value'0.C_Bool false) = sort'1 t
      end))
    | Term'0.C_Eq l r -> ([%#stheory0] inv'0 self)
    /\ (([%#stheory1] invariant'0 self  -> sort'0 (interp self l) = sort'1 l)
     -> ([%#stheory0] inv'0 self)
    /\ (([%#stheory1] invariant'0 self  -> sort'0 (interp self r) = sort'1 r)
     -> ([%#stheory1] invariant'0 self  -> sort'0 (Value'0.C_Bool (interp self l = interp self r)) = sort'1 t)))
    | Term'0.C_Neg t -> ([%#stheory0] inv'0 self)
    /\ (([%#stheory1] invariant'0 self  -> sort'0 (interp self t) = sort'1 t)
     -> match interp self t with
      | Value'0.C_Bool b -> [%#stheory1] invariant'0 self  -> sort'0 (Value'0.C_Bool (not b)) = sort'1 t
      | _ -> [%#stheory1] invariant'0 self  -> sort'0 (Value'0.C_Bool false) = sort'1 t
      end)
    end
end
module Cdsat_Theory_Impl5_Impls_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 696 4 696 55
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 698 8 698 108
  
  let%span span2 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span3 = "/Users/xavier/Code/cdsat/src/theory.rs" 157 8 159 9
  
  let%span span4 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span5 = "/Users/xavier/Code/cdsat/src/theory.rs" 167 18 167 22
  
  let%span span6 = "/Users/xavier/Code/cdsat/src/theory.rs" 166 4 166 62
  
  let%span span7 = "/Users/xavier/Code/cdsat/src/theory.rs" 168 8 188 9
  
  let%span span8 = "/Users/xavier/Code/cdsat/src/theory.rs" 194 8 194 31
  
  let%span span9 = "/Users/xavier/Code/cdsat/src/theory.rs" 122 8 126 9
  
  let%span span10 = "/Users/xavier/Code/cdsat/src/theory.rs" 346 8 349 9
  
  let%span span11 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span12 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  let%span span13 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span span14 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span15 = "/Users/xavier/Code/cdsat/src/theory.rs" 601 8 605 9
  
  let%span span16 = "/Users/xavier/Code/cdsat/src/theory.rs" 337 8 340 9
  
  let%span span17 = "/Users/xavier/Code/cdsat/src/theory.rs" 132 8 136 9
  
  let%span span18 = "/Users/xavier/Code/cdsat/src/theory.rs" 465 14 468 5
  
  let%span span19 = "/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 111
  
  let%span span20 = "/Users/xavier/Code/cdsat/src/theory.rs" 470 4 470 104
  
  let%span span21 = "/Users/xavier/Code/cdsat/src/theory.rs" 472 8 481 9
  
  let%span span22 = "/Users/xavier/Code/cdsat/src/theory.rs" 417 4 417 87
  
  let%span span23 = "/Users/xavier/Code/cdsat/src/theory.rs" 419 8 422 9
  
  let%span span24 = "/Users/xavier/Code/cdsat/src/theory.rs" 678 8 678 71
  
  let%span span25 = "/Users/xavier/Code/cdsat/src/theory.rs" 406 15 406 38
  
  let%span span26 = "/Users/xavier/Code/cdsat/src/theory.rs" 407 14 407 51
  
  let%span span27 = "/Users/xavier/Code/cdsat/src/theory.rs" 409 8 412 9
  
  let%span span28 = "/Users/xavier/Code/cdsat/src/theory.rs" 82 8 82 36
  
  let%span span29 = "/Users/xavier/Code/cdsat/src/theory.rs" 96 15 96 29
  
  let%span span30 = "/Users/xavier/Code/cdsat/src/theory.rs" 97 14 97 30
  
  let%span span31 = "/Users/xavier/Code/cdsat/src/theory.rs" 99 8 102 9
  
  let%span span32 = "/Users/xavier/Code/cdsat/src/theory.rs" 374 8 382 9
  
  let%span span33 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 16 8 16 26
  
  let%span span34 = "/Users/xavier/Code/cdsat/src/theory.rs" 355 8 368 9
  
  let%span span35 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 53 8 53 26
  
  let%span span36 = "/Users/xavier/Code/cdsat/src/theory.rs" 281 15 281 38
  
  let%span span37 = "/Users/xavier/Code/cdsat/src/theory.rs" 282 4 282 74
  
  let%span span38 = "/Users/xavier/Code/cdsat/src/theory.rs" 283 4 283 94
  
  let%span span39 = "/Users/xavier/Code/cdsat/src/theory.rs" 284 4 284 48
  
  let%span span40 = "/Users/xavier/Code/cdsat/src/theory.rs" 285 14 285 25
  
  let%span span41 = "/Users/xavier/Code/cdsat/src/theory.rs" 286 14 286 36
  
  let%span span42 = "/Users/xavier/Code/cdsat/src/theory.rs" 280 14 280 21
  
  let%span span43 = "/Users/xavier/Code/cdsat/src/theory.rs" 278 4 278 12
  
  let%span span44 = "/Users/xavier/Code/cdsat/src/theory.rs" 321 8 331 9
  
  let%span span45 = "/Users/xavier/Code/cdsat/src/theory.rs" 388 8 392 38
  
  let%span span46 = "/Users/xavier/Code/cdsat/src/theory.rs" 741 15 741 31
  
  let%span span47 = "/Users/xavier/Code/cdsat/src/theory.rs" 742 4 742 83
  
  let%span span48 = "/Users/xavier/Code/cdsat/src/theory.rs" 744 8 749 9
  
  let%span span49 = "/Users/xavier/Code/cdsat/src/theory.rs" 562 8 573 9
  
  let%span span50 = "/Users/xavier/Code/cdsat/src/theory.rs" 685 8 685 82
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  use Cdsat_Theory_Value_Type as Value'0
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span2] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  use map.Map
  
  use Cdsat_Theory_Model_Type as Cdsat_Theory_Model_Type
  
  use Cdsat_Theory_Var_Type as Var'0
  
  use Cdsat_Theory_Model_Type as Model'0
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 156 4 156 30] (self : Model'0.t_model) =
    [%#span3] forall v : Value'0.t_value . forall k : Var'0.t_var . Map.get (Cdsat_Theory_Model_Type.model_0 self) k = v
     -> Cdsat_Theory_Var_Type.var_1 k = sort'1 v
  
  predicate inv'0 (_x : Model'0.t_model)
  
  axiom inv'0 : forall x : Model'0.t_model . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Model'0.C_Model a_0 -> true
    end)
  
  use prelude.prelude.Real
  
  use prelude.prelude.Int
  
  function from_int'0 (_1 : int) : Real.real
  
  use Cdsat_Theory_Term_Type as Term'0
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span4] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'1 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  function interp'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 167 4 167 41] (self : Model'0.t_model) (t : Term'0.t_term) : Value'0.t_value
    
   =
    [%#span7] match t with
      | Term'0.C_Variable v -> Map.get (Cdsat_Theory_Model_Type.model_0 self) v
      | Term'0.C_Value v -> v
      | Term'0.C_Plus l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Rat r1, Value'0.C_Rat r2) -> Value'0.C_Rat r1
        | _ -> Value'0.C_Rat (from_int'0 (- 1))
        end
      | Term'0.C_Conj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 /\ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Disj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 \/ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Eq l r -> Value'0.C_Bool (interp'0 self l = interp'0 self r)
      | Term'0.C_Neg t -> match interp'0 self t with
        | Value'0.C_Bool b -> Value'0.C_Bool (not b)
        | _ -> Value'0.C_Bool false
        end
      end
  
  axiom interp'0_spec : forall self : Model'0.t_model, t : Term'0.t_term . ([%#span5] inv'0 self)
   -> ([%#span6] invariant'0 self  -> sort'1 (interp'0 self t) = sort'0 t)
  
  predicate satisfies'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 193 4 193 52] (self : Model'0.t_model) (v : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span8] interp'0 self (let (a, _) = v in a) = (let (_, a) = v in a)
  
  use prelude.prelude.Int
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  predicate invariant'2 [#"/Users/xavier/Code/cdsat/src/theory.rs" 121 4 121 34] (self : Assign'0.t_assign) =
    [%#span9] match self with
      | Assign'0.C_Decision t v -> sort'0 t = sort'1 v
      | Assign'0.C_Justified _ t v -> sort'0 t = sort'1 v /\ sort'0 t = Sort'0.C_Boolean
      | Assign'0.C_Input t v -> sort'0 t = sort'1 v
      end
  
  predicate invariant_assign'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 345 4 345 41] (self : Trail'0.t_trail) =
    [%#span10] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_assign'0 tl /\ invariant'2 a
      end
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span12] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span11] len'0 self >= 0
  
  function level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int =
    [%#span15] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> 1 + level'0 tl
      | Trail'0.C_Assign _ _ tl -> level'0 tl
      end
  
  axiom level'0_spec : forall self : Trail'0.t_trail . ([%#span14] level'0 self <= len'0 self)
  && ([%#span13] level'0 self >= 0)
  
  predicate invariant_nonneg'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 336 4 336 41] (self : Trail'0.t_trail) =
    [%#span16] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_nonneg'0 tl /\ l >= 0 /\ l <= level'0 self
      end
  
  function to_pair'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 131 4 131 41] (self : Assign'0.t_assign) : (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span17] match self with
      | Assign'0.C_Decision t val' -> (t, val')
      | Assign'0.C_Input t val' -> (t, val')
      | Assign'0.C_Justified _ t val' -> (t, val')
      end
  
  use Core_Option_Option_Type as Option'0
  
  function find'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 471 4 471 64] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Option'0.t_option (Assign'0.t_assign, int)
    
   =
    [%#span21] match self with
      | Trail'0.C_Empty -> Option'0.C_None
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then Option'0.C_Some (a, l) else find'0 tl d
      end
  
  axiom find'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span20] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)))
  && ([%#span19] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
  && ([%#span18] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
  
  predicate contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 418 4 418 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span23] match find'0 self d with
      | Option'0.C_Some ix -> true
      | Option'0.C_None -> false
      end
  
  axiom contains'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . [%#span22] invariant_assign'0 self
   -> contains'0 self d = true  -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)
  
  predicate satisfied_by'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 677 4 677 47] (self : Trail'0.t_trail) (m : Model'0.t_model)
    
   =
    [%#span24] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 self a  -> satisfies'0 m a
  
  function level_of'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 408 4 408 50] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : int
    
   =
    [%#span27] match find'0 self d with
      | Option'0.C_Some (_, l) -> l
      | Option'0.C_None -> 0
      end
  
  axiom level_of'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span25] invariant_nonneg'0 self)
   -> ([%#span26] level_of'0 self d >= 0 /\ level_of'0 self d <= level'0 self)
  
  predicate is_bool'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 81 4 81 32] (self : Value'0.t_value) =
    [%#span28] sort'1 self = Sort'0.C_Boolean
  
  function negate'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 98 4 98 31] (self : Value'0.t_value) : Value'0.t_value =
    [%#span31] match self with
      | Value'0.C_Bool b -> Value'0.C_Bool (not b)
      | _ -> self
      end
  
  axiom negate'0_spec : forall self : Value'0.t_value . ([%#span29] is_bool'0 self)
   -> ([%#span30] is_bool'0 (negate'0 self))
  
  predicate trail_unique'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 373 4 373 37] (self : Trail'0.t_trail) =
    [%#span32] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> let ap = to_pair'0 a in not contains'0 tl ap
      /\ trail_unique'0 tl
      /\ (if is_bool'0 (let (_, a) = ap in a) then
        not contains'0 tl ((let (a, _) = ap in a), negate'0 (let (_, a) = ap in a))
      else
        true
      )
      end
  
  use set.Fset
  
  use set.Fset
  
  predicate contains'1 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (e : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span33] Fset.mem e self
  
  predicate invariant_contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 354 4 354 43] (self : Trail'0.t_trail) =
    [%#span34] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_contains'0 tl
      /\ match a with
        | Assign'0.C_Justified j _ _ -> forall a : (Term'0.t_term, Value'0.t_value) . contains'1 j a  -> contains'0 tl a
        | _ -> true
        end
      end
  
  use set.Fset
  
  function remove'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (a : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span35] Fset.remove a self
  
  use set.Fset
  
  use set.Fset
  
  use set.Fset
  
  function set_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 287 4 287 57] (self : Trail'0.t_trail) (s : Fset.fset (Term'0.t_term, Value'0.t_value)) : int
    
  
  axiom set_level'0_def : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . set_level'0 self s
  = ([%#span43] if Fset.cardinal s = 0 then
    0
  else
    if Fset.cardinal s = 1 then
      level_of'0 self (Fset.pick s)
    else
      let a = Fset.pick s in let rec' = set_level'0 self (remove'0 s a) in if level_of'0 self a >= rec' then
        level_of'0 self a
      else
        rec'
      
    
  )
  
  axiom set_level'0_spec : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . ([%#span36] invariant_nonneg'0 self)
   -> ([%#span41] set_level'0 self s <= level'0 self)
  && ([%#span40] set_level'0 self s >= 0)
  && ([%#span39] s = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))  -> set_level'0 self s = 0)
  && ([%#span38] s <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
   -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'1 s i /\ level_of'0 self i = set_level'0 self s))
  && ([%#span37] forall i : (Term'0.t_term, Value'0.t_value) . contains'1 s i
   -> level_of'0 self i <= set_level'0 self s)
  
  predicate invariant_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 320 4 320 40] (self : Trail'0.t_trail) =
    [%#span44] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_level'0 tl
      /\ match a with
        | Assign'0.C_Input _ _ -> l = 0
        | Assign'0.C_Decision _ _ -> level'0 tl + 1 = l
        | Assign'0.C_Justified j _ _ -> set_level'0 tl j = l
        end
      end
  
  predicate invariant'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 387 4 387 34] (self : Trail'0.t_trail) =
    [%#span45] invariant_level'0 self
    /\ invariant_contains'0 self /\ trail_unique'0 self /\ invariant_nonneg'0 self /\ invariant_assign'0 self
  
  function count_bounds'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 743 4 743 35] (self : Trail'0.t_trail) : () =
    [%#span48] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign (Assign'0.C_Input _ _) _ tl -> count_bounds'0 tl
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> count_bounds'0 tl
      | Trail'0.C_Assign (Assign'0.C_Justified _ _ _) _ tl -> count_bounds'0 tl
      end
  
  axiom count_bounds'0_spec : forall self : Trail'0.t_trail . ([%#span46] invariant'1 self)
   -> ([%#span47] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 self a  -> level_of'0 self a <= level'0 self)
  
  function restrict'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 561 4 561 45] (self : Trail'0.t_trail) (level : int) : Trail'0.t_trail
    
   =
    [%#span49] match self with
      | Trail'0.C_Empty -> Trail'0.C_Empty
      | Trail'0.C_Assign a l tl -> let tl = restrict'0 tl level in let _ = count_bounds'0 tl in if l <= level then
        Trail'0.C_Assign a l tl
      else
        tl
      
      end
  
  predicate unsat'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 684 4 684 30] (self : Trail'0.t_trail) =
    [%#span50] forall m : Model'0.t_model . inv'0 m  -> satisfied_by'0 (restrict'0 self 0) m  -> false
  
  constant self  : Trail'0.t_trail
  
  constant rhs  : Trail'0.t_trail
  
  predicate impls [#"/Users/xavier/Code/cdsat/src/theory.rs" 697 4 697 41] (self : Trail'0.t_trail) (rhs : Trail'0.t_trail)
    
  
  goal vc_impls : [%#stheory0] ([%#stheory1] forall m : Model'0.t_model . inv'0 m
   -> satisfied_by'0 (restrict'0 self 0) m  -> satisfied_by'0 (restrict'0 rhs 0) m)  -> unsat'0 rhs  -> unsat'0 self
end
module Cdsat_Theory_Impl5_FindJustified_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 619 15 619 27
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 620 15 620 32
  
  let%span stheory2 = "/Users/xavier/Code/cdsat/src/theory.rs" 621 4 621 90
  
  let%span span3 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span4 = "/Users/xavier/Code/cdsat/src/theory.rs" 157 8 159 9
  
  let%span span5 = "/Users/xavier/Code/cdsat/src/theory.rs" 132 8 136 9
  
  let%span span6 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span7 = "/Users/xavier/Code/cdsat/src/theory.rs" 167 18 167 22
  
  let%span span8 = "/Users/xavier/Code/cdsat/src/theory.rs" 166 4 166 62
  
  let%span span9 = "/Users/xavier/Code/cdsat/src/theory.rs" 168 8 188 9
  
  let%span span10 = "/Users/xavier/Code/cdsat/src/theory.rs" 194 8 194 31
  
  let%span span11 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 16 8 16 26
  
  let%span span12 = "/Users/xavier/Code/cdsat/src/theory.rs" 200 8 200 71
  
  let%span span13 = "/Users/xavier/Code/cdsat/src/theory.rs" 142 8 147 9
  
  let%span span14 = "/Users/xavier/Code/cdsat/src/theory.rs" 122 8 126 9
  
  let%span span15 = "/Users/xavier/Code/cdsat/src/theory.rs" 346 8 349 9
  
  let%span span16 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span17 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  let%span span18 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span span19 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span20 = "/Users/xavier/Code/cdsat/src/theory.rs" 601 8 605 9
  
  let%span span21 = "/Users/xavier/Code/cdsat/src/theory.rs" 337 8 340 9
  
  let%span span22 = "/Users/xavier/Code/cdsat/src/theory.rs" 465 14 468 5
  
  let%span span23 = "/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 111
  
  let%span span24 = "/Users/xavier/Code/cdsat/src/theory.rs" 470 4 470 104
  
  let%span span25 = "/Users/xavier/Code/cdsat/src/theory.rs" 472 8 481 9
  
  let%span span26 = "/Users/xavier/Code/cdsat/src/theory.rs" 417 4 417 87
  
  let%span span27 = "/Users/xavier/Code/cdsat/src/theory.rs" 419 8 422 9
  
  let%span span28 = "/Users/xavier/Code/cdsat/src/theory.rs" 262 8 265 9
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  use Cdsat_Theory_Value_Type as Value'0
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span3] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  use map.Map
  
  use Cdsat_Theory_Model_Type as Cdsat_Theory_Model_Type
  
  use Cdsat_Theory_Var_Type as Var'0
  
  use Cdsat_Theory_Model_Type as Model'0
  
  predicate invariant'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 156 4 156 30] (self : Model'0.t_model) =
    [%#span4] forall v : Value'0.t_value . forall k : Var'0.t_var . Map.get (Cdsat_Theory_Model_Type.model_0 self) k = v
     -> Cdsat_Theory_Var_Type.var_1 k = sort'1 v
  
  predicate inv'0 (_x : Model'0.t_model)
  
  axiom inv'0 : forall x : Model'0.t_model . inv'0 x
  = (invariant'1 x
  /\ match x with
    | Model'0.C_Model a_0 -> true
    end)
  
  use Cdsat_Theory_Term_Type as Term'0
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  function to_pair'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 131 4 131 41] (self : Assign'0.t_assign) : (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span5] match self with
      | Assign'0.C_Decision t val' -> (t, val')
      | Assign'0.C_Input t val' -> (t, val')
      | Assign'0.C_Justified _ t val' -> (t, val')
      end
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  use set.Fset
  
  use prelude.prelude.Real
  
  use prelude.prelude.Int
  
  function from_int'0 (_1 : int) : Real.real
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span6] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'1 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  function interp'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 167 4 167 41] (self : Model'0.t_model) (t : Term'0.t_term) : Value'0.t_value
    
   =
    [%#span9] match t with
      | Term'0.C_Variable v -> Map.get (Cdsat_Theory_Model_Type.model_0 self) v
      | Term'0.C_Value v -> v
      | Term'0.C_Plus l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Rat r1, Value'0.C_Rat r2) -> Value'0.C_Rat r1
        | _ -> Value'0.C_Rat (from_int'0 (- 1))
        end
      | Term'0.C_Conj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 /\ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Disj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 \/ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Eq l r -> Value'0.C_Bool (interp'0 self l = interp'0 self r)
      | Term'0.C_Neg t -> match interp'0 self t with
        | Value'0.C_Bool b -> Value'0.C_Bool (not b)
        | _ -> Value'0.C_Bool false
        end
      end
  
  axiom interp'0_spec : forall self : Model'0.t_model, t : Term'0.t_term . ([%#span7] inv'0 self)
   -> ([%#span8] invariant'1 self  -> sort'1 (interp'0 self t) = sort'0 t)
  
  predicate satisfies'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 193 4 193 52] (self : Model'0.t_model) (v : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span10] interp'0 self (let (a, _) = v in a) = (let (_, a) = v in a)
  
  use set.Fset
  
  predicate contains'1 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (e : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span11] Fset.mem e self
  
  predicate satisfy_set'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 199 4 199 60] (self : Model'0.t_model) (v : Fset.fset (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span12] forall a : (Term'0.t_term, Value'0.t_value) . contains'1 v a  -> satisfies'0 self a
  
  predicate justified_sound'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 141 4 141 40] (self : Assign'0.t_assign) =
    [%#span13] match self with
      | Assign'0.C_Justified just t val' -> forall m : Model'0.t_model . inv'0 m
       -> satisfy_set'0 m just  -> satisfies'0 m (t, val')
      | _ -> true
      end
  
  use prelude.prelude.Int
  
  use Core_Option_Option_Type as Option'0
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 121 4 121 34] (self : Assign'0.t_assign) =
    [%#span14] match self with
      | Assign'0.C_Decision t v -> sort'0 t = sort'1 v
      | Assign'0.C_Justified _ t v -> sort'0 t = sort'1 v /\ sort'0 t = Sort'0.C_Boolean
      | Assign'0.C_Input t v -> sort'0 t = sort'1 v
      end
  
  predicate invariant_assign'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 345 4 345 41] (self : Trail'0.t_trail) =
    [%#span15] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_assign'0 tl /\ invariant'0 a
      end
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span17] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span16] len'0 self >= 0
  
  function level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int =
    [%#span20] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> 1 + level'0 tl
      | Trail'0.C_Assign _ _ tl -> level'0 tl
      end
  
  axiom level'0_spec : forall self : Trail'0.t_trail . ([%#span19] level'0 self <= len'0 self)
  && ([%#span18] level'0 self >= 0)
  
  predicate invariant_nonneg'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 336 4 336 41] (self : Trail'0.t_trail) =
    [%#span21] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_nonneg'0 tl /\ l >= 0 /\ l <= level'0 self
      end
  
  function find'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 471 4 471 64] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Option'0.t_option (Assign'0.t_assign, int)
    
   =
    [%#span25] match self with
      | Trail'0.C_Empty -> Option'0.C_None
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then Option'0.C_Some (a, l) else find'0 tl d
      end
  
  axiom find'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span24] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)))
  && ([%#span23] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
  && ([%#span22] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
  
  predicate contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 418 4 418 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span27] match find'0 self d with
      | Option'0.C_Some ix -> true
      | Option'0.C_None -> false
      end
  
  axiom contains'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . [%#span26] invariant_assign'0 self
   -> contains'0 self d = true  -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)
  
  predicate sound'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 261 4 261 30] (self : Trail'0.t_trail)
   =
    [%#span28] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a _ tl -> sound'0 tl /\ justified_sound'0 a
      end
  
  constant self  : Trail'0.t_trail
  
  constant kv  : (Term'0.t_term, Value'0.t_value)
  
  function find_justified [#"/Users/xavier/Code/cdsat/src/theory.rs" 622 4 622 46] (self : Trail'0.t_trail) (kv : (Term'0.t_term, Value'0.t_value)) : ()
    
  
  goal vc_find_justified : ([%#stheory1] contains'0 self kv)
   -> ([%#stheory0] sound'0 self)
   -> match self with
    | Trail'0.C_Empty -> [%#stheory2] forall l : int . forall a : Assign'0.t_assign . find'0 self kv
    = Option'0.C_Some (a, l)  -> justified_sound'0 a
    | Trail'0.C_Assign a l tl -> match to_pair'0 a = kv with
      | True -> [%#stheory2] forall l : int . forall a : Assign'0.t_assign . find'0 self kv = Option'0.C_Some (a, l)
       -> justified_sound'0 a
      | False -> (([%#stheory1] contains'0 tl kv) && ([%#stheory0] sound'0 tl))
      /\ (([%#stheory2] forall l : int . forall a : Assign'0.t_assign . find'0 tl kv = Option'0.C_Some (a, l)
       -> justified_sound'0 a)
       -> ([%#stheory2] forall l : int . forall a : Assign'0.t_assign . find'0 self kv = Option'0.C_Some (a, l)
       -> justified_sound'0 a))
      end
    end
end
module Cdsat_Theory_Impl5_Justification_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 486 15 486 31
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 487 15 487 35
  
  let%span stheory2 = "/Users/xavier/Code/cdsat/src/theory.rs" 488 15 488 27
  
  let%span stheory3 = "/Users/xavier/Code/cdsat/src/theory.rs" 489 4 489 54
  
  let%span stheory4 = "/Users/xavier/Code/cdsat/src/theory.rs" 490 4 490 58
  
  let%span stheory5 = "/Users/xavier/Code/cdsat/src/theory.rs" 491 4 491 61
  
  let%span stheory6 = "/Users/xavier/Code/cdsat/src/theory.rs" 619 15 619 27
  
  let%span stheory7 = "/Users/xavier/Code/cdsat/src/theory.rs" 620 15 620 32
  
  let%span stheory8 = "/Users/xavier/Code/cdsat/src/theory.rs" 621 4 621 90
  
  let%span stheory9 = "/Users/xavier/Code/cdsat/src/theory.rs" 465 14 468 5
  
  let%span stheory10 = "/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 111
  
  let%span stheory11 = "/Users/xavier/Code/cdsat/src/theory.rs" 470 4 470 104
  
  let%span span12 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span13 = "/Users/xavier/Code/cdsat/src/theory.rs" 157 8 159 9
  
  let%span span14 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span15 = "/Users/xavier/Code/cdsat/src/theory.rs" 122 8 126 9
  
  let%span span16 = "/Users/xavier/Code/cdsat/src/theory.rs" 346 8 349 9
  
  let%span span17 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span18 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  let%span span19 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span span20 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span21 = "/Users/xavier/Code/cdsat/src/theory.rs" 601 8 605 9
  
  let%span span22 = "/Users/xavier/Code/cdsat/src/theory.rs" 337 8 340 9
  
  let%span span23 = "/Users/xavier/Code/cdsat/src/theory.rs" 132 8 136 9
  
  let%span span24 = "/Users/xavier/Code/cdsat/src/theory.rs" 167 18 167 22
  
  let%span span25 = "/Users/xavier/Code/cdsat/src/theory.rs" 166 4 166 62
  
  let%span span26 = "/Users/xavier/Code/cdsat/src/theory.rs" 168 8 188 9
  
  let%span span27 = "/Users/xavier/Code/cdsat/src/theory.rs" 194 8 194 31
  
  let%span span28 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 16 8 16 26
  
  let%span span29 = "/Users/xavier/Code/cdsat/src/theory.rs" 200 8 200 71
  
  let%span span30 = "/Users/xavier/Code/cdsat/src/theory.rs" 142 8 147 9
  
  let%span span31 = "/Users/xavier/Code/cdsat/src/theory.rs" 472 8 481 9
  
  let%span span32 = "/Users/xavier/Code/cdsat/src/theory.rs" 417 4 417 87
  
  let%span span33 = "/Users/xavier/Code/cdsat/src/theory.rs" 419 8 422 9
  
  let%span span34 = "/Users/xavier/Code/cdsat/src/theory.rs" 262 8 265 9
  
  let%span span35 = "/Users/xavier/Code/cdsat/src/theory.rs" 623 8 632 9
  
  let%span span36 = "/Users/xavier/Code/cdsat/src/theory.rs" 514 8 517 9
  
  let%span span37 = "/Users/xavier/Code/cdsat/src/theory.rs" 524 8 527 9
  
  let%span span38 = "/Users/xavier/Code/cdsat/src/theory.rs" 206 8 206 84
  
  let%span span39 = "/Users/xavier/Code/cdsat/src/theory.rs" 504 8 507 9
  
  let%span span40 = "/Users/xavier/Code/cdsat/src/theory.rs" 82 8 82 36
  
  let%span span41 = "/Users/xavier/Code/cdsat/src/theory.rs" 96 15 96 29
  
  let%span span42 = "/Users/xavier/Code/cdsat/src/theory.rs" 97 14 97 30
  
  let%span span43 = "/Users/xavier/Code/cdsat/src/theory.rs" 99 8 102 9
  
  let%span span44 = "/Users/xavier/Code/cdsat/src/theory.rs" 374 8 382 9
  
  let%span span45 = "/Users/xavier/Code/cdsat/src/theory.rs" 355 8 368 9
  
  let%span span46 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 53 8 53 26
  
  let%span span47 = "/Users/xavier/Code/cdsat/src/theory.rs" 406 15 406 38
  
  let%span span48 = "/Users/xavier/Code/cdsat/src/theory.rs" 407 14 407 51
  
  let%span span49 = "/Users/xavier/Code/cdsat/src/theory.rs" 409 8 412 9
  
  let%span span50 = "/Users/xavier/Code/cdsat/src/theory.rs" 281 15 281 38
  
  let%span span51 = "/Users/xavier/Code/cdsat/src/theory.rs" 282 4 282 74
  
  let%span span52 = "/Users/xavier/Code/cdsat/src/theory.rs" 283 4 283 94
  
  let%span span53 = "/Users/xavier/Code/cdsat/src/theory.rs" 284 4 284 48
  
  let%span span54 = "/Users/xavier/Code/cdsat/src/theory.rs" 285 14 285 25
  
  let%span span55 = "/Users/xavier/Code/cdsat/src/theory.rs" 286 14 286 36
  
  let%span span56 = "/Users/xavier/Code/cdsat/src/theory.rs" 280 14 280 21
  
  let%span span57 = "/Users/xavier/Code/cdsat/src/theory.rs" 278 4 278 12
  
  let%span span58 = "/Users/xavier/Code/cdsat/src/theory.rs" 321 8 331 9
  
  let%span span59 = "/Users/xavier/Code/cdsat/src/theory.rs" 388 8 392 38
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  use Cdsat_Theory_Value_Type as Value'0
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span12] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  use map.Map
  
  use Cdsat_Theory_Model_Type as Cdsat_Theory_Model_Type
  
  use Cdsat_Theory_Var_Type as Var'0
  
  use Cdsat_Theory_Model_Type as Model'0
  
  predicate invariant'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 156 4 156 30] (self : Model'0.t_model) =
    [%#span13] forall v : Value'0.t_value . forall k : Var'0.t_var . Map.get (Cdsat_Theory_Model_Type.model_0 self) k
    = v  -> Cdsat_Theory_Var_Type.var_1 k = sort'1 v
  
  predicate inv'0 (_x : Model'0.t_model)
  
  axiom inv'0 : forall x : Model'0.t_model . inv'0 x
  = (invariant'1 x
  /\ match x with
    | Model'0.C_Model a_0 -> true
    end)
  
  use Cdsat_Theory_Term_Type as Term'0
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span14] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'1 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  predicate invariant'2 [#"/Users/xavier/Code/cdsat/src/theory.rs" 121 4 121 34] (self : Assign'0.t_assign) =
    [%#span15] match self with
      | Assign'0.C_Decision t v -> sort'0 t = sort'1 v
      | Assign'0.C_Justified _ t v -> sort'0 t = sort'1 v /\ sort'0 t = Sort'0.C_Boolean
      | Assign'0.C_Input t v -> sort'0 t = sort'1 v
      end
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  predicate invariant_assign'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 345 4 345 41] (self : Trail'0.t_trail) =
    [%#span16] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_assign'0 tl /\ invariant'2 a
      end
  
  use prelude.prelude.Int
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span18] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span17] len'0 self >= 0
  
  function level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int =
    [%#span21] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> 1 + level'0 tl
      | Trail'0.C_Assign _ _ tl -> level'0 tl
      end
  
  axiom level'0_spec : forall self : Trail'0.t_trail . ([%#span20] level'0 self <= len'0 self)
  && ([%#span19] level'0 self >= 0)
  
  predicate invariant_nonneg'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 336 4 336 41] (self : Trail'0.t_trail) =
    [%#span22] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_nonneg'0 tl /\ l >= 0 /\ l <= level'0 self
      end
  
  function to_pair'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 131 4 131 41] (self : Assign'0.t_assign) : (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span23] match self with
      | Assign'0.C_Decision t val' -> (t, val')
      | Assign'0.C_Input t val' -> (t, val')
      | Assign'0.C_Justified _ t val' -> (t, val')
      end
  
  use set.Fset
  
  use prelude.prelude.Real
  
  function from_int'0 (_1 : int) : Real.real
  
  function interp'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 167 4 167 41] (self : Model'0.t_model) (t : Term'0.t_term) : Value'0.t_value
    
   =
    [%#span26] match t with
      | Term'0.C_Variable v -> Map.get (Cdsat_Theory_Model_Type.model_0 self) v
      | Term'0.C_Value v -> v
      | Term'0.C_Plus l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Rat r1, Value'0.C_Rat r2) -> Value'0.C_Rat r1
        | _ -> Value'0.C_Rat (from_int'0 (- 1))
        end
      | Term'0.C_Conj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 /\ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Disj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 \/ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Eq l r -> Value'0.C_Bool (interp'0 self l = interp'0 self r)
      | Term'0.C_Neg t -> match interp'0 self t with
        | Value'0.C_Bool b -> Value'0.C_Bool (not b)
        | _ -> Value'0.C_Bool false
        end
      end
  
  axiom interp'0_spec : forall self : Model'0.t_model, t : Term'0.t_term . ([%#span24] inv'0 self)
   -> ([%#span25] invariant'1 self  -> sort'1 (interp'0 self t) = sort'0 t)
  
  predicate satisfies'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 193 4 193 52] (self : Model'0.t_model) (v : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span27] interp'0 self (let (a, _) = v in a) = (let (_, a) = v in a)
  
  use set.Fset
  
  predicate contains'1 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (e : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span28] Fset.mem e self
  
  predicate satisfy_set'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 199 4 199 60] (self : Model'0.t_model) (v : Fset.fset (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span29] forall a : (Term'0.t_term, Value'0.t_value) . contains'1 v a  -> satisfies'0 self a
  
  predicate justified_sound'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 141 4 141 40] (self : Assign'0.t_assign) =
    [%#span30] match self with
      | Assign'0.C_Justified just t val' -> forall m : Model'0.t_model . inv'0 m
       -> satisfy_set'0 m just  -> satisfies'0 m (t, val')
      | _ -> true
      end
  
  use prelude.prelude.Int
  
  use Core_Option_Option_Type as Option'0
  
  function find'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 471 4 471 64] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Option'0.t_option (Assign'0.t_assign, int)
    
   =
    [%#span31] match self with
      | Trail'0.C_Empty -> Option'0.C_None
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then Option'0.C_Some (a, l) else find'0 tl d
      end
  
  axiom find'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#stheory11] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)))
  && ([%#stheory10] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
  && ([%#stheory9] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
  
  predicate contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 418 4 418 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span33] match find'0 self d with
      | Option'0.C_Some ix -> true
      | Option'0.C_None -> false
      end
  
  axiom contains'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . [%#span32] invariant_assign'0 self
   -> contains'0 self d = true  -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)
  
  predicate sound'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 261 4 261 30] (self : Trail'0.t_trail)
   =
    [%#span34] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a _ tl -> sound'0 tl /\ justified_sound'0 a
      end
  
  function find_justified'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 622 4 622 46] (self : Trail'0.t_trail) (kv : (Term'0.t_term, Value'0.t_value)) : ()
    
   =
    [%#span35] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = kv then () else find_justified'0 tl kv
      end
  
  axiom find_justified'0_spec : forall self : Trail'0.t_trail, kv : (Term'0.t_term, Value'0.t_value) . ([%#stheory6] sound'0 self)
   -> ([%#stheory7] contains'0 self kv)
   -> ([%#stheory8] forall l : int . forall a : Assign'0.t_assign . find'0 self kv = Option'0.C_Some (a, l)
   -> justified_sound'0 a)
  
  predicate is_decision'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 513 4 513 54] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span36] match find'0 self d with
      | Option'0.C_Some (Assign'0.C_Decision _ _, _) -> true
      | _ -> false
      end
  
  use set.Fset
  
  predicate is_input'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 523 4 523 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span37] match find'0 self d with
      | Option'0.C_Some (Assign'0.C_Input _ _, _) -> true
      | _ -> false
      end
  
  predicate entails'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 205 4 205 74] (self : Model'0.t_model) (j : Fset.fset (Term'0.t_term, Value'0.t_value)) (c : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span38] invariant'1 self  -> satisfy_set'0 self j  -> satisfies'0 self c
  
  predicate is_justified'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 503 4 503 55] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span39] match find'0 self d with
      | Option'0.C_Some (Assign'0.C_Justified _ _ _, _) -> true
      | _ -> false
      end
  
  predicate is_bool'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 81 4 81 32] (self : Value'0.t_value) =
    [%#span40] sort'1 self = Sort'0.C_Boolean
  
  function negate'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 98 4 98 31] (self : Value'0.t_value) : Value'0.t_value =
    [%#span43] match self with
      | Value'0.C_Bool b -> Value'0.C_Bool (not b)
      | _ -> self
      end
  
  axiom negate'0_spec : forall self : Value'0.t_value . ([%#span41] is_bool'0 self)
   -> ([%#span42] is_bool'0 (negate'0 self))
  
  predicate trail_unique'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 373 4 373 37] (self : Trail'0.t_trail) =
    [%#span44] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> let ap = to_pair'0 a in not contains'0 tl ap
      /\ trail_unique'0 tl
      /\ (if is_bool'0 (let (_, a) = ap in a) then
        not contains'0 tl ((let (a, _) = ap in a), negate'0 (let (_, a) = ap in a))
      else
        true
      )
      end
  
  predicate invariant_contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 354 4 354 43] (self : Trail'0.t_trail) =
    [%#span45] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_contains'0 tl
      /\ match a with
        | Assign'0.C_Justified j _ _ -> forall a : (Term'0.t_term, Value'0.t_value) . contains'1 j a  -> contains'0 tl a
        | _ -> true
        end
      end
  
  use set.Fset
  
  function remove'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (a : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span46] Fset.remove a self
  
  use set.Fset
  
  use set.Fset
  
  function level_of'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 408 4 408 50] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : int
    
   =
    [%#span49] match find'0 self d with
      | Option'0.C_Some (_, l) -> l
      | Option'0.C_None -> 0
      end
  
  axiom level_of'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span47] invariant_nonneg'0 self)
   -> ([%#span48] level_of'0 self d >= 0 /\ level_of'0 self d <= level'0 self)
  
  function set_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 287 4 287 57] (self : Trail'0.t_trail) (s : Fset.fset (Term'0.t_term, Value'0.t_value)) : int
    
  
  axiom set_level'0_def : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . set_level'0 self s
  = ([%#span57] if Fset.cardinal s = 0 then
    0
  else
    if Fset.cardinal s = 1 then
      level_of'0 self (Fset.pick s)
    else
      let a = Fset.pick s in let rec' = set_level'0 self (remove'0 s a) in if level_of'0 self a >= rec' then
        level_of'0 self a
      else
        rec'
      
    
  )
  
  axiom set_level'0_spec : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . ([%#span50] invariant_nonneg'0 self)
   -> ([%#span55] set_level'0 self s <= level'0 self)
  && ([%#span54] set_level'0 self s >= 0)
  && ([%#span53] s = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))  -> set_level'0 self s = 0)
  && ([%#span52] s <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
   -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'1 s i /\ level_of'0 self i = set_level'0 self s))
  && ([%#span51] forall i : (Term'0.t_term, Value'0.t_value) . contains'1 s i
   -> level_of'0 self i <= set_level'0 self s)
  
  predicate invariant_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 320 4 320 40] (self : Trail'0.t_trail) =
    [%#span58] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_level'0 tl
      /\ match a with
        | Assign'0.C_Input _ _ -> l = 0
        | Assign'0.C_Decision _ _ -> level'0 tl + 1 = l
        | Assign'0.C_Justified j _ _ -> set_level'0 tl j = l
        end
      end
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 387 4 387 34] (self : Trail'0.t_trail) =
    [%#span59] invariant_level'0 self
    /\ invariant_contains'0 self /\ trail_unique'0 self /\ invariant_nonneg'0 self /\ invariant_assign'0 self
  
  constant self  : Trail'0.t_trail
  
  constant d  : (Term'0.t_term, Value'0.t_value)
  
  function justification [#"/Users/xavier/Code/cdsat/src/theory.rs" 492 4 492 71] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
  
  goal vc_justification : ([%#stheory2] sound'0 self)
   -> ([%#stheory1] is_justified'0 self d)
   -> ([%#stheory0] invariant'0 self)
   -> (([%#stheory7] contains'0 self d) && ([%#stheory6] sound'0 self))
  /\ (([%#stheory8] forall l : int . forall a : Assign'0.t_assign . find'0 self d = Option'0.C_Some (a, l)
   -> justified_sound'0 a)
   -> (let _ = find_justified'0 self d in ([%#stheory11] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)))
  && ([%#stheory10] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
  && ([%#stheory9] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
   -> match find'0 self d with
    | Option'0.C_Some (Assign'0.C_Justified j _ _, _) -> let result = j in ([%#stheory5] is_decision'0 self d
     -> result = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value)))
    && ([%#stheory4] is_input'0 self d  -> result = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value)))
    && ([%#stheory3] forall m : Model'0.t_model . inv'0 m  -> entails'0 m result d)
    | _ -> let result = Fset.empty : Fset.fset (Term'0.t_term, Value'0.t_value) in ([%#stheory5] is_decision'0 self d
     -> result = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value)))
    && ([%#stheory4] is_input'0 self d  -> result = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value)))
    && ([%#stheory3] forall m : Model'0.t_model . inv'0 m  -> entails'0 m result d)
    end))
end
module Cdsat_Theory_Impl4_Consistent_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 238 15 238 37
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 239 15 239 37
  
  let%span stheory2 = "/Users/xavier/Code/cdsat/src/theory.rs" 240 15 240 21
  
  let%span stheory3 = "/Users/xavier/Code/cdsat/src/theory.rs" 242 22 242 26
  
  let%span stheory4 = "/Users/xavier/Code/cdsat/src/theory.rs" 241 14 241 19
  
  let%span span5 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span6 = "/Users/xavier/Code/cdsat/src/theory.rs" 157 8 159 9
  
  let%span span7 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span8 = "/Users/xavier/Code/cdsat/src/theory.rs" 167 18 167 22
  
  let%span span9 = "/Users/xavier/Code/cdsat/src/theory.rs" 166 4 166 62
  
  let%span span10 = "/Users/xavier/Code/cdsat/src/theory.rs" 168 8 188 9
  
  let%span span11 = "/Users/xavier/Code/cdsat/src/theory.rs" 194 8 194 31
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  use Cdsat_Theory_Value_Type as Value'0
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span5] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  use map.Map
  
  use Cdsat_Theory_Model_Type as Cdsat_Theory_Model_Type
  
  use Cdsat_Theory_Var_Type as Var'0
  
  use Cdsat_Theory_Model_Type as Model'0
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 156 4 156 30] (self : Model'0.t_model) =
    [%#span6] forall v : Value'0.t_value . forall k : Var'0.t_var . Map.get (Cdsat_Theory_Model_Type.model_0 self) k = v
     -> Cdsat_Theory_Var_Type.var_1 k = sort'0 v
  
  predicate inv'0 (_x : Model'0.t_model)
  
  axiom inv'0 : forall x : Model'0.t_model . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Model'0.C_Model a_0 -> true
    end)
  
  use Cdsat_Theory_Term_Type as Term'0
  
  use prelude.prelude.Real
  
  use prelude.prelude.Int
  
  function from_int'0 (_1 : int) : Real.real
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span7] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'0 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  function interp'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 167 4 167 41] (self : Model'0.t_model) (t : Term'0.t_term) : Value'0.t_value
    
   =
    [%#span10] match t with
      | Term'0.C_Variable v -> Map.get (Cdsat_Theory_Model_Type.model_0 self) v
      | Term'0.C_Value v -> v
      | Term'0.C_Plus l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Rat r1, Value'0.C_Rat r2) -> Value'0.C_Rat r1
        | _ -> Value'0.C_Rat (from_int'0 (- 1))
        end
      | Term'0.C_Conj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 /\ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Disj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 \/ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Eq l r -> Value'0.C_Bool (interp'0 self l = interp'0 self r)
      | Term'0.C_Neg t -> match interp'0 self t with
        | Value'0.C_Bool b -> Value'0.C_Bool (not b)
        | _ -> Value'0.C_Bool false
        end
      end
  
  axiom interp'0_spec : forall self : Model'0.t_model, t : Term'0.t_term . ([%#span8] inv'0 self)
   -> ([%#span9] invariant'0 self  -> sort'0 (interp'0 self t) = sort'1 t)
  
  predicate satisfies'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 193 4 193 52] (self : Model'0.t_model) (v : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span11] interp'0 self (let (a, _) = v in a) = (let (_, a) = v in a)
  
  constant self  : Model'0.t_model
  
  constant t  : Term'0.t_term
  
  constant v  : Value'0.t_value
  
  constant w  : Value'0.t_value
  
  function consistent [#"/Users/xavier/Code/cdsat/src/theory.rs" 242 4 242 56] (self : Model'0.t_model) (t : Term'0.t_term) (v : Value'0.t_value) (w : Value'0.t_value) : ()
    
  
  goal vc_consistent : ([%#stheory3] inv'0 self)
   -> ([%#stheory2] v <> w)
   -> ([%#stheory1] satisfies'0 self (t, w))  -> ([%#stheory0] satisfies'0 self (t, v))  -> ([%#stheory4] false)
end
module Cdsat_Theory_Impl5_SetLevelMax_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 305 15 305 38
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 306 15 306 57
  
  let%span stheory2 = "/Users/xavier/Code/cdsat/src/theory.rs" 308 14 308 69
  
  let%span span3 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 31 8 31 26
  
  let%span span4 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span5 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span6 = "/Users/xavier/Code/cdsat/src/theory.rs" 122 8 126 9
  
  let%span span7 = "/Users/xavier/Code/cdsat/src/theory.rs" 346 8 349 9
  
  let%span span8 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span9 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  let%span span10 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span span11 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span12 = "/Users/xavier/Code/cdsat/src/theory.rs" 601 8 605 9
  
  let%span span13 = "/Users/xavier/Code/cdsat/src/theory.rs" 337 8 340 9
  
  let%span span14 = "/Users/xavier/Code/cdsat/src/theory.rs" 132 8 136 9
  
  let%span span15 = "/Users/xavier/Code/cdsat/src/theory.rs" 465 14 468 5
  
  let%span span16 = "/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 111
  
  let%span span17 = "/Users/xavier/Code/cdsat/src/theory.rs" 470 4 470 104
  
  let%span span18 = "/Users/xavier/Code/cdsat/src/theory.rs" 472 8 481 9
  
  let%span span19 = "/Users/xavier/Code/cdsat/src/theory.rs" 406 15 406 38
  
  let%span span20 = "/Users/xavier/Code/cdsat/src/theory.rs" 407 14 407 51
  
  let%span span21 = "/Users/xavier/Code/cdsat/src/theory.rs" 409 8 412 9
  
  let%span span22 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 53 8 53 26
  
  let%span span23 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 16 8 16 26
  
  let%span span24 = "/Users/xavier/Code/cdsat/src/theory.rs" 281 15 281 38
  
  let%span span25 = "/Users/xavier/Code/cdsat/src/theory.rs" 282 4 282 74
  
  let%span span26 = "/Users/xavier/Code/cdsat/src/theory.rs" 283 4 283 94
  
  let%span span27 = "/Users/xavier/Code/cdsat/src/theory.rs" 284 4 284 48
  
  let%span span28 = "/Users/xavier/Code/cdsat/src/theory.rs" 285 14 285 25
  
  let%span span29 = "/Users/xavier/Code/cdsat/src/theory.rs" 286 14 286 36
  
  let%span span30 = "/Users/xavier/Code/cdsat/src/theory.rs" 280 14 280 21
  
  let%span span31 = "/Users/xavier/Code/cdsat/src/theory.rs" 278 4 278 12
  
  use Cdsat_Theory_Value_Type as Value'0
  
  use Cdsat_Theory_Term_Type as Term'0
  
  use set.Fset
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  use set.Fset
  
  function insert'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (e : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span3] Fset.add e self
  
  use prelude.prelude.Int
  
  use prelude.prelude.Int
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span4] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span5] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'1 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 121 4 121 34] (self : Assign'0.t_assign) =
    [%#span6] match self with
      | Assign'0.C_Decision t v -> sort'0 t = sort'1 v
      | Assign'0.C_Justified _ t v -> sort'0 t = sort'1 v /\ sort'0 t = Sort'0.C_Boolean
      | Assign'0.C_Input t v -> sort'0 t = sort'1 v
      end
  
  predicate invariant_assign'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 345 4 345 41] (self : Trail'0.t_trail) =
    [%#span7] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_assign'0 tl /\ invariant'0 a
      end
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span9] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span8] len'0 self >= 0
  
  function level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int =
    [%#span12] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> 1 + level'0 tl
      | Trail'0.C_Assign _ _ tl -> level'0 tl
      end
  
  axiom level'0_spec : forall self : Trail'0.t_trail . ([%#span11] level'0 self <= len'0 self)
  && ([%#span10] level'0 self >= 0)
  
  predicate invariant_nonneg'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 336 4 336 41] (self : Trail'0.t_trail) =
    [%#span13] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_nonneg'0 tl /\ l >= 0 /\ l <= level'0 self
      end
  
  function to_pair'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 131 4 131 41] (self : Assign'0.t_assign) : (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span14] match self with
      | Assign'0.C_Decision t val' -> (t, val')
      | Assign'0.C_Input t val' -> (t, val')
      | Assign'0.C_Justified _ t val' -> (t, val')
      end
  
  use Core_Option_Option_Type as Option'0
  
  function find'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 471 4 471 64] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Option'0.t_option (Assign'0.t_assign, int)
    
   =
    [%#span18] match self with
      | Trail'0.C_Empty -> Option'0.C_None
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then Option'0.C_Some (a, l) else find'0 tl d
      end
  
  axiom find'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span17] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)))
  && ([%#span16] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
  && ([%#span15] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
  
  function level_of'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 408 4 408 50] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : int
    
   =
    [%#span21] match find'0 self d with
      | Option'0.C_Some (_, l) -> l
      | Option'0.C_None -> 0
      end
  
  axiom level_of'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span19] invariant_nonneg'0 self)
   -> ([%#span20] level_of'0 self d >= 0 /\ level_of'0 self d <= level'0 self)
  
  use set.Fset
  
  function remove'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (a : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span22] Fset.remove a self
  
  use set.Fset
  
  use set.Fset
  
  use set.Fset
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (e : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span23] Fset.mem e self
  
  function set_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 287 4 287 57] (self : Trail'0.t_trail) (s : Fset.fset (Term'0.t_term, Value'0.t_value)) : int
    
  
  axiom set_level'0_def : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . set_level'0 self s
  = ([%#span31] if Fset.cardinal s = 0 then
    0
  else
    if Fset.cardinal s = 1 then
      level_of'0 self (Fset.pick s)
    else
      let a = Fset.pick s in let rec' = set_level'0 self (remove'0 s a) in if level_of'0 self a >= rec' then
        level_of'0 self a
      else
        rec'
      
    
  )
  
  axiom set_level'0_spec : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . ([%#span24] invariant_nonneg'0 self)
   -> ([%#span29] set_level'0 self s <= level'0 self)
  && ([%#span28] set_level'0 self s >= 0)
  && ([%#span27] s = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))  -> set_level'0 self s = 0)
  && ([%#span26] s <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
   -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'0 s i /\ level_of'0 self i = set_level'0 self s))
  && ([%#span25] forall i : (Term'0.t_term, Value'0.t_value) . contains'0 s i
   -> level_of'0 self i <= set_level'0 self s)
  
  constant self  : Trail'0.t_trail
  
  constant set  : Fset.fset (Term'0.t_term, Value'0.t_value)
  
  constant elem  : (Term'0.t_term, Value'0.t_value)
  
  function set_level_max [#"/Users/xavier/Code/cdsat/src/theory.rs" 309 4 309 77] (self : Trail'0.t_trail) (set : Fset.fset (Term'0.t_term, Value'0.t_value)) (elem : (Term'0.t_term, Value'0.t_value)) : ()
    
  
  goal vc_set_level_max : ([%#stheory1] set_level'0 self set <= level_of'0 self elem)
   -> ([%#stheory0] invariant_nonneg'0 self)
   -> ([%#stheory2] set_level'0 self (insert'0 set elem) = level_of'0 self elem)
end
module Cdsat_Theory_Impl5_SetLevelMin_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 313 15 313 38
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 314 15 314 56
  
  let%span stheory2 = "/Users/xavier/Code/cdsat/src/theory.rs" 315 14 315 69
  
  let%span span3 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 31 8 31 26
  
  let%span span4 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 53 8 53 26
  
  let%span span5 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span6 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  let%span span7 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span span8 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span9 = "/Users/xavier/Code/cdsat/src/theory.rs" 601 8 605 9
  
  let%span span10 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span11 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span12 = "/Users/xavier/Code/cdsat/src/theory.rs" 122 8 126 9
  
  let%span span13 = "/Users/xavier/Code/cdsat/src/theory.rs" 346 8 349 9
  
  let%span span14 = "/Users/xavier/Code/cdsat/src/theory.rs" 337 8 340 9
  
  let%span span15 = "/Users/xavier/Code/cdsat/src/theory.rs" 132 8 136 9
  
  let%span span16 = "/Users/xavier/Code/cdsat/src/theory.rs" 465 14 468 5
  
  let%span span17 = "/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 111
  
  let%span span18 = "/Users/xavier/Code/cdsat/src/theory.rs" 470 4 470 104
  
  let%span span19 = "/Users/xavier/Code/cdsat/src/theory.rs" 472 8 481 9
  
  let%span span20 = "/Users/xavier/Code/cdsat/src/theory.rs" 406 15 406 38
  
  let%span span21 = "/Users/xavier/Code/cdsat/src/theory.rs" 407 14 407 51
  
  let%span span22 = "/Users/xavier/Code/cdsat/src/theory.rs" 409 8 412 9
  
  let%span span23 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 16 8 16 26
  
  let%span span24 = "/Users/xavier/Code/cdsat/src/theory.rs" 281 15 281 38
  
  let%span span25 = "/Users/xavier/Code/cdsat/src/theory.rs" 282 4 282 74
  
  let%span span26 = "/Users/xavier/Code/cdsat/src/theory.rs" 283 4 283 94
  
  let%span span27 = "/Users/xavier/Code/cdsat/src/theory.rs" 284 4 284 48
  
  let%span span28 = "/Users/xavier/Code/cdsat/src/theory.rs" 285 14 285 25
  
  let%span span29 = "/Users/xavier/Code/cdsat/src/theory.rs" 286 14 286 36
  
  let%span span30 = "/Users/xavier/Code/cdsat/src/theory.rs" 280 14 280 21
  
  let%span span31 = "/Users/xavier/Code/cdsat/src/theory.rs" 278 4 278 12
  
  use Cdsat_Theory_Value_Type as Value'0
  
  use Cdsat_Theory_Term_Type as Term'0
  
  use set.Fset
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  use set.Fset
  
  function insert'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (e : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span3] Fset.add e self
  
  use prelude.prelude.Int
  
  use set.Fset
  
  function remove'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (a : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span4] Fset.remove a self
  
  use set.Fset
  
  use set.Fset
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span6] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span5] len'0 self >= 0
  
  function level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int =
    [%#span9] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> 1 + level'0 tl
      | Trail'0.C_Assign _ _ tl -> level'0 tl
      end
  
  axiom level'0_spec : forall self : Trail'0.t_trail . ([%#span8] level'0 self <= len'0 self)
  && ([%#span7] level'0 self >= 0)
  
  use set.Fset
  
  use prelude.prelude.Int
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span10] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span11] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'1 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 121 4 121 34] (self : Assign'0.t_assign) =
    [%#span12] match self with
      | Assign'0.C_Decision t v -> sort'0 t = sort'1 v
      | Assign'0.C_Justified _ t v -> sort'0 t = sort'1 v /\ sort'0 t = Sort'0.C_Boolean
      | Assign'0.C_Input t v -> sort'0 t = sort'1 v
      end
  
  predicate invariant_assign'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 345 4 345 41] (self : Trail'0.t_trail) =
    [%#span13] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_assign'0 tl /\ invariant'0 a
      end
  
  predicate invariant_nonneg'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 336 4 336 41] (self : Trail'0.t_trail) =
    [%#span14] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_nonneg'0 tl /\ l >= 0 /\ l <= level'0 self
      end
  
  function to_pair'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 131 4 131 41] (self : Assign'0.t_assign) : (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span15] match self with
      | Assign'0.C_Decision t val' -> (t, val')
      | Assign'0.C_Input t val' -> (t, val')
      | Assign'0.C_Justified _ t val' -> (t, val')
      end
  
  use Core_Option_Option_Type as Option'0
  
  function find'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 471 4 471 64] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Option'0.t_option (Assign'0.t_assign, int)
    
   =
    [%#span19] match self with
      | Trail'0.C_Empty -> Option'0.C_None
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then Option'0.C_Some (a, l) else find'0 tl d
      end
  
  axiom find'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span18] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)))
  && ([%#span17] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
  && ([%#span16] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
  
  function level_of'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 408 4 408 50] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : int
    
   =
    [%#span22] match find'0 self d with
      | Option'0.C_Some (_, l) -> l
      | Option'0.C_None -> 0
      end
  
  axiom level_of'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span20] invariant_nonneg'0 self)
   -> ([%#span21] level_of'0 self d >= 0 /\ level_of'0 self d <= level'0 self)
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (e : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span23] Fset.mem e self
  
  function set_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 287 4 287 57] (self : Trail'0.t_trail) (s : Fset.fset (Term'0.t_term, Value'0.t_value)) : int
    
  
  axiom set_level'0_def : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . set_level'0 self s
  = ([%#span31] if Fset.cardinal s = 0 then
    0
  else
    if Fset.cardinal s = 1 then
      level_of'0 self (Fset.pick s)
    else
      let a = Fset.pick s in let rec' = set_level'0 self (remove'0 s a) in if level_of'0 self a >= rec' then
        level_of'0 self a
      else
        rec'
      
    
  )
  
  axiom set_level'0_spec : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . ([%#span24] invariant_nonneg'0 self)
   -> ([%#span29] set_level'0 self s <= level'0 self)
  && ([%#span28] set_level'0 self s >= 0)
  && ([%#span27] s = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))  -> set_level'0 self s = 0)
  && ([%#span26] s <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
   -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'0 s i /\ level_of'0 self i = set_level'0 self s))
  && ([%#span25] forall i : (Term'0.t_term, Value'0.t_value) . contains'0 s i
   -> level_of'0 self i <= set_level'0 self s)
  
  constant self  : Trail'0.t_trail
  
  constant set  : Fset.fset (Term'0.t_term, Value'0.t_value)
  
  constant elem  : (Term'0.t_term, Value'0.t_value)
  
  function set_level_min [#"/Users/xavier/Code/cdsat/src/theory.rs" 316 4 316 77] (self : Trail'0.t_trail) (set : Fset.fset (Term'0.t_term, Value'0.t_value)) (elem : (Term'0.t_term, Value'0.t_value)) : ()
    
  
  goal vc_set_level_min : ([%#stheory1] level_of'0 self elem < set_level'0 self set)
   -> ([%#stheory0] invariant_nonneg'0 self)
   -> ([%#stheory2] set_level'0 self (insert'0 set elem) = set_level'0 self set)
end
module Cdsat_Theory_Conflict_Type
  use Cdsat_Theory_Value_Type as Value'0
  
  use Cdsat_Theory_Term_Type as Term'0
  
  use set.Fset
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  type t_conflict  =
    | C_Conflict (Trail'0.t_trail) (Fset.fset (Term'0.t_term, Value'0.t_value))
  
  function any_l (_ : 'b) : 'a
  
  let rec t_conflict (input:t_conflict) (ret  (field_0:Trail'0.t_trail) (field_1:Fset.fset (Term'0.t_term, Value'0.t_value)))= any
    [ good (field_0:Trail'0.t_trail) (field_1:Fset.fset (Term'0.t_term, Value'0.t_value))-> {C_Conflict field_0 field_1
      = input}
      (! ret {field_0} {field_1})
    | bad (field_0:Trail'0.t_trail) (field_1:Fset.fset (Term'0.t_term, Value'0.t_value))-> {C_Conflict field_0 field_1
      <> input}
      {false}
      any ]
    
  
  function conflict_1 (self : t_conflict) : Fset.fset (Term'0.t_term, Value'0.t_value) =
    match self with
      | C_Conflict _ a -> a
      end
  
  function conflict_0 (self : t_conflict) : Trail'0.t_trail =
    match self with
      | C_Conflict a _ -> a
      end
end
module Cdsat_Theory_Impl5_JustifiedIsBool_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 806 15 806 38
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 807 15 807 35
  
  let%span stheory2 = "/Users/xavier/Code/cdsat/src/theory.rs" 808 4 808 29
  
  let%span span3 = "/Users/xavier/Code/cdsat/src/theory.rs" 132 8 136 9
  
  let%span span4 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span5 = "/Users/xavier/Code/cdsat/src/theory.rs" 82 8 82 36
  
  let%span span6 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span7 = "/Users/xavier/Code/cdsat/src/theory.rs" 122 8 126 9
  
  let%span span8 = "/Users/xavier/Code/cdsat/src/theory.rs" 346 8 349 9
  
  let%span span9 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span10 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  let%span span11 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span span12 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span13 = "/Users/xavier/Code/cdsat/src/theory.rs" 601 8 605 9
  
  let%span span14 = "/Users/xavier/Code/cdsat/src/theory.rs" 337 8 340 9
  
  let%span span15 = "/Users/xavier/Code/cdsat/src/theory.rs" 465 14 468 5
  
  let%span span16 = "/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 111
  
  let%span span17 = "/Users/xavier/Code/cdsat/src/theory.rs" 470 4 470 104
  
  let%span span18 = "/Users/xavier/Code/cdsat/src/theory.rs" 472 8 481 9
  
  let%span span19 = "/Users/xavier/Code/cdsat/src/theory.rs" 504 8 507 9
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  use Cdsat_Theory_Value_Type as Value'0
  
  use Cdsat_Theory_Term_Type as Term'0
  
  function to_pair'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 131 4 131 41] (self : Assign'0.t_assign) : (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span3] match self with
      | Assign'0.C_Decision t val' -> (t, val')
      | Assign'0.C_Input t val' -> (t, val')
      | Assign'0.C_Justified _ t val' -> (t, val')
      end
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span4] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  predicate is_bool'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 81 4 81 32] (self : Value'0.t_value) =
    [%#span5] sort'0 self = Sort'0.C_Boolean
  
  use prelude.prelude.Int
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span6] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'0 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 121 4 121 34] (self : Assign'0.t_assign) =
    [%#span7] match self with
      | Assign'0.C_Decision t v -> sort'1 t = sort'0 v
      | Assign'0.C_Justified _ t v -> sort'1 t = sort'0 v /\ sort'1 t = Sort'0.C_Boolean
      | Assign'0.C_Input t v -> sort'1 t = sort'0 v
      end
  
  predicate invariant_assign'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 345 4 345 41] (self : Trail'0.t_trail) =
    [%#span8] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_assign'0 tl /\ invariant'0 a
      end
  
  use prelude.prelude.Int
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span10] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span9] len'0 self >= 0
  
  function level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int =
    [%#span13] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> 1 + level'0 tl
      | Trail'0.C_Assign _ _ tl -> level'0 tl
      end
  
  axiom level'0_spec : forall self : Trail'0.t_trail . ([%#span12] level'0 self <= len'0 self)
  && ([%#span11] level'0 self >= 0)
  
  predicate invariant_nonneg'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 336 4 336 41] (self : Trail'0.t_trail) =
    [%#span14] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_nonneg'0 tl /\ l >= 0 /\ l <= level'0 self
      end
  
  use Core_Option_Option_Type as Option'0
  
  function find'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 471 4 471 64] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Option'0.t_option (Assign'0.t_assign, int)
    
   =
    [%#span18] match self with
      | Trail'0.C_Empty -> Option'0.C_None
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then Option'0.C_Some (a, l) else find'0 tl d
      end
  
  axiom find'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span17] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'1 (let (a, _) = d in a) = sort'0 (let (_, a) = d in a)))
  && ([%#span16] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
  && ([%#span15] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
  
  predicate is_justified'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 503 4 503 55] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span19] match find'0 self d with
      | Option'0.C_Some (Assign'0.C_Justified _ _ _, _) -> true
      | _ -> false
      end
  
  constant self  : Trail'0.t_trail
  
  constant d  : (Term'0.t_term, Value'0.t_value)
  
  function justified_is_bool [#"/Users/xavier/Code/cdsat/src/theory.rs" 809 4 809 52] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : ()
    
  
  goal vc_justified_is_bool : ([%#stheory1] is_justified'0 self d)
   -> ([%#stheory0] invariant_assign'0 self)
   -> match self with
    | Trail'0.C_Empty -> [%#stheory2] is_bool'0 (let (_, a) = d in a)
    | Trail'0.C_Assign a l tl -> match to_pair'0 a = d with
      | True -> [%#stheory2] is_bool'0 (let (_, a) = d in a)
      | False -> (([%#stheory1] is_justified'0 tl d) && ([%#stheory0] invariant_assign'0 tl))
      /\ (([%#stheory2] is_bool'0 (let (_, a) = d in a))
       -> (let _ = justified_is_bool tl d in [%#stheory2] is_bool'0 (let (_, a) = d in a)))
      end
    end
end
module Cdsat_Theory_Impl5_JustificationContains_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 658 15 658 31
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 659 15 659 36
  
  let%span stheory2 = "/Users/xavier/Code/cdsat/src/theory.rs" 660 4 660 126
  
  let%span stheory3 = "/Users/xavier/Code/cdsat/src/theory.rs" 661 14 661 73
  
  let%span span4 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span5 = "/Users/xavier/Code/cdsat/src/theory.rs" 157 8 159 9
  
  let%span span6 = "/Users/xavier/Code/cdsat/src/theory.rs" 132 8 136 9
  
  let%span span7 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 53 8 53 26
  
  let%span span8 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span9 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  let%span span10 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span span11 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span12 = "/Users/xavier/Code/cdsat/src/theory.rs" 601 8 605 9
  
  let%span span13 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span14 = "/Users/xavier/Code/cdsat/src/theory.rs" 122 8 126 9
  
  let%span span15 = "/Users/xavier/Code/cdsat/src/theory.rs" 346 8 349 9
  
  let%span span16 = "/Users/xavier/Code/cdsat/src/theory.rs" 337 8 340 9
  
  let%span span17 = "/Users/xavier/Code/cdsat/src/theory.rs" 465 14 468 5
  
  let%span span18 = "/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 111
  
  let%span span19 = "/Users/xavier/Code/cdsat/src/theory.rs" 470 4 470 104
  
  let%span span20 = "/Users/xavier/Code/cdsat/src/theory.rs" 472 8 481 9
  
  let%span span21 = "/Users/xavier/Code/cdsat/src/theory.rs" 406 15 406 38
  
  let%span span22 = "/Users/xavier/Code/cdsat/src/theory.rs" 407 14 407 51
  
  let%span span23 = "/Users/xavier/Code/cdsat/src/theory.rs" 409 8 412 9
  
  let%span span24 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 16 8 16 26
  
  let%span span25 = "/Users/xavier/Code/cdsat/src/theory.rs" 281 15 281 38
  
  let%span span26 = "/Users/xavier/Code/cdsat/src/theory.rs" 282 4 282 74
  
  let%span span27 = "/Users/xavier/Code/cdsat/src/theory.rs" 283 4 283 94
  
  let%span span28 = "/Users/xavier/Code/cdsat/src/theory.rs" 284 4 284 48
  
  let%span span29 = "/Users/xavier/Code/cdsat/src/theory.rs" 285 14 285 25
  
  let%span span30 = "/Users/xavier/Code/cdsat/src/theory.rs" 286 14 286 36
  
  let%span span31 = "/Users/xavier/Code/cdsat/src/theory.rs" 280 14 280 21
  
  let%span span32 = "/Users/xavier/Code/cdsat/src/theory.rs" 278 4 278 12
  
  let%span span33 = "/Users/xavier/Code/cdsat/src/theory.rs" 417 4 417 87
  
  let%span span34 = "/Users/xavier/Code/cdsat/src/theory.rs" 419 8 422 9
  
  let%span span35 = "/Users/xavier/Code/cdsat/src/theory.rs" 167 18 167 22
  
  let%span span36 = "/Users/xavier/Code/cdsat/src/theory.rs" 166 4 166 62
  
  let%span span37 = "/Users/xavier/Code/cdsat/src/theory.rs" 168 8 188 9
  
  let%span span38 = "/Users/xavier/Code/cdsat/src/theory.rs" 194 8 194 31
  
  let%span span39 = "/Users/xavier/Code/cdsat/src/theory.rs" 200 8 200 71
  
  let%span span40 = "/Users/xavier/Code/cdsat/src/theory.rs" 142 8 147 9
  
  let%span span41 = "/Users/xavier/Code/cdsat/src/theory.rs" 262 8 265 9
  
  let%span span42 = "/Users/xavier/Code/cdsat/src/theory.rs" 619 15 619 27
  
  let%span span43 = "/Users/xavier/Code/cdsat/src/theory.rs" 620 15 620 32
  
  let%span span44 = "/Users/xavier/Code/cdsat/src/theory.rs" 621 4 621 90
  
  let%span span45 = "/Users/xavier/Code/cdsat/src/theory.rs" 623 8 632 9
  
  let%span span46 = "/Users/xavier/Code/cdsat/src/theory.rs" 514 8 517 9
  
  let%span span47 = "/Users/xavier/Code/cdsat/src/theory.rs" 524 8 527 9
  
  let%span span48 = "/Users/xavier/Code/cdsat/src/theory.rs" 206 8 206 84
  
  let%span span49 = "/Users/xavier/Code/cdsat/src/theory.rs" 504 8 507 9
  
  let%span span50 = "/Users/xavier/Code/cdsat/src/theory.rs" 82 8 82 36
  
  let%span span51 = "/Users/xavier/Code/cdsat/src/theory.rs" 96 15 96 29
  
  let%span span52 = "/Users/xavier/Code/cdsat/src/theory.rs" 97 14 97 30
  
  let%span span53 = "/Users/xavier/Code/cdsat/src/theory.rs" 99 8 102 9
  
  let%span span54 = "/Users/xavier/Code/cdsat/src/theory.rs" 374 8 382 9
  
  let%span span55 = "/Users/xavier/Code/cdsat/src/theory.rs" 355 8 368 9
  
  let%span span56 = "/Users/xavier/Code/cdsat/src/theory.rs" 321 8 331 9
  
  let%span span57 = "/Users/xavier/Code/cdsat/src/theory.rs" 388 8 392 38
  
  let%span span58 = "/Users/xavier/Code/cdsat/src/theory.rs" 486 15 486 31
  
  let%span span59 = "/Users/xavier/Code/cdsat/src/theory.rs" 487 15 487 35
  
  let%span span60 = "/Users/xavier/Code/cdsat/src/theory.rs" 488 15 488 27
  
  let%span span61 = "/Users/xavier/Code/cdsat/src/theory.rs" 489 4 489 54
  
  let%span span62 = "/Users/xavier/Code/cdsat/src/theory.rs" 490 4 490 58
  
  let%span span63 = "/Users/xavier/Code/cdsat/src/theory.rs" 491 4 491 61
  
  let%span span64 = "/Users/xavier/Code/cdsat/src/theory.rs" 493 8 493 30
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  use Cdsat_Theory_Value_Type as Value'0
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span4] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  use map.Map
  
  use Cdsat_Theory_Model_Type as Cdsat_Theory_Model_Type
  
  use Cdsat_Theory_Var_Type as Var'0
  
  use Cdsat_Theory_Model_Type as Model'0
  
  predicate invariant'2 [#"/Users/xavier/Code/cdsat/src/theory.rs" 156 4 156 30] (self : Model'0.t_model) =
    [%#span5] forall v : Value'0.t_value . forall k : Var'0.t_var . Map.get (Cdsat_Theory_Model_Type.model_0 self) k = v
     -> Cdsat_Theory_Var_Type.var_1 k = sort'1 v
  
  predicate inv'0 (_x : Model'0.t_model)
  
  axiom inv'0 : forall x : Model'0.t_model . inv'0 x
  = (invariant'2 x
  /\ match x with
    | Model'0.C_Model a_0 -> true
    end)
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  use Cdsat_Theory_Term_Type as Term'0
  
  function to_pair'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 131 4 131 41] (self : Assign'0.t_assign) : (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span6] match self with
      | Assign'0.C_Decision t val' -> (t, val')
      | Assign'0.C_Input t val' -> (t, val')
      | Assign'0.C_Justified _ t val' -> (t, val')
      end
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  use set.Fset
  
  use set.Fset
  
  function remove'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (a : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span7] Fset.remove a self
  
  use set.Fset
  
  use set.Fset
  
  use prelude.prelude.Int
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span9] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span8] len'0 self >= 0
  
  function level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int =
    [%#span12] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> 1 + level'0 tl
      | Trail'0.C_Assign _ _ tl -> level'0 tl
      end
  
  axiom level'0_spec : forall self : Trail'0.t_trail . ([%#span11] level'0 self <= len'0 self)
  && ([%#span10] level'0 self >= 0)
  
  use set.Fset
  
  use prelude.prelude.Int
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span13] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'1 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  predicate invariant'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 121 4 121 34] (self : Assign'0.t_assign) =
    [%#span14] match self with
      | Assign'0.C_Decision t v -> sort'0 t = sort'1 v
      | Assign'0.C_Justified _ t v -> sort'0 t = sort'1 v /\ sort'0 t = Sort'0.C_Boolean
      | Assign'0.C_Input t v -> sort'0 t = sort'1 v
      end
  
  predicate invariant_assign'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 345 4 345 41] (self : Trail'0.t_trail) =
    [%#span15] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_assign'0 tl /\ invariant'1 a
      end
  
  predicate invariant_nonneg'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 336 4 336 41] (self : Trail'0.t_trail) =
    [%#span16] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_nonneg'0 tl /\ l >= 0 /\ l <= level'0 self
      end
  
  use Core_Option_Option_Type as Option'0
  
  function find'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 471 4 471 64] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Option'0.t_option (Assign'0.t_assign, int)
    
   =
    [%#span20] match self with
      | Trail'0.C_Empty -> Option'0.C_None
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then Option'0.C_Some (a, l) else find'0 tl d
      end
  
  axiom find'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span19] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)))
  && ([%#span18] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
  && ([%#span17] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
  
  function level_of'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 408 4 408 50] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : int
    
   =
    [%#span23] match find'0 self d with
      | Option'0.C_Some (_, l) -> l
      | Option'0.C_None -> 0
      end
  
  axiom level_of'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span21] invariant_nonneg'0 self)
   -> ([%#span22] level_of'0 self d >= 0 /\ level_of'0 self d <= level'0 self)
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (e : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span24] Fset.mem e self
  
  function set_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 287 4 287 57] (self : Trail'0.t_trail) (s : Fset.fset (Term'0.t_term, Value'0.t_value)) : int
    
  
  axiom set_level'0_def : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . set_level'0 self s
  = ([%#span32] if Fset.cardinal s = 0 then
    0
  else
    if Fset.cardinal s = 1 then
      level_of'0 self (Fset.pick s)
    else
      let a = Fset.pick s in let rec' = set_level'0 self (remove'0 s a) in if level_of'0 self a >= rec' then
        level_of'0 self a
      else
        rec'
      
    
  )
  
  axiom set_level'0_spec : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . ([%#span25] invariant_nonneg'0 self)
   -> ([%#span30] set_level'0 self s <= level'0 self)
  && ([%#span29] set_level'0 self s >= 0)
  && ([%#span28] s = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))  -> set_level'0 self s = 0)
  && ([%#span27] s <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
   -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'0 s i /\ level_of'0 self i = set_level'0 self s))
  && ([%#span26] forall i : (Term'0.t_term, Value'0.t_value) . contains'0 s i
   -> level_of'0 self i <= set_level'0 self s)
  
  predicate contains'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 418 4 418 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span34] match find'0 self d with
      | Option'0.C_Some ix -> true
      | Option'0.C_None -> false
      end
  
  axiom contains'1_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . [%#span33] invariant_assign'0 self
   -> contains'1 self d = true  -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)
  
  use prelude.prelude.Real
  
  function from_int'0 (_1 : int) : Real.real
  
  function interp'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 167 4 167 41] (self : Model'0.t_model) (t : Term'0.t_term) : Value'0.t_value
    
   =
    [%#span37] match t with
      | Term'0.C_Variable v -> Map.get (Cdsat_Theory_Model_Type.model_0 self) v
      | Term'0.C_Value v -> v
      | Term'0.C_Plus l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Rat r1, Value'0.C_Rat r2) -> Value'0.C_Rat r1
        | _ -> Value'0.C_Rat (from_int'0 (- 1))
        end
      | Term'0.C_Conj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 /\ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Disj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 \/ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Eq l r -> Value'0.C_Bool (interp'0 self l = interp'0 self r)
      | Term'0.C_Neg t -> match interp'0 self t with
        | Value'0.C_Bool b -> Value'0.C_Bool (not b)
        | _ -> Value'0.C_Bool false
        end
      end
  
  axiom interp'0_spec : forall self : Model'0.t_model, t : Term'0.t_term . ([%#span35] inv'0 self)
   -> ([%#span36] invariant'2 self  -> sort'1 (interp'0 self t) = sort'0 t)
  
  predicate satisfies'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 193 4 193 52] (self : Model'0.t_model) (v : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span38] interp'0 self (let (a, _) = v in a) = (let (_, a) = v in a)
  
  predicate satisfy_set'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 199 4 199 60] (self : Model'0.t_model) (v : Fset.fset (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span39] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 v a  -> satisfies'0 self a
  
  predicate justified_sound'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 141 4 141 40] (self : Assign'0.t_assign) =
    [%#span40] match self with
      | Assign'0.C_Justified just t val' -> forall m : Model'0.t_model . inv'0 m
       -> satisfy_set'0 m just  -> satisfies'0 m (t, val')
      | _ -> true
      end
  
  predicate sound'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 261 4 261 30] (self : Trail'0.t_trail)
   =
    [%#span41] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a _ tl -> sound'0 tl /\ justified_sound'0 a
      end
  
  function find_justified'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 622 4 622 46] (self : Trail'0.t_trail) (kv : (Term'0.t_term, Value'0.t_value)) : ()
    
   =
    [%#span45] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = kv then () else find_justified'0 tl kv
      end
  
  axiom find_justified'0_spec : forall self : Trail'0.t_trail, kv : (Term'0.t_term, Value'0.t_value) . ([%#span42] sound'0 self)
   -> ([%#span43] contains'1 self kv)
   -> ([%#span44] forall l : int . forall a : Assign'0.t_assign . find'0 self kv = Option'0.C_Some (a, l)
   -> justified_sound'0 a)
  
  predicate is_decision'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 513 4 513 54] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span46] match find'0 self d with
      | Option'0.C_Some (Assign'0.C_Decision _ _, _) -> true
      | _ -> false
      end
  
  predicate is_input'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 523 4 523 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span47] match find'0 self d with
      | Option'0.C_Some (Assign'0.C_Input _ _, _) -> true
      | _ -> false
      end
  
  predicate entails'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 205 4 205 74] (self : Model'0.t_model) (j : Fset.fset (Term'0.t_term, Value'0.t_value)) (c : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span48] invariant'2 self  -> satisfy_set'0 self j  -> satisfies'0 self c
  
  predicate is_justified'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 503 4 503 55] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span49] match find'0 self d with
      | Option'0.C_Some (Assign'0.C_Justified _ _ _, _) -> true
      | _ -> false
      end
  
  predicate is_bool'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 81 4 81 32] (self : Value'0.t_value) =
    [%#span50] sort'1 self = Sort'0.C_Boolean
  
  function negate'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 98 4 98 31] (self : Value'0.t_value) : Value'0.t_value =
    [%#span53] match self with
      | Value'0.C_Bool b -> Value'0.C_Bool (not b)
      | _ -> self
      end
  
  axiom negate'0_spec : forall self : Value'0.t_value . ([%#span51] is_bool'0 self)
   -> ([%#span52] is_bool'0 (negate'0 self))
  
  predicate trail_unique'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 373 4 373 37] (self : Trail'0.t_trail) =
    [%#span54] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> let ap = to_pair'0 a in not contains'1 tl ap
      /\ trail_unique'0 tl
      /\ (if is_bool'0 (let (_, a) = ap in a) then
        not contains'1 tl ((let (a, _) = ap in a), negate'0 (let (_, a) = ap in a))
      else
        true
      )
      end
  
  predicate invariant_contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 354 4 354 43] (self : Trail'0.t_trail) =
    [%#span55] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_contains'0 tl
      /\ match a with
        | Assign'0.C_Justified j _ _ -> forall a : (Term'0.t_term, Value'0.t_value) . contains'0 j a  -> contains'1 tl a
        | _ -> true
        end
      end
  
  predicate invariant_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 320 4 320 40] (self : Trail'0.t_trail) =
    [%#span56] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_level'0 tl
      /\ match a with
        | Assign'0.C_Input _ _ -> l = 0
        | Assign'0.C_Decision _ _ -> level'0 tl + 1 = l
        | Assign'0.C_Justified j _ _ -> set_level'0 tl j = l
        end
      end
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 387 4 387 34] (self : Trail'0.t_trail) =
    [%#span57] invariant_level'0 self
    /\ invariant_contains'0 self /\ trail_unique'0 self /\ invariant_nonneg'0 self /\ invariant_assign'0 self
  
  function justification'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 492 4 492 71] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span64] let _ = find_justified'0 self d in match find'0 self d with
      | Option'0.C_Some (Assign'0.C_Justified j _ _, _) -> j
      | _ -> Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value)
      end
  
  axiom justification'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span58] invariant'0 self)
   -> ([%#span59] is_justified'0 self d)
   -> ([%#span60] sound'0 self)
   -> ([%#span63] is_decision'0 self d
   -> justification'0 self d = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value)))
  && ([%#span62] is_input'0 self d
   -> justification'0 self d = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value)))
  && ([%#span61] forall m : Model'0.t_model . inv'0 m  -> entails'0 m (justification'0 self d) d)
  
  constant self  : Trail'0.t_trail
  
  constant kv  : (Term'0.t_term, Value'0.t_value)
  
  function justification_contains [#"/Users/xavier/Code/cdsat/src/theory.rs" 662 4 662 58] (self : Trail'0.t_trail) (kv : (Term'0.t_term, Value'0.t_value)) : ()
    
  
  goal vc_justification_contains : ([%#stheory1] is_justified'0 self kv)
   -> ([%#stheory0] invariant'0 self)
   -> match self with
    | Trail'0.C_Empty -> ([%#stheory3] set_level'0 self (justification'0 self kv) = level_of'0 self kv)
    && ([%#stheory2] forall e : (Term'0.t_term, Value'0.t_value) . contains'0 (justification'0 self kv) e
     -> contains'1 self e /\ level_of'0 self e <= level_of'0 self kv)
    | Trail'0.C_Assign a l tl -> match to_pair'0 a = kv with
      | True -> ([%#stheory3] set_level'0 self (justification'0 self kv) = level_of'0 self kv)
      && ([%#stheory2] forall e : (Term'0.t_term, Value'0.t_value) . contains'0 (justification'0 self kv) e
       -> contains'1 self e /\ level_of'0 self e <= level_of'0 self kv)
      | False -> (([%#stheory1] is_justified'0 tl kv) && ([%#stheory0] invariant'0 tl))
      /\ (([%#stheory3] set_level'0 tl (justification'0 tl kv) = level_of'0 tl kv)
      && ([%#stheory2] forall e : (Term'0.t_term, Value'0.t_value) . contains'0 (justification'0 tl kv) e
       -> contains'1 tl e /\ level_of'0 tl e <= level_of'0 tl kv)
       -> ([%#stheory3] set_level'0 self (justification'0 self kv) = level_of'0 self kv)
      && ([%#stheory2] forall e : (Term'0.t_term, Value'0.t_value) . contains'0 (justification'0 self kv) e
       -> contains'1 self e /\ level_of'0 self e <= level_of'0 self kv))
      end
    end
end
module Cdsat_Theory_Impl4_ResolveSound_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 211 4 211 61
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 212 15 212 39
  
  let%span stheory2 = "/Users/xavier/Code/cdsat/src/theory.rs" 213 15 213 32
  
  let%span stheory3 = "/Users/xavier/Code/cdsat/src/theory.rs" 216 8 216 12
  
  let%span stheory4 = "/Users/xavier/Code/cdsat/src/theory.rs" 214 14 214 60
  
  let%span span5 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span6 = "/Users/xavier/Code/cdsat/src/theory.rs" 157 8 159 9
  
  let%span span7 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 53 8 53 26
  
  let%span span8 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 16 8 16 26
  
  let%span span9 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span10 = "/Users/xavier/Code/cdsat/src/theory.rs" 167 18 167 22
  
  let%span span11 = "/Users/xavier/Code/cdsat/src/theory.rs" 166 4 166 62
  
  let%span span12 = "/Users/xavier/Code/cdsat/src/theory.rs" 168 8 188 9
  
  let%span span13 = "/Users/xavier/Code/cdsat/src/theory.rs" 194 8 194 31
  
  let%span span14 = "/Users/xavier/Code/cdsat/src/theory.rs" 200 8 200 71
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  use Cdsat_Theory_Value_Type as Value'0
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span5] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  use map.Map
  
  use Cdsat_Theory_Model_Type as Cdsat_Theory_Model_Type
  
  use Cdsat_Theory_Var_Type as Var'0
  
  use Cdsat_Theory_Model_Type as Model'0
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 156 4 156 30] (self : Model'0.t_model) =
    [%#span6] forall v : Value'0.t_value . forall k : Var'0.t_var . Map.get (Cdsat_Theory_Model_Type.model_0 self) k = v
     -> Cdsat_Theory_Var_Type.var_1 k = sort'0 v
  
  predicate inv'0 (_x : Model'0.t_model)
  
  axiom inv'0 : forall x : Model'0.t_model . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Model'0.C_Model a_0 -> true
    end)
  
  use Cdsat_Theory_Term_Type as Term'0
  
  use set.Fset
  
  use set.Fset
  
  use set.Fset
  
  function remove'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (a : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span7] Fset.remove a self
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (e : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span8] Fset.mem e self
  
  use prelude.prelude.Real
  
  use prelude.prelude.Int
  
  function from_int'0 (_1 : int) : Real.real
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span9] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'0 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  function interp'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 167 4 167 41] (self : Model'0.t_model) (t : Term'0.t_term) : Value'0.t_value
    
   =
    [%#span12] match t with
      | Term'0.C_Variable v -> Map.get (Cdsat_Theory_Model_Type.model_0 self) v
      | Term'0.C_Value v -> v
      | Term'0.C_Plus l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Rat r1, Value'0.C_Rat r2) -> Value'0.C_Rat r1
        | _ -> Value'0.C_Rat (from_int'0 (- 1))
        end
      | Term'0.C_Conj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 /\ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Disj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 \/ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Eq l r -> Value'0.C_Bool (interp'0 self l = interp'0 self r)
      | Term'0.C_Neg t -> match interp'0 self t with
        | Value'0.C_Bool b -> Value'0.C_Bool (not b)
        | _ -> Value'0.C_Bool false
        end
      end
  
  axiom interp'0_spec : forall self : Model'0.t_model, t : Term'0.t_term . ([%#span10] inv'0 self)
   -> ([%#span11] invariant'0 self  -> sort'0 (interp'0 self t) = sort'1 t)
  
  predicate satisfies'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 193 4 193 52] (self : Model'0.t_model) (v : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span13] interp'0 self (let (a, _) = v in a) = (let (_, a) = v in a)
  
  predicate satisfy_set'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 199 4 199 60] (self : Model'0.t_model) (v : Fset.fset (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span14] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 v a  -> satisfies'0 self a
  
  constant self  : Model'0.t_model
  
  constant cflct  : Fset.fset (Term'0.t_term, Value'0.t_value)
  
  constant just  : Fset.fset (Term'0.t_term, Value'0.t_value)
  
  constant a  : (Term'0.t_term, Value'0.t_value)
  
  function resolve_sound [#"/Users/xavier/Code/cdsat/src/theory.rs" 215 4 220 5] (self : Model'0.t_model) (cflct : Fset.fset (Term'0.t_term, Value'0.t_value)) (just : Fset.fset (Term'0.t_term, Value'0.t_value)) (a : (Term'0.t_term, Value'0.t_value)) : ()
    
  
  goal vc_resolve_sound : ([%#stheory3] inv'0 self)
   -> ([%#stheory2] contains'0 cflct a)
   -> ([%#stheory1] not satisfy_set'0 self cflct)
   -> ([%#stheory0] satisfy_set'0 self just  -> satisfies'0 self a)
   -> ([%#stheory4] not satisfy_set'0 self (Fset.union (remove'0 cflct a) just))
end
module Cdsat_Theory_Impl7_Resolvef_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 1023 15 1023 31
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 1024 15 1024 27
  
  let%span stheory2 = "/Users/xavier/Code/cdsat/src/theory.rs" 1025 4 1025 39
  
  let%span stheory3 = "/Users/xavier/Code/cdsat/src/theory.rs" 1026 4 1026 35
  
  let%span stheory4 = "/Users/xavier/Code/cdsat/src/theory.rs" 1027 4 1031 6
  
  let%span stheory5 = "/Users/xavier/Code/cdsat/src/theory.rs" 1032 14 1032 32
  
  let%span stheory6 = "/Users/xavier/Code/cdsat/src/theory.rs" 1033 14 1033 28
  
  let%span stheory7 = "/Users/xavier/Code/cdsat/src/theory.rs" 1034 14 1034 44
  
  let%span stheory8 = "/Users/xavier/Code/cdsat/src/theory.rs" 486 15 486 31
  
  let%span stheory9 = "/Users/xavier/Code/cdsat/src/theory.rs" 487 15 487 35
  
  let%span stheory10 = "/Users/xavier/Code/cdsat/src/theory.rs" 488 15 488 27
  
  let%span stheory11 = "/Users/xavier/Code/cdsat/src/theory.rs" 489 4 489 54
  
  let%span stheory12 = "/Users/xavier/Code/cdsat/src/theory.rs" 490 4 490 58
  
  let%span stheory13 = "/Users/xavier/Code/cdsat/src/theory.rs" 491 4 491 61
  
  let%span stheory14 = "/Users/xavier/Code/cdsat/src/theory.rs" 658 15 658 31
  
  let%span stheory15 = "/Users/xavier/Code/cdsat/src/theory.rs" 659 15 659 36
  
  let%span stheory16 = "/Users/xavier/Code/cdsat/src/theory.rs" 660 4 660 126
  
  let%span stheory17 = "/Users/xavier/Code/cdsat/src/theory.rs" 661 14 661 73
  
  let%span span18 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span19 = "/Users/xavier/Code/cdsat/src/theory.rs" 157 8 159 9
  
  let%span span20 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 53 8 53 26
  
  let%span span21 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 16 8 16 26
  
  let%span span22 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span23 = "/Users/xavier/Code/cdsat/src/theory.rs" 167 18 167 22
  
  let%span span24 = "/Users/xavier/Code/cdsat/src/theory.rs" 166 4 166 62
  
  let%span span25 = "/Users/xavier/Code/cdsat/src/theory.rs" 168 8 188 9
  
  let%span span26 = "/Users/xavier/Code/cdsat/src/theory.rs" 194 8 194 31
  
  let%span span27 = "/Users/xavier/Code/cdsat/src/theory.rs" 200 8 200 71
  
  let%span span28 = "/Users/xavier/Code/cdsat/src/theory.rs" 211 4 211 61
  
  let%span span29 = "/Users/xavier/Code/cdsat/src/theory.rs" 212 15 212 39
  
  let%span span30 = "/Users/xavier/Code/cdsat/src/theory.rs" 213 15 213 32
  
  let%span span31 = "/Users/xavier/Code/cdsat/src/theory.rs" 216 8 216 12
  
  let%span span32 = "/Users/xavier/Code/cdsat/src/theory.rs" 214 14 214 60
  
  let%span span33 = "/Users/xavier/Code/cdsat/src/theory.rs" 209 4 209 12
  
  let%span span34 = "/Users/xavier/Code/cdsat/src/theory.rs" 122 8 126 9
  
  let%span span35 = "/Users/xavier/Code/cdsat/src/theory.rs" 346 8 349 9
  
  let%span span36 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span37 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  let%span span38 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span span39 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span40 = "/Users/xavier/Code/cdsat/src/theory.rs" 601 8 605 9
  
  let%span span41 = "/Users/xavier/Code/cdsat/src/theory.rs" 337 8 340 9
  
  let%span span42 = "/Users/xavier/Code/cdsat/src/theory.rs" 132 8 136 9
  
  let%span span43 = "/Users/xavier/Code/cdsat/src/theory.rs" 465 14 468 5
  
  let%span span44 = "/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 111
  
  let%span span45 = "/Users/xavier/Code/cdsat/src/theory.rs" 470 4 470 104
  
  let%span span46 = "/Users/xavier/Code/cdsat/src/theory.rs" 472 8 481 9
  
  let%span span47 = "/Users/xavier/Code/cdsat/src/theory.rs" 417 4 417 87
  
  let%span span48 = "/Users/xavier/Code/cdsat/src/theory.rs" 419 8 422 9
  
  let%span span49 = "/Users/xavier/Code/cdsat/src/theory.rs" 406 15 406 38
  
  let%span span50 = "/Users/xavier/Code/cdsat/src/theory.rs" 407 14 407 51
  
  let%span span51 = "/Users/xavier/Code/cdsat/src/theory.rs" 409 8 412 9
  
  let%span span52 = "/Users/xavier/Code/cdsat/src/theory.rs" 281 15 281 38
  
  let%span span53 = "/Users/xavier/Code/cdsat/src/theory.rs" 282 4 282 74
  
  let%span span54 = "/Users/xavier/Code/cdsat/src/theory.rs" 283 4 283 94
  
  let%span span55 = "/Users/xavier/Code/cdsat/src/theory.rs" 284 4 284 48
  
  let%span span56 = "/Users/xavier/Code/cdsat/src/theory.rs" 285 14 285 25
  
  let%span span57 = "/Users/xavier/Code/cdsat/src/theory.rs" 286 14 286 36
  
  let%span span58 = "/Users/xavier/Code/cdsat/src/theory.rs" 280 14 280 21
  
  let%span span59 = "/Users/xavier/Code/cdsat/src/theory.rs" 278 4 278 12
  
  let%span span60 = "/Users/xavier/Code/cdsat/src/theory.rs" 142 8 147 9
  
  let%span span61 = "/Users/xavier/Code/cdsat/src/theory.rs" 262 8 265 9
  
  let%span span62 = "/Users/xavier/Code/cdsat/src/theory.rs" 619 15 619 27
  
  let%span span63 = "/Users/xavier/Code/cdsat/src/theory.rs" 620 15 620 32
  
  let%span span64 = "/Users/xavier/Code/cdsat/src/theory.rs" 621 4 621 90
  
  let%span span65 = "/Users/xavier/Code/cdsat/src/theory.rs" 623 8 632 9
  
  let%span span66 = "/Users/xavier/Code/cdsat/src/theory.rs" 514 8 517 9
  
  let%span span67 = "/Users/xavier/Code/cdsat/src/theory.rs" 524 8 527 9
  
  let%span span68 = "/Users/xavier/Code/cdsat/src/theory.rs" 206 8 206 84
  
  let%span span69 = "/Users/xavier/Code/cdsat/src/theory.rs" 504 8 507 9
  
  let%span span70 = "/Users/xavier/Code/cdsat/src/theory.rs" 82 8 82 36
  
  let%span span71 = "/Users/xavier/Code/cdsat/src/theory.rs" 96 15 96 29
  
  let%span span72 = "/Users/xavier/Code/cdsat/src/theory.rs" 97 14 97 30
  
  let%span span73 = "/Users/xavier/Code/cdsat/src/theory.rs" 99 8 102 9
  
  let%span span74 = "/Users/xavier/Code/cdsat/src/theory.rs" 374 8 382 9
  
  let%span span75 = "/Users/xavier/Code/cdsat/src/theory.rs" 355 8 368 9
  
  let%span span76 = "/Users/xavier/Code/cdsat/src/theory.rs" 321 8 331 9
  
  let%span span77 = "/Users/xavier/Code/cdsat/src/theory.rs" 388 8 392 38
  
  let%span span78 = "/Users/xavier/Code/cdsat/src/theory.rs" 493 8 493 30
  
  let%span span79 = "/Users/xavier/Code/cdsat/src/theory.rs" 663 8 672 9
  
  let%span span80 = "/Users/xavier/Code/cdsat/src/theory.rs" 1002 4 1002 12
  
  let%span span81 = "/Users/xavier/Code/cdsat/src/theory.rs" 999 8 999 91
  
  let%span span82 = "/Users/xavier/Code/cdsat/src/theory.rs" 992 8 992 131
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  use Cdsat_Theory_Value_Type as Value'0
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span18] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  use map.Map
  
  use Cdsat_Theory_Model_Type as Cdsat_Theory_Model_Type
  
  use Cdsat_Theory_Var_Type as Var'0
  
  use Cdsat_Theory_Model_Type as Model'0
  
  predicate invariant'2 [#"/Users/xavier/Code/cdsat/src/theory.rs" 156 4 156 30] (self : Model'0.t_model) =
    [%#span19] forall v : Value'0.t_value . forall k : Var'0.t_var . Map.get (Cdsat_Theory_Model_Type.model_0 self) k
    = v  -> Cdsat_Theory_Var_Type.var_1 k = sort'0 v
  
  predicate inv'0 (_x : Model'0.t_model)
  
  axiom inv'0 : forall x : Model'0.t_model . inv'0 x
  = (invariant'2 x
  /\ match x with
    | Model'0.C_Model a_0 -> true
    end)
  
  use set.Fset
  
  use set.Fset
  
  use Cdsat_Theory_Term_Type as Term'0
  
  use set.Fset
  
  function remove'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (a : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span20] Fset.remove a self
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (e : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span21] Fset.mem e self
  
  use prelude.prelude.Real
  
  use prelude.prelude.Int
  
  function from_int'0 (_1 : int) : Real.real
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span22] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'0 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  function interp'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 167 4 167 41] (self : Model'0.t_model) (t : Term'0.t_term) : Value'0.t_value
    
   =
    [%#span25] match t with
      | Term'0.C_Variable v -> Map.get (Cdsat_Theory_Model_Type.model_0 self) v
      | Term'0.C_Value v -> v
      | Term'0.C_Plus l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Rat r1, Value'0.C_Rat r2) -> Value'0.C_Rat r1
        | _ -> Value'0.C_Rat (from_int'0 (- 1))
        end
      | Term'0.C_Conj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 /\ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Disj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 \/ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Eq l r -> Value'0.C_Bool (interp'0 self l = interp'0 self r)
      | Term'0.C_Neg t -> match interp'0 self t with
        | Value'0.C_Bool b -> Value'0.C_Bool (not b)
        | _ -> Value'0.C_Bool false
        end
      end
  
  axiom interp'0_spec : forall self : Model'0.t_model, t : Term'0.t_term . ([%#span23] inv'0 self)
   -> ([%#span24] invariant'2 self  -> sort'0 (interp'0 self t) = sort'1 t)
  
  predicate satisfies'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 193 4 193 52] (self : Model'0.t_model) (v : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span26] interp'0 self (let (a, _) = v in a) = (let (_, a) = v in a)
  
  predicate satisfy_set'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 199 4 199 60] (self : Model'0.t_model) (v : Fset.fset (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span27] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 v a  -> satisfies'0 self a
  
  function resolve_sound'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 215 4 220 5] (self : Model'0.t_model) (cflct : Fset.fset (Term'0.t_term, Value'0.t_value)) (just : Fset.fset (Term'0.t_term, Value'0.t_value)) (a : (Term'0.t_term, Value'0.t_value)) : ()
    
   =
    [%#span33] ()
  
  axiom resolve_sound'0_spec : forall self : Model'0.t_model, cflct : Fset.fset (Term'0.t_term, Value'0.t_value), just : Fset.fset (Term'0.t_term, Value'0.t_value), a : (Term'0.t_term, Value'0.t_value) . ([%#span28] satisfy_set'0 self just
   -> satisfies'0 self a)
   -> ([%#span29] not satisfy_set'0 self cflct)
   -> ([%#span30] contains'0 cflct a)
   -> ([%#span31] inv'0 self)  -> ([%#span32] not satisfy_set'0 self (Fset.union (remove'0 cflct a) just))
  
  use prelude.prelude.Int
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  predicate invariant'3 [#"/Users/xavier/Code/cdsat/src/theory.rs" 121 4 121 34] (self : Assign'0.t_assign) =
    [%#span34] match self with
      | Assign'0.C_Decision t v -> sort'1 t = sort'0 v
      | Assign'0.C_Justified _ t v -> sort'1 t = sort'0 v /\ sort'1 t = Sort'0.C_Boolean
      | Assign'0.C_Input t v -> sort'1 t = sort'0 v
      end
  
  predicate invariant_assign'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 345 4 345 41] (self : Trail'0.t_trail) =
    [%#span35] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_assign'0 tl /\ invariant'3 a
      end
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span37] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span36] len'0 self >= 0
  
  function level'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int =
    [%#span40] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> 1 + level'1 tl
      | Trail'0.C_Assign _ _ tl -> level'1 tl
      end
  
  axiom level'1_spec : forall self : Trail'0.t_trail . ([%#span39] level'1 self <= len'0 self)
  && ([%#span38] level'1 self >= 0)
  
  predicate invariant_nonneg'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 336 4 336 41] (self : Trail'0.t_trail) =
    [%#span41] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_nonneg'0 tl /\ l >= 0 /\ l <= level'1 self
      end
  
  function to_pair'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 131 4 131 41] (self : Assign'0.t_assign) : (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span42] match self with
      | Assign'0.C_Decision t val' -> (t, val')
      | Assign'0.C_Input t val' -> (t, val')
      | Assign'0.C_Justified _ t val' -> (t, val')
      end
  
  use Core_Option_Option_Type as Option'0
  
  function find'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 471 4 471 64] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Option'0.t_option (Assign'0.t_assign, int)
    
   =
    [%#span46] match self with
      | Trail'0.C_Empty -> Option'0.C_None
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then Option'0.C_Some (a, l) else find'0 tl d
      end
  
  axiom find'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span45] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'1 (let (a, _) = d in a) = sort'0 (let (_, a) = d in a)))
  && ([%#span44] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'1 self))
  && ([%#span43] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
  
  predicate contains'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 418 4 418 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span48] match find'0 self d with
      | Option'0.C_Some ix -> true
      | Option'0.C_None -> false
      end
  
  axiom contains'1_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . [%#span47] invariant_assign'0 self
   -> contains'1 self d = true  -> sort'1 (let (a, _) = d in a) = sort'0 (let (_, a) = d in a)
  
  use set.Fset
  
  use set.Fset
  
  use set.Fset
  
  function level_of'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 408 4 408 50] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : int
    
   =
    [%#span51] match find'0 self d with
      | Option'0.C_Some (_, l) -> l
      | Option'0.C_None -> 0
      end
  
  axiom level_of'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span49] invariant_nonneg'0 self)
   -> ([%#span50] level_of'0 self d >= 0 /\ level_of'0 self d <= level'1 self)
  
  function set_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 287 4 287 57] (self : Trail'0.t_trail) (s : Fset.fset (Term'0.t_term, Value'0.t_value)) : int
    
  
  axiom set_level'0_def : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . set_level'0 self s
  = ([%#span59] if Fset.cardinal s = 0 then
    0
  else
    if Fset.cardinal s = 1 then
      level_of'0 self (Fset.pick s)
    else
      let a = Fset.pick s in let rec' = set_level'0 self (remove'0 s a) in if level_of'0 self a >= rec' then
        level_of'0 self a
      else
        rec'
      
    
  )
  
  axiom set_level'0_spec : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . ([%#span52] invariant_nonneg'0 self)
   -> ([%#span57] set_level'0 self s <= level'1 self)
  && ([%#span56] set_level'0 self s >= 0)
  && ([%#span55] s = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))  -> set_level'0 self s = 0)
  && ([%#span54] s <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
   -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'0 s i /\ level_of'0 self i = set_level'0 self s))
  && ([%#span53] forall i : (Term'0.t_term, Value'0.t_value) . contains'0 s i
   -> level_of'0 self i <= set_level'0 self s)
  
  predicate justified_sound'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 141 4 141 40] (self : Assign'0.t_assign) =
    [%#span60] match self with
      | Assign'0.C_Justified just t val' -> forall m : Model'0.t_model . inv'0 m
       -> satisfy_set'0 m just  -> satisfies'0 m (t, val')
      | _ -> true
      end
  
  predicate sound'1 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 261 4 261 30] (self : Trail'0.t_trail)
   =
    [%#span61] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a _ tl -> sound'1 tl /\ justified_sound'0 a
      end
  
  function find_justified'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 622 4 622 46] (self : Trail'0.t_trail) (kv : (Term'0.t_term, Value'0.t_value)) : ()
    
   =
    [%#span65] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = kv then () else find_justified'0 tl kv
      end
  
  axiom find_justified'0_spec : forall self : Trail'0.t_trail, kv : (Term'0.t_term, Value'0.t_value) . ([%#span62] sound'1 self)
   -> ([%#span63] contains'1 self kv)
   -> ([%#span64] forall l : int . forall a : Assign'0.t_assign . find'0 self kv = Option'0.C_Some (a, l)
   -> justified_sound'0 a)
  
  predicate is_decision'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 513 4 513 54] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span66] match find'0 self d with
      | Option'0.C_Some (Assign'0.C_Decision _ _, _) -> true
      | _ -> false
      end
  
  predicate is_input'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 523 4 523 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span67] match find'0 self d with
      | Option'0.C_Some (Assign'0.C_Input _ _, _) -> true
      | _ -> false
      end
  
  predicate entails'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 205 4 205 74] (self : Model'0.t_model) (j : Fset.fset (Term'0.t_term, Value'0.t_value)) (c : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span68] invariant'2 self  -> satisfy_set'0 self j  -> satisfies'0 self c
  
  predicate is_justified'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 503 4 503 55] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span69] match find'0 self d with
      | Option'0.C_Some (Assign'0.C_Justified _ _ _, _) -> true
      | _ -> false
      end
  
  predicate is_bool'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 81 4 81 32] (self : Value'0.t_value) =
    [%#span70] sort'0 self = Sort'0.C_Boolean
  
  function negate'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 98 4 98 31] (self : Value'0.t_value) : Value'0.t_value =
    [%#span73] match self with
      | Value'0.C_Bool b -> Value'0.C_Bool (not b)
      | _ -> self
      end
  
  axiom negate'0_spec : forall self : Value'0.t_value . ([%#span71] is_bool'0 self)
   -> ([%#span72] is_bool'0 (negate'0 self))
  
  predicate trail_unique'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 373 4 373 37] (self : Trail'0.t_trail) =
    [%#span74] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> let ap = to_pair'0 a in not contains'1 tl ap
      /\ trail_unique'0 tl
      /\ (if is_bool'0 (let (_, a) = ap in a) then
        not contains'1 tl ((let (a, _) = ap in a), negate'0 (let (_, a) = ap in a))
      else
        true
      )
      end
  
  predicate invariant_contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 354 4 354 43] (self : Trail'0.t_trail) =
    [%#span75] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_contains'0 tl
      /\ match a with
        | Assign'0.C_Justified j _ _ -> forall a : (Term'0.t_term, Value'0.t_value) . contains'0 j a  -> contains'1 tl a
        | _ -> true
        end
      end
  
  predicate invariant_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 320 4 320 40] (self : Trail'0.t_trail) =
    [%#span76] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_level'0 tl
      /\ match a with
        | Assign'0.C_Input _ _ -> l = 0
        | Assign'0.C_Decision _ _ -> level'1 tl + 1 = l
        | Assign'0.C_Justified j _ _ -> set_level'0 tl j = l
        end
      end
  
  predicate invariant'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 387 4 387 34] (self : Trail'0.t_trail) =
    [%#span77] invariant_level'0 self
    /\ invariant_contains'0 self /\ trail_unique'0 self /\ invariant_nonneg'0 self /\ invariant_assign'0 self
  
  function justification'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 492 4 492 71] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span78] let _ = find_justified'0 self d in match find'0 self d with
      | Option'0.C_Some (Assign'0.C_Justified j _ _, _) -> j
      | _ -> Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value)
      end
  
  axiom justification'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#stheory8] invariant'1 self)
   -> ([%#stheory9] is_justified'0 self d)
   -> ([%#stheory10] sound'1 self)
   -> ([%#stheory13] is_decision'0 self d
   -> justification'0 self d = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value)))
  && ([%#stheory12] is_input'0 self d
   -> justification'0 self d = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value)))
  && ([%#stheory11] forall m : Model'0.t_model . inv'0 m  -> entails'0 m (justification'0 self d) d)
  
  function justification_contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 662 4 662 58] (self : Trail'0.t_trail) (kv : (Term'0.t_term, Value'0.t_value)) : ()
    
   =
    [%#span79] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = kv then () else justification_contains'0 tl kv
      end
  
  axiom justification_contains'0_spec : forall self : Trail'0.t_trail, kv : (Term'0.t_term, Value'0.t_value) . ([%#stheory14] invariant'1 self)
   -> ([%#stheory15] is_justified'0 self kv)
   -> ([%#stheory17] set_level'0 self (justification'0 self kv) = level_of'0 self kv)
  && ([%#stheory16] forall e : (Term'0.t_term, Value'0.t_value) . contains'0 (justification'0 self kv) e
   -> contains'1 self e /\ level_of'0 self e <= level_of'0 self kv)
  
  use Cdsat_Theory_Conflict_Type as Conflict'0
  
  use Cdsat_Theory_Conflict_Type as Cdsat_Theory_Conflict_Type
  
  function level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 1004 4 1004 29] (self : Conflict'0.t_conflict) : int =
    [%#span80] set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (Cdsat_Theory_Conflict_Type.conflict_1 self)
  
  predicate sound'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 998 4 998 30] (self : Conflict'0.t_conflict)
    
   =
    [%#span81] sound'1 (Cdsat_Theory_Conflict_Type.conflict_0 self)
    /\ (forall m : Model'0.t_model . inv'0 m  -> satisfy_set'0 m (Cdsat_Theory_Conflict_Type.conflict_1 self)  -> false)
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 991 4 991 34] (self : Conflict'0.t_conflict) =
    [%#span82] set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (Cdsat_Theory_Conflict_Type.conflict_1 self) > 0
    /\ invariant'1 (Cdsat_Theory_Conflict_Type.conflict_0 self)
    /\ (forall a : (Term'0.t_term, Value'0.t_value) . contains'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) a
     -> contains'1 (Cdsat_Theory_Conflict_Type.conflict_0 self) a)
  
  constant self  : Conflict'0.t_conflict
  
  constant a  : (Term'0.t_term, Value'0.t_value)
  
  function resolvef [#"/Users/xavier/Code/cdsat/src/theory.rs" 1035 4 1035 51] (self : Conflict'0.t_conflict) (a : (Term'0.t_term, Value'0.t_value)) : Conflict'0.t_conflict
    
  
  goal vc_resolvef : ([%#stheory4] forall j : (Term'0.t_term, Value'0.t_value) . contains'0 (justification'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) a) j
   -> not is_bool'0 (let (_, a) = j in a)
   -> is_decision'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) j
   -> level_of'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) j
  < set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (Cdsat_Theory_Conflict_Type.conflict_1 self))
   -> ([%#stheory3] contains'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) a)
   -> ([%#stheory2] is_justified'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) a)
   -> ([%#stheory1] sound'0 self)
   -> ([%#stheory0] invariant'0 self)
   -> (([%#stheory10] sound'1 (Cdsat_Theory_Conflict_Type.conflict_0 self))
  && ([%#stheory9] is_justified'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) a)
  && ([%#stheory8] invariant'1 (Cdsat_Theory_Conflict_Type.conflict_0 self)))
  /\ (([%#stheory13] is_decision'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) a
   -> justification'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) a
  = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value)))
  && ([%#stheory12] is_input'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) a
   -> justification'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) a
  = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value)))
  && ([%#stheory11] forall m : Model'0.t_model . inv'0 m
   -> entails'0 m (justification'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) a) a)
   -> (let just = justification'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) a in (([%#stheory15] is_justified'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) a)
  && ([%#stheory14] invariant'1 (Cdsat_Theory_Conflict_Type.conflict_0 self)))
  /\ (([%#stheory17] set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (justification'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) a)
  = level_of'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) a)
  && ([%#stheory16] forall e : (Term'0.t_term, Value'0.t_value) . contains'0 (justification'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) a) e
   -> contains'1 (Cdsat_Theory_Conflict_Type.conflict_0 self) e
  /\ level_of'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) e
  <= level_of'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) a)
   -> (let _ = justification_contains'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) a in let _ = resolve_sound'0 in let result = Conflict'0.C_Conflict (Cdsat_Theory_Conflict_Type.conflict_0 self) (Fset.union (remove'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) a) just) in ([%#stheory7] level'0 result
  = level'0 self)
  && ([%#stheory6] sound'0 result) && ([%#stheory5] invariant'0 result)))))
end
module Cdsat_Theory_Normal_Type
  use Cdsat_Theory_Trail_Type as Trail'0
  
  type t_normal  =
    | C_Normal (Trail'0.t_trail)
  
  function any_l (_ : 'b) : 'a
  
  let rec t_normal (input:t_normal) (ret  (field_0:Trail'0.t_trail))= any
    [ good (field_0:Trail'0.t_trail)-> {C_Normal field_0 = input} (! ret {field_0})
    | bad (field_0:Trail'0.t_trail)-> {C_Normal field_0 <> input} {false} any ]
    
  
  function normal_0 (self : t_normal) : Trail'0.t_trail =
    match self with
      | C_Normal a -> a
      end
end
module Cdsat_Theory_Impl5_RestrictSound_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 705 15 705 27
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 706 14 706 42
  
  let%span span2 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span3 = "/Users/xavier/Code/cdsat/src/theory.rs" 157 8 159 9
  
  let%span span4 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span5 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  let%span span6 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span span7 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span8 = "/Users/xavier/Code/cdsat/src/theory.rs" 601 8 605 9
  
  let%span span9 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span10 = "/Users/xavier/Code/cdsat/src/theory.rs" 122 8 126 9
  
  let%span span11 = "/Users/xavier/Code/cdsat/src/theory.rs" 346 8 349 9
  
  let%span span12 = "/Users/xavier/Code/cdsat/src/theory.rs" 337 8 340 9
  
  let%span span13 = "/Users/xavier/Code/cdsat/src/theory.rs" 132 8 136 9
  
  let%span span14 = "/Users/xavier/Code/cdsat/src/theory.rs" 465 14 468 5
  
  let%span span15 = "/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 111
  
  let%span span16 = "/Users/xavier/Code/cdsat/src/theory.rs" 470 4 470 104
  
  let%span span17 = "/Users/xavier/Code/cdsat/src/theory.rs" 472 8 481 9
  
  let%span span18 = "/Users/xavier/Code/cdsat/src/theory.rs" 406 15 406 38
  
  let%span span19 = "/Users/xavier/Code/cdsat/src/theory.rs" 407 14 407 51
  
  let%span span20 = "/Users/xavier/Code/cdsat/src/theory.rs" 409 8 412 9
  
  let%span span21 = "/Users/xavier/Code/cdsat/src/theory.rs" 417 4 417 87
  
  let%span span22 = "/Users/xavier/Code/cdsat/src/theory.rs" 419 8 422 9
  
  let%span span23 = "/Users/xavier/Code/cdsat/src/theory.rs" 82 8 82 36
  
  let%span span24 = "/Users/xavier/Code/cdsat/src/theory.rs" 96 15 96 29
  
  let%span span25 = "/Users/xavier/Code/cdsat/src/theory.rs" 97 14 97 30
  
  let%span span26 = "/Users/xavier/Code/cdsat/src/theory.rs" 99 8 102 9
  
  let%span span27 = "/Users/xavier/Code/cdsat/src/theory.rs" 374 8 382 9
  
  let%span span28 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 16 8 16 26
  
  let%span span29 = "/Users/xavier/Code/cdsat/src/theory.rs" 355 8 368 9
  
  let%span span30 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 53 8 53 26
  
  let%span span31 = "/Users/xavier/Code/cdsat/src/theory.rs" 281 15 281 38
  
  let%span span32 = "/Users/xavier/Code/cdsat/src/theory.rs" 282 4 282 74
  
  let%span span33 = "/Users/xavier/Code/cdsat/src/theory.rs" 283 4 283 94
  
  let%span span34 = "/Users/xavier/Code/cdsat/src/theory.rs" 284 4 284 48
  
  let%span span35 = "/Users/xavier/Code/cdsat/src/theory.rs" 285 14 285 25
  
  let%span span36 = "/Users/xavier/Code/cdsat/src/theory.rs" 286 14 286 36
  
  let%span span37 = "/Users/xavier/Code/cdsat/src/theory.rs" 280 14 280 21
  
  let%span span38 = "/Users/xavier/Code/cdsat/src/theory.rs" 278 4 278 12
  
  let%span span39 = "/Users/xavier/Code/cdsat/src/theory.rs" 321 8 331 9
  
  let%span span40 = "/Users/xavier/Code/cdsat/src/theory.rs" 388 8 392 38
  
  let%span span41 = "/Users/xavier/Code/cdsat/src/theory.rs" 741 15 741 31
  
  let%span span42 = "/Users/xavier/Code/cdsat/src/theory.rs" 742 4 742 83
  
  let%span span43 = "/Users/xavier/Code/cdsat/src/theory.rs" 744 8 749 9
  
  let%span span44 = "/Users/xavier/Code/cdsat/src/theory.rs" 562 8 573 9
  
  let%span span45 = "/Users/xavier/Code/cdsat/src/theory.rs" 167 18 167 22
  
  let%span span46 = "/Users/xavier/Code/cdsat/src/theory.rs" 166 4 166 62
  
  let%span span47 = "/Users/xavier/Code/cdsat/src/theory.rs" 168 8 188 9
  
  let%span span48 = "/Users/xavier/Code/cdsat/src/theory.rs" 194 8 194 31
  
  let%span span49 = "/Users/xavier/Code/cdsat/src/theory.rs" 200 8 200 71
  
  let%span span50 = "/Users/xavier/Code/cdsat/src/theory.rs" 142 8 147 9
  
  let%span span51 = "/Users/xavier/Code/cdsat/src/theory.rs" 262 8 265 9
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  use Cdsat_Theory_Value_Type as Value'0
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span2] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  use map.Map
  
  use Cdsat_Theory_Model_Type as Cdsat_Theory_Model_Type
  
  use Cdsat_Theory_Var_Type as Var'0
  
  use Cdsat_Theory_Model_Type as Model'0
  
  predicate invariant'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 156 4 156 30] (self : Model'0.t_model) =
    [%#span3] forall v : Value'0.t_value . forall k : Var'0.t_var . Map.get (Cdsat_Theory_Model_Type.model_0 self) k = v
     -> Cdsat_Theory_Var_Type.var_1 k = sort'1 v
  
  predicate inv'0 (_x : Model'0.t_model)
  
  axiom inv'0 : forall x : Model'0.t_model . inv'0 x
  = (invariant'1 x
  /\ match x with
    | Model'0.C_Model a_0 -> true
    end)
  
  use prelude.prelude.Int
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span5] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span4] len'0 self >= 0
  
  function level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int =
    [%#span8] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> 1 + level'0 tl
      | Trail'0.C_Assign _ _ tl -> level'0 tl
      end
  
  axiom level'0_spec : forall self : Trail'0.t_trail . ([%#span7] level'0 self <= len'0 self)
  && ([%#span6] level'0 self >= 0)
  
  use prelude.prelude.Int
  
  use Cdsat_Theory_Term_Type as Term'0
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span9] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'1 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  predicate invariant'2 [#"/Users/xavier/Code/cdsat/src/theory.rs" 121 4 121 34] (self : Assign'0.t_assign) =
    [%#span10] match self with
      | Assign'0.C_Decision t v -> sort'0 t = sort'1 v
      | Assign'0.C_Justified _ t v -> sort'0 t = sort'1 v /\ sort'0 t = Sort'0.C_Boolean
      | Assign'0.C_Input t v -> sort'0 t = sort'1 v
      end
  
  predicate invariant_assign'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 345 4 345 41] (self : Trail'0.t_trail) =
    [%#span11] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_assign'0 tl /\ invariant'2 a
      end
  
  predicate invariant_nonneg'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 336 4 336 41] (self : Trail'0.t_trail) =
    [%#span12] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_nonneg'0 tl /\ l >= 0 /\ l <= level'0 self
      end
  
  function to_pair'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 131 4 131 41] (self : Assign'0.t_assign) : (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span13] match self with
      | Assign'0.C_Decision t val' -> (t, val')
      | Assign'0.C_Input t val' -> (t, val')
      | Assign'0.C_Justified _ t val' -> (t, val')
      end
  
  use Core_Option_Option_Type as Option'0
  
  function find'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 471 4 471 64] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Option'0.t_option (Assign'0.t_assign, int)
    
   =
    [%#span17] match self with
      | Trail'0.C_Empty -> Option'0.C_None
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then Option'0.C_Some (a, l) else find'0 tl d
      end
  
  axiom find'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span16] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)))
  && ([%#span15] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
  && ([%#span14] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
  
  function level_of'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 408 4 408 50] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : int
    
   =
    [%#span20] match find'0 self d with
      | Option'0.C_Some (_, l) -> l
      | Option'0.C_None -> 0
      end
  
  axiom level_of'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span18] invariant_nonneg'0 self)
   -> ([%#span19] level_of'0 self d >= 0 /\ level_of'0 self d <= level'0 self)
  
  predicate contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 418 4 418 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span22] match find'0 self d with
      | Option'0.C_Some ix -> true
      | Option'0.C_None -> false
      end
  
  axiom contains'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . [%#span21] invariant_assign'0 self
   -> contains'0 self d = true  -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)
  
  predicate is_bool'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 81 4 81 32] (self : Value'0.t_value) =
    [%#span23] sort'1 self = Sort'0.C_Boolean
  
  function negate'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 98 4 98 31] (self : Value'0.t_value) : Value'0.t_value =
    [%#span26] match self with
      | Value'0.C_Bool b -> Value'0.C_Bool (not b)
      | _ -> self
      end
  
  axiom negate'0_spec : forall self : Value'0.t_value . ([%#span24] is_bool'0 self)
   -> ([%#span25] is_bool'0 (negate'0 self))
  
  predicate trail_unique'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 373 4 373 37] (self : Trail'0.t_trail) =
    [%#span27] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> let ap = to_pair'0 a in not contains'0 tl ap
      /\ trail_unique'0 tl
      /\ (if is_bool'0 (let (_, a) = ap in a) then
        not contains'0 tl ((let (a, _) = ap in a), negate'0 (let (_, a) = ap in a))
      else
        true
      )
      end
  
  use set.Fset
  
  use set.Fset
  
  predicate contains'1 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (e : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span28] Fset.mem e self
  
  predicate invariant_contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 354 4 354 43] (self : Trail'0.t_trail) =
    [%#span29] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_contains'0 tl
      /\ match a with
        | Assign'0.C_Justified j _ _ -> forall a : (Term'0.t_term, Value'0.t_value) . contains'1 j a  -> contains'0 tl a
        | _ -> true
        end
      end
  
  use set.Fset
  
  function remove'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (a : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span30] Fset.remove a self
  
  use set.Fset
  
  use set.Fset
  
  use set.Fset
  
  function set_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 287 4 287 57] (self : Trail'0.t_trail) (s : Fset.fset (Term'0.t_term, Value'0.t_value)) : int
    
  
  axiom set_level'0_def : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . set_level'0 self s
  = ([%#span38] if Fset.cardinal s = 0 then
    0
  else
    if Fset.cardinal s = 1 then
      level_of'0 self (Fset.pick s)
    else
      let a = Fset.pick s in let rec' = set_level'0 self (remove'0 s a) in if level_of'0 self a >= rec' then
        level_of'0 self a
      else
        rec'
      
    
  )
  
  axiom set_level'0_spec : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . ([%#span31] invariant_nonneg'0 self)
   -> ([%#span36] set_level'0 self s <= level'0 self)
  && ([%#span35] set_level'0 self s >= 0)
  && ([%#span34] s = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))  -> set_level'0 self s = 0)
  && ([%#span33] s <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
   -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'1 s i /\ level_of'0 self i = set_level'0 self s))
  && ([%#span32] forall i : (Term'0.t_term, Value'0.t_value) . contains'1 s i
   -> level_of'0 self i <= set_level'0 self s)
  
  predicate invariant_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 320 4 320 40] (self : Trail'0.t_trail) =
    [%#span39] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_level'0 tl
      /\ match a with
        | Assign'0.C_Input _ _ -> l = 0
        | Assign'0.C_Decision _ _ -> level'0 tl + 1 = l
        | Assign'0.C_Justified j _ _ -> set_level'0 tl j = l
        end
      end
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 387 4 387 34] (self : Trail'0.t_trail) =
    [%#span40] invariant_level'0 self
    /\ invariant_contains'0 self /\ trail_unique'0 self /\ invariant_nonneg'0 self /\ invariant_assign'0 self
  
  function count_bounds'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 743 4 743 35] (self : Trail'0.t_trail) : () =
    [%#span43] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign (Assign'0.C_Input _ _) _ tl -> count_bounds'0 tl
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> count_bounds'0 tl
      | Trail'0.C_Assign (Assign'0.C_Justified _ _ _) _ tl -> count_bounds'0 tl
      end
  
  axiom count_bounds'0_spec : forall self : Trail'0.t_trail . ([%#span41] invariant'0 self)
   -> ([%#span42] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 self a  -> level_of'0 self a <= level'0 self)
  
  function restrict'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 561 4 561 45] (self : Trail'0.t_trail) (level : int) : Trail'0.t_trail
    
   =
    [%#span44] match self with
      | Trail'0.C_Empty -> Trail'0.C_Empty
      | Trail'0.C_Assign a l tl -> let tl = restrict'0 tl level in let _ = count_bounds'0 tl in if l <= level then
        Trail'0.C_Assign a l tl
      else
        tl
      
      end
  
  use prelude.prelude.Real
  
  function from_int'0 (_1 : int) : Real.real
  
  function interp'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 167 4 167 41] (self : Model'0.t_model) (t : Term'0.t_term) : Value'0.t_value
    
   =
    [%#span47] match t with
      | Term'0.C_Variable v -> Map.get (Cdsat_Theory_Model_Type.model_0 self) v
      | Term'0.C_Value v -> v
      | Term'0.C_Plus l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Rat r1, Value'0.C_Rat r2) -> Value'0.C_Rat r1
        | _ -> Value'0.C_Rat (from_int'0 (- 1))
        end
      | Term'0.C_Conj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 /\ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Disj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 \/ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Eq l r -> Value'0.C_Bool (interp'0 self l = interp'0 self r)
      | Term'0.C_Neg t -> match interp'0 self t with
        | Value'0.C_Bool b -> Value'0.C_Bool (not b)
        | _ -> Value'0.C_Bool false
        end
      end
  
  axiom interp'0_spec : forall self : Model'0.t_model, t : Term'0.t_term . ([%#span45] inv'0 self)
   -> ([%#span46] invariant'1 self  -> sort'1 (interp'0 self t) = sort'0 t)
  
  predicate satisfies'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 193 4 193 52] (self : Model'0.t_model) (v : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span48] interp'0 self (let (a, _) = v in a) = (let (_, a) = v in a)
  
  predicate satisfy_set'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 199 4 199 60] (self : Model'0.t_model) (v : Fset.fset (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span49] forall a : (Term'0.t_term, Value'0.t_value) . contains'1 v a  -> satisfies'0 self a
  
  predicate justified_sound'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 141 4 141 40] (self : Assign'0.t_assign) =
    [%#span50] match self with
      | Assign'0.C_Justified just t val' -> forall m : Model'0.t_model . inv'0 m
       -> satisfy_set'0 m just  -> satisfies'0 m (t, val')
      | _ -> true
      end
  
  predicate sound'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 261 4 261 30] (self : Trail'0.t_trail)
   =
    [%#span51] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a _ tl -> sound'0 tl /\ justified_sound'0 a
      end
  
  constant self  : Trail'0.t_trail
  
  constant level  : int
  
  function restrict_sound [#"/Users/xavier/Code/cdsat/src/theory.rs" 707 4 707 43] (self : Trail'0.t_trail) (level : int) : ()
    
  
  goal vc_restrict_sound : ([%#stheory0] sound'0 self)
   -> match self with
    | Trail'0.C_Empty -> [%#stheory1] sound'0 (restrict'0 self level)
    | Trail'0.C_Assign a l tl -> ([%#stheory0] sound'0 tl)
    /\ (([%#stheory1] sound'0 (restrict'0 tl level))
     -> (let _ = restrict_sound tl level in [%#stheory1] sound'0 (restrict'0 self level)))
    end
end
module Cdsat_Theory_Impl5_TrailPlausible_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 787 15 787 31
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 788 15 788 31
  
  let%span stheory2 = "/Users/xavier/Code/cdsat/src/theory.rs" 789 4 789 30
  
  let%span stheory3 = "/Users/xavier/Code/cdsat/src/theory.rs" 790 14 790 49
  
  let%span span4 = "/Users/xavier/Code/cdsat/src/theory.rs" 132 8 136 9
  
  let%span span5 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span6 = "/Users/xavier/Code/cdsat/src/theory.rs" 82 8 82 36
  
  let%span span7 = "/Users/xavier/Code/cdsat/src/theory.rs" 96 15 96 29
  
  let%span span8 = "/Users/xavier/Code/cdsat/src/theory.rs" 97 14 97 30
  
  let%span span9 = "/Users/xavier/Code/cdsat/src/theory.rs" 99 8 102 9
  
  let%span span10 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span11 = "/Users/xavier/Code/cdsat/src/theory.rs" 122 8 126 9
  
  let%span span12 = "/Users/xavier/Code/cdsat/src/theory.rs" 346 8 349 9
  
  let%span span13 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span14 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  let%span span15 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span span16 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span17 = "/Users/xavier/Code/cdsat/src/theory.rs" 601 8 605 9
  
  let%span span18 = "/Users/xavier/Code/cdsat/src/theory.rs" 337 8 340 9
  
  let%span span19 = "/Users/xavier/Code/cdsat/src/theory.rs" 465 14 468 5
  
  let%span span20 = "/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 111
  
  let%span span21 = "/Users/xavier/Code/cdsat/src/theory.rs" 470 4 470 104
  
  let%span span22 = "/Users/xavier/Code/cdsat/src/theory.rs" 472 8 481 9
  
  let%span span23 = "/Users/xavier/Code/cdsat/src/theory.rs" 417 4 417 87
  
  let%span span24 = "/Users/xavier/Code/cdsat/src/theory.rs" 419 8 422 9
  
  let%span span25 = "/Users/xavier/Code/cdsat/src/theory.rs" 374 8 382 9
  
  let%span span26 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 16 8 16 26
  
  let%span span27 = "/Users/xavier/Code/cdsat/src/theory.rs" 355 8 368 9
  
  let%span span28 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 53 8 53 26
  
  let%span span29 = "/Users/xavier/Code/cdsat/src/theory.rs" 406 15 406 38
  
  let%span span30 = "/Users/xavier/Code/cdsat/src/theory.rs" 407 14 407 51
  
  let%span span31 = "/Users/xavier/Code/cdsat/src/theory.rs" 409 8 412 9
  
  let%span span32 = "/Users/xavier/Code/cdsat/src/theory.rs" 281 15 281 38
  
  let%span span33 = "/Users/xavier/Code/cdsat/src/theory.rs" 282 4 282 74
  
  let%span span34 = "/Users/xavier/Code/cdsat/src/theory.rs" 283 4 283 94
  
  let%span span35 = "/Users/xavier/Code/cdsat/src/theory.rs" 284 4 284 48
  
  let%span span36 = "/Users/xavier/Code/cdsat/src/theory.rs" 285 14 285 25
  
  let%span span37 = "/Users/xavier/Code/cdsat/src/theory.rs" 286 14 286 36
  
  let%span span38 = "/Users/xavier/Code/cdsat/src/theory.rs" 280 14 280 21
  
  let%span span39 = "/Users/xavier/Code/cdsat/src/theory.rs" 278 4 278 12
  
  let%span span40 = "/Users/xavier/Code/cdsat/src/theory.rs" 321 8 331 9
  
  let%span span41 = "/Users/xavier/Code/cdsat/src/theory.rs" 388 8 392 38
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  use Cdsat_Theory_Value_Type as Value'0
  
  use Cdsat_Theory_Term_Type as Term'0
  
  function to_pair'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 131 4 131 41] (self : Assign'0.t_assign) : (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span4] match self with
      | Assign'0.C_Decision t val' -> (t, val')
      | Assign'0.C_Input t val' -> (t, val')
      | Assign'0.C_Justified _ t val' -> (t, val')
      end
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span5] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  predicate is_bool'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 81 4 81 32] (self : Value'0.t_value) =
    [%#span6] sort'1 self = Sort'0.C_Boolean
  
  function negate'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 98 4 98 31] (self : Value'0.t_value) : Value'0.t_value =
    [%#span9] match self with
      | Value'0.C_Bool b -> Value'0.C_Bool (not b)
      | _ -> self
      end
  
  axiom negate'0_spec : forall self : Value'0.t_value . ([%#span7] is_bool'0 self)
   -> ([%#span8] is_bool'0 (negate'0 self))
  
  use prelude.prelude.Int
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span10] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'1 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  predicate invariant'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 121 4 121 34] (self : Assign'0.t_assign) =
    [%#span11] match self with
      | Assign'0.C_Decision t v -> sort'0 t = sort'1 v
      | Assign'0.C_Justified _ t v -> sort'0 t = sort'1 v /\ sort'0 t = Sort'0.C_Boolean
      | Assign'0.C_Input t v -> sort'0 t = sort'1 v
      end
  
  predicate invariant_assign'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 345 4 345 41] (self : Trail'0.t_trail) =
    [%#span12] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_assign'0 tl /\ invariant'1 a
      end
  
  use prelude.prelude.Int
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span14] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span13] len'0 self >= 0
  
  function level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int =
    [%#span17] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> 1 + level'0 tl
      | Trail'0.C_Assign _ _ tl -> level'0 tl
      end
  
  axiom level'0_spec : forall self : Trail'0.t_trail . ([%#span16] level'0 self <= len'0 self)
  && ([%#span15] level'0 self >= 0)
  
  predicate invariant_nonneg'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 336 4 336 41] (self : Trail'0.t_trail) =
    [%#span18] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_nonneg'0 tl /\ l >= 0 /\ l <= level'0 self
      end
  
  use Core_Option_Option_Type as Option'0
  
  function find'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 471 4 471 64] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Option'0.t_option (Assign'0.t_assign, int)
    
   =
    [%#span22] match self with
      | Trail'0.C_Empty -> Option'0.C_None
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then Option'0.C_Some (a, l) else find'0 tl d
      end
  
  axiom find'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span21] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)))
  && ([%#span20] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
  && ([%#span19] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
  
  predicate contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 418 4 418 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span24] match find'0 self d with
      | Option'0.C_Some ix -> true
      | Option'0.C_None -> false
      end
  
  axiom contains'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . [%#span23] invariant_assign'0 self
   -> contains'0 self d = true  -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)
  
  predicate trail_unique'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 373 4 373 37] (self : Trail'0.t_trail) =
    [%#span25] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> let ap = to_pair'0 a in not contains'0 tl ap
      /\ trail_unique'0 tl
      /\ (if is_bool'0 (let (_, a) = ap in a) then
        not contains'0 tl ((let (a, _) = ap in a), negate'0 (let (_, a) = ap in a))
      else
        true
      )
      end
  
  use set.Fset
  
  use set.Fset
  
  predicate contains'1 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (e : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span26] Fset.mem e self
  
  predicate invariant_contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 354 4 354 43] (self : Trail'0.t_trail) =
    [%#span27] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_contains'0 tl
      /\ match a with
        | Assign'0.C_Justified j _ _ -> forall a : (Term'0.t_term, Value'0.t_value) . contains'1 j a  -> contains'0 tl a
        | _ -> true
        end
      end
  
  use set.Fset
  
  function remove'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (a : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span28] Fset.remove a self
  
  use set.Fset
  
  use set.Fset
  
  use set.Fset
  
  function level_of'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 408 4 408 50] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : int
    
   =
    [%#span31] match find'0 self d with
      | Option'0.C_Some (_, l) -> l
      | Option'0.C_None -> 0
      end
  
  axiom level_of'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span29] invariant_nonneg'0 self)
   -> ([%#span30] level_of'0 self d >= 0 /\ level_of'0 self d <= level'0 self)
  
  function set_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 287 4 287 57] (self : Trail'0.t_trail) (s : Fset.fset (Term'0.t_term, Value'0.t_value)) : int
    
  
  axiom set_level'0_def : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . set_level'0 self s
  = ([%#span39] if Fset.cardinal s = 0 then
    0
  else
    if Fset.cardinal s = 1 then
      level_of'0 self (Fset.pick s)
    else
      let a = Fset.pick s in let rec' = set_level'0 self (remove'0 s a) in if level_of'0 self a >= rec' then
        level_of'0 self a
      else
        rec'
      
    
  )
  
  axiom set_level'0_spec : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . ([%#span32] invariant_nonneg'0 self)
   -> ([%#span37] set_level'0 self s <= level'0 self)
  && ([%#span36] set_level'0 self s >= 0)
  && ([%#span35] s = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))  -> set_level'0 self s = 0)
  && ([%#span34] s <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
   -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'1 s i /\ level_of'0 self i = set_level'0 self s))
  && ([%#span33] forall i : (Term'0.t_term, Value'0.t_value) . contains'1 s i
   -> level_of'0 self i <= set_level'0 self s)
  
  predicate invariant_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 320 4 320 40] (self : Trail'0.t_trail) =
    [%#span40] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_level'0 tl
      /\ match a with
        | Assign'0.C_Input _ _ -> l = 0
        | Assign'0.C_Decision _ _ -> level'0 tl + 1 = l
        | Assign'0.C_Justified j _ _ -> set_level'0 tl j = l
        end
      end
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 387 4 387 34] (self : Trail'0.t_trail) =
    [%#span41] invariant_level'0 self
    /\ invariant_contains'0 self /\ trail_unique'0 self /\ invariant_nonneg'0 self /\ invariant_assign'0 self
  
  constant self  : Trail'0.t_trail
  
  constant d  : (Term'0.t_term, Value'0.t_value)
  
  function trail_plausible [#"/Users/xavier/Code/cdsat/src/theory.rs" 791 4 791 50] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : ()
    
  
  goal vc_trail_plausible : ([%#stheory2] is_bool'0 (let (_, a) = d in a))
   -> ([%#stheory1] contains'0 self d)
   -> ([%#stheory0] invariant'0 self)
   -> match self with
    | Trail'0.C_Empty -> [%#stheory3] not contains'0 self ((let (a, _) = d in a), negate'0 (let (_, a) = d in a))
    | Trail'0.C_Assign a l tl -> match to_pair'0 a = d with
      | True -> [%#stheory3] not contains'0 self ((let (a, _) = d in a), negate'0 (let (_, a) = d in a))
      | False -> (([%#stheory2] is_bool'0 (let (_, a) = d in a))
      && ([%#stheory1] contains'0 tl d) && ([%#stheory0] invariant'0 tl))
      /\ (([%#stheory3] not contains'0 tl ((let (a, _) = d in a), negate'0 (let (_, a) = d in a)))
       -> (let _ = trail_plausible tl d in [%#stheory3] not contains'0 self ((let (a, _) = d in a), negate'0 (let (_, a) = d in a))))
      end
    end
end
module Cdsat_Theory_Impl5_RestrictIdempotent_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 774 15 774 31
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 775 15 775 33
  
  let%span stheory2 = "/Users/xavier/Code/cdsat/src/theory.rs" 776 15 776 23
  
  let%span stheory3 = "/Users/xavier/Code/cdsat/src/theory.rs" 777 14 777 65
  
  let%span span4 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span5 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  let%span span6 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span span7 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span8 = "/Users/xavier/Code/cdsat/src/theory.rs" 601 8 605 9
  
  let%span span9 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span10 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span11 = "/Users/xavier/Code/cdsat/src/theory.rs" 122 8 126 9
  
  let%span span12 = "/Users/xavier/Code/cdsat/src/theory.rs" 346 8 349 9
  
  let%span span13 = "/Users/xavier/Code/cdsat/src/theory.rs" 337 8 340 9
  
  let%span span14 = "/Users/xavier/Code/cdsat/src/theory.rs" 132 8 136 9
  
  let%span span15 = "/Users/xavier/Code/cdsat/src/theory.rs" 465 14 468 5
  
  let%span span16 = "/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 111
  
  let%span span17 = "/Users/xavier/Code/cdsat/src/theory.rs" 470 4 470 104
  
  let%span span18 = "/Users/xavier/Code/cdsat/src/theory.rs" 472 8 481 9
  
  let%span span19 = "/Users/xavier/Code/cdsat/src/theory.rs" 406 15 406 38
  
  let%span span20 = "/Users/xavier/Code/cdsat/src/theory.rs" 407 14 407 51
  
  let%span span21 = "/Users/xavier/Code/cdsat/src/theory.rs" 409 8 412 9
  
  let%span span22 = "/Users/xavier/Code/cdsat/src/theory.rs" 417 4 417 87
  
  let%span span23 = "/Users/xavier/Code/cdsat/src/theory.rs" 419 8 422 9
  
  let%span span24 = "/Users/xavier/Code/cdsat/src/theory.rs" 82 8 82 36
  
  let%span span25 = "/Users/xavier/Code/cdsat/src/theory.rs" 96 15 96 29
  
  let%span span26 = "/Users/xavier/Code/cdsat/src/theory.rs" 97 14 97 30
  
  let%span span27 = "/Users/xavier/Code/cdsat/src/theory.rs" 99 8 102 9
  
  let%span span28 = "/Users/xavier/Code/cdsat/src/theory.rs" 374 8 382 9
  
  let%span span29 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 16 8 16 26
  
  let%span span30 = "/Users/xavier/Code/cdsat/src/theory.rs" 355 8 368 9
  
  let%span span31 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 53 8 53 26
  
  let%span span32 = "/Users/xavier/Code/cdsat/src/theory.rs" 281 15 281 38
  
  let%span span33 = "/Users/xavier/Code/cdsat/src/theory.rs" 282 4 282 74
  
  let%span span34 = "/Users/xavier/Code/cdsat/src/theory.rs" 283 4 283 94
  
  let%span span35 = "/Users/xavier/Code/cdsat/src/theory.rs" 284 4 284 48
  
  let%span span36 = "/Users/xavier/Code/cdsat/src/theory.rs" 285 14 285 25
  
  let%span span37 = "/Users/xavier/Code/cdsat/src/theory.rs" 286 14 286 36
  
  let%span span38 = "/Users/xavier/Code/cdsat/src/theory.rs" 280 14 280 21
  
  let%span span39 = "/Users/xavier/Code/cdsat/src/theory.rs" 278 4 278 12
  
  let%span span40 = "/Users/xavier/Code/cdsat/src/theory.rs" 321 8 331 9
  
  let%span span41 = "/Users/xavier/Code/cdsat/src/theory.rs" 388 8 392 38
  
  let%span span42 = "/Users/xavier/Code/cdsat/src/theory.rs" 741 15 741 31
  
  let%span span43 = "/Users/xavier/Code/cdsat/src/theory.rs" 742 4 742 83
  
  let%span span44 = "/Users/xavier/Code/cdsat/src/theory.rs" 744 8 749 9
  
  let%span span45 = "/Users/xavier/Code/cdsat/src/theory.rs" 562 8 573 9
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  use prelude.prelude.Int
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span5] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span4] len'0 self >= 0
  
  function level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int =
    [%#span8] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> 1 + level'0 tl
      | Trail'0.C_Assign _ _ tl -> level'0 tl
      end
  
  axiom level'0_spec : forall self : Trail'0.t_trail . ([%#span7] level'0 self <= len'0 self)
  && ([%#span6] level'0 self >= 0)
  
  use prelude.prelude.Int
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  use Cdsat_Theory_Value_Type as Value'0
  
  use Cdsat_Theory_Term_Type as Term'0
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span9] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span10] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'1 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  predicate invariant'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 121 4 121 34] (self : Assign'0.t_assign) =
    [%#span11] match self with
      | Assign'0.C_Decision t v -> sort'0 t = sort'1 v
      | Assign'0.C_Justified _ t v -> sort'0 t = sort'1 v /\ sort'0 t = Sort'0.C_Boolean
      | Assign'0.C_Input t v -> sort'0 t = sort'1 v
      end
  
  predicate invariant_assign'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 345 4 345 41] (self : Trail'0.t_trail) =
    [%#span12] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_assign'0 tl /\ invariant'1 a
      end
  
  predicate invariant_nonneg'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 336 4 336 41] (self : Trail'0.t_trail) =
    [%#span13] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_nonneg'0 tl /\ l >= 0 /\ l <= level'0 self
      end
  
  function to_pair'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 131 4 131 41] (self : Assign'0.t_assign) : (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span14] match self with
      | Assign'0.C_Decision t val' -> (t, val')
      | Assign'0.C_Input t val' -> (t, val')
      | Assign'0.C_Justified _ t val' -> (t, val')
      end
  
  use Core_Option_Option_Type as Option'0
  
  function find'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 471 4 471 64] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Option'0.t_option (Assign'0.t_assign, int)
    
   =
    [%#span18] match self with
      | Trail'0.C_Empty -> Option'0.C_None
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then Option'0.C_Some (a, l) else find'0 tl d
      end
  
  axiom find'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span17] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)))
  && ([%#span16] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
  && ([%#span15] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
  
  function level_of'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 408 4 408 50] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : int
    
   =
    [%#span21] match find'0 self d with
      | Option'0.C_Some (_, l) -> l
      | Option'0.C_None -> 0
      end
  
  axiom level_of'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span19] invariant_nonneg'0 self)
   -> ([%#span20] level_of'0 self d >= 0 /\ level_of'0 self d <= level'0 self)
  
  predicate contains'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 418 4 418 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span23] match find'0 self d with
      | Option'0.C_Some ix -> true
      | Option'0.C_None -> false
      end
  
  axiom contains'1_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . [%#span22] invariant_assign'0 self
   -> contains'1 self d = true  -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)
  
  predicate is_bool'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 81 4 81 32] (self : Value'0.t_value) =
    [%#span24] sort'1 self = Sort'0.C_Boolean
  
  function negate'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 98 4 98 31] (self : Value'0.t_value) : Value'0.t_value =
    [%#span27] match self with
      | Value'0.C_Bool b -> Value'0.C_Bool (not b)
      | _ -> self
      end
  
  axiom negate'0_spec : forall self : Value'0.t_value . ([%#span25] is_bool'0 self)
   -> ([%#span26] is_bool'0 (negate'0 self))
  
  predicate trail_unique'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 373 4 373 37] (self : Trail'0.t_trail) =
    [%#span28] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> let ap = to_pair'0 a in not contains'1 tl ap
      /\ trail_unique'0 tl
      /\ (if is_bool'0 (let (_, a) = ap in a) then
        not contains'1 tl ((let (a, _) = ap in a), negate'0 (let (_, a) = ap in a))
      else
        true
      )
      end
  
  use set.Fset
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (e : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span29] Fset.mem e self
  
  predicate invariant_contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 354 4 354 43] (self : Trail'0.t_trail) =
    [%#span30] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_contains'0 tl
      /\ match a with
        | Assign'0.C_Justified j _ _ -> forall a : (Term'0.t_term, Value'0.t_value) . contains'0 j a  -> contains'1 tl a
        | _ -> true
        end
      end
  
  use set.Fset
  
  function remove'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (a : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span31] Fset.remove a self
  
  use set.Fset
  
  use set.Fset
  
  use set.Fset
  
  function set_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 287 4 287 57] (self : Trail'0.t_trail) (s : Fset.fset (Term'0.t_term, Value'0.t_value)) : int
    
  
  axiom set_level'0_def : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . set_level'0 self s
  = ([%#span39] if Fset.cardinal s = 0 then
    0
  else
    if Fset.cardinal s = 1 then
      level_of'0 self (Fset.pick s)
    else
      let a = Fset.pick s in let rec' = set_level'0 self (remove'0 s a) in if level_of'0 self a >= rec' then
        level_of'0 self a
      else
        rec'
      
    
  )
  
  axiom set_level'0_spec : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . ([%#span32] invariant_nonneg'0 self)
   -> ([%#span37] set_level'0 self s <= level'0 self)
  && ([%#span36] set_level'0 self s >= 0)
  && ([%#span35] s = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))  -> set_level'0 self s = 0)
  && ([%#span34] s <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
   -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'0 s i /\ level_of'0 self i = set_level'0 self s))
  && ([%#span33] forall i : (Term'0.t_term, Value'0.t_value) . contains'0 s i
   -> level_of'0 self i <= set_level'0 self s)
  
  predicate invariant_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 320 4 320 40] (self : Trail'0.t_trail) =
    [%#span40] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_level'0 tl
      /\ match a with
        | Assign'0.C_Input _ _ -> l = 0
        | Assign'0.C_Decision _ _ -> level'0 tl + 1 = l
        | Assign'0.C_Justified j _ _ -> set_level'0 tl j = l
        end
      end
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 387 4 387 34] (self : Trail'0.t_trail) =
    [%#span41] invariant_level'0 self
    /\ invariant_contains'0 self /\ trail_unique'0 self /\ invariant_nonneg'0 self /\ invariant_assign'0 self
  
  function count_bounds'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 743 4 743 35] (self : Trail'0.t_trail) : () =
    [%#span44] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign (Assign'0.C_Input _ _) _ tl -> count_bounds'0 tl
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> count_bounds'0 tl
      | Trail'0.C_Assign (Assign'0.C_Justified _ _ _) _ tl -> count_bounds'0 tl
      end
  
  axiom count_bounds'0_spec : forall self : Trail'0.t_trail . ([%#span42] invariant'0 self)
   -> ([%#span43] forall a : (Term'0.t_term, Value'0.t_value) . contains'1 self a  -> level_of'0 self a <= level'0 self)
  
  function restrict'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 561 4 561 45] (self : Trail'0.t_trail) (level : int) : Trail'0.t_trail
    
   =
    [%#span45] match self with
      | Trail'0.C_Empty -> Trail'0.C_Empty
      | Trail'0.C_Assign a l tl -> let tl = restrict'0 tl level in let _ = count_bounds'0 tl in if l <= level then
        Trail'0.C_Assign a l tl
      else
        tl
      
      end
  
  constant self  : Trail'0.t_trail
  
  constant l1  : int
  
  constant l2  : int
  
  function restrict_idempotent [#"/Users/xavier/Code/cdsat/src/theory.rs" 778 4 778 54] (self : Trail'0.t_trail) (l1 : int) (l2 : int) : ()
    
  
  goal vc_restrict_idempotent : ([%#stheory2] l1 <= l2)
   -> ([%#stheory1] l1 >= 0 /\ l2 >= 0)
   -> ([%#stheory0] invariant'0 self)
   -> match self with
    | Trail'0.C_Empty -> [%#stheory3] restrict'0 self l1 = restrict'0 (restrict'0 self l2) l1
    | Trail'0.C_Assign _ _ tl -> (([%#stheory2] l1 <= l2)
    && ([%#stheory1] l1 >= 0 /\ l2 >= 0) && ([%#stheory0] invariant'0 tl))
    /\ (([%#stheory3] restrict'0 tl l1 = restrict'0 (restrict'0 tl l2) l1)
     -> ([%#stheory3] restrict'0 self l1 = restrict'0 (restrict'0 self l2) l1))
    end
end
module Cdsat_Theory_Impl1_NegateInvolutive_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 107 15 107 29
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 108 14 108 44
  
  let%span span2 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span3 = "/Users/xavier/Code/cdsat/src/theory.rs" 82 8 82 36
  
  let%span span4 = "/Users/xavier/Code/cdsat/src/theory.rs" 96 15 96 29
  
  let%span span5 = "/Users/xavier/Code/cdsat/src/theory.rs" 97 14 97 30
  
  let%span span6 = "/Users/xavier/Code/cdsat/src/theory.rs" 99 8 102 9
  
  use Cdsat_Theory_Value_Type as Value'0
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span2] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  predicate is_bool'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 81 4 81 32] (self : Value'0.t_value) =
    [%#span3] sort'0 self = Sort'0.C_Boolean
  
  function negate'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 98 4 98 31] (self : Value'0.t_value) : Value'0.t_value =
    [%#span6] match self with
      | Value'0.C_Bool b -> Value'0.C_Bool (not b)
      | _ -> self
      end
  
  axiom negate'0_spec : forall self : Value'0.t_value . ([%#span4] is_bool'0 self)
   -> ([%#span5] is_bool'0 (negate'0 self))
  
  constant self  : Value'0.t_value
  
  function negate_involutive [#"/Users/xavier/Code/cdsat/src/theory.rs" 109 4 109 34] (self : Value'0.t_value) : ()
  
  goal vc_negate_involutive : ([%#stheory0] is_bool'0 self)  -> ([%#stheory1] negate'0 (negate'0 self) = self)
end
module Cdsat_Theory_Impl4_Lemma_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 225 15 225 40
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 226 15 226 40
  
  let%span stheory2 = "/Users/xavier/Code/cdsat/src/theory.rs" 227 15 227 31
  
  let%span stheory3 = "/Users/xavier/Code/cdsat/src/theory.rs" 229 17 229 21
  
  let%span stheory4 = "/Users/xavier/Code/cdsat/src/theory.rs" 228 14 228 71
  
  let%span stheory5 = "/Users/xavier/Code/cdsat/src/theory.rs" 167 18 167 22
  
  let%span stheory6 = "/Users/xavier/Code/cdsat/src/theory.rs" 166 4 166 62
  
  let%span span7 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span8 = "/Users/xavier/Code/cdsat/src/theory.rs" 157 8 159 9
  
  let%span span9 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span10 = "/Users/xavier/Code/cdsat/src/theory.rs" 168 8 188 9
  
  let%span span11 = "/Users/xavier/Code/cdsat/src/theory.rs" 82 8 82 36
  
  let%span span12 = "/Users/xavier/Code/cdsat/src/theory.rs" 96 15 96 29
  
  let%span span13 = "/Users/xavier/Code/cdsat/src/theory.rs" 97 14 97 30
  
  let%span span14 = "/Users/xavier/Code/cdsat/src/theory.rs" 99 8 102 9
  
  let%span span15 = "/Users/xavier/Code/cdsat/src/theory.rs" 194 8 194 31
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  use Cdsat_Theory_Value_Type as Value'0
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span7] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  use map.Map
  
  use Cdsat_Theory_Model_Type as Cdsat_Theory_Model_Type
  
  use Cdsat_Theory_Var_Type as Var'0
  
  use Cdsat_Theory_Model_Type as Model'0
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 156 4 156 30] (self : Model'0.t_model) =
    [%#span8] forall v : Value'0.t_value . forall k : Var'0.t_var . Map.get (Cdsat_Theory_Model_Type.model_0 self) k = v
     -> Cdsat_Theory_Var_Type.var_1 k = sort'0 v
  
  predicate inv'0 (_x : Model'0.t_model)
  
  axiom inv'0 : forall x : Model'0.t_model . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Model'0.C_Model a_0 -> true
    end)
  
  use prelude.prelude.Real
  
  use prelude.prelude.Int
  
  function from_int'0 (_1 : int) : Real.real
  
  use Cdsat_Theory_Term_Type as Term'0
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span9] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'0 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  function interp'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 167 4 167 41] (self : Model'0.t_model) (t : Term'0.t_term) : Value'0.t_value
    
   =
    [%#span10] match t with
      | Term'0.C_Variable v -> Map.get (Cdsat_Theory_Model_Type.model_0 self) v
      | Term'0.C_Value v -> v
      | Term'0.C_Plus l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Rat r1, Value'0.C_Rat r2) -> Value'0.C_Rat r1
        | _ -> Value'0.C_Rat (from_int'0 (- 1))
        end
      | Term'0.C_Conj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 /\ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Disj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 \/ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Eq l r -> Value'0.C_Bool (interp'0 self l = interp'0 self r)
      | Term'0.C_Neg t -> match interp'0 self t with
        | Value'0.C_Bool b -> Value'0.C_Bool (not b)
        | _ -> Value'0.C_Bool false
        end
      end
  
  axiom interp'0_spec : forall self : Model'0.t_model, t : Term'0.t_term . ([%#stheory5] inv'0 self)
   -> ([%#stheory6] invariant'0 self  -> sort'0 (interp'0 self t) = sort'1 t)
  
  predicate is_bool'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 81 4 81 32] (self : Value'0.t_value) =
    [%#span11] sort'0 self = Sort'0.C_Boolean
  
  function negate'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 98 4 98 31] (self : Value'0.t_value) : Value'0.t_value =
    [%#span14] match self with
      | Value'0.C_Bool b -> Value'0.C_Bool (not b)
      | _ -> self
      end
  
  axiom negate'0_spec : forall self : Value'0.t_value . ([%#span12] is_bool'0 self)
   -> ([%#span13] is_bool'0 (negate'0 self))
  
  predicate satisfies'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 193 4 193 52] (self : Model'0.t_model) (v : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span15] interp'0 self (let (a, _) = v in a) = (let (_, a) = v in a)
  
  constant self  : Model'0.t_model
  
  constant t  : Term'0.t_term
  
  constant v  : Value'0.t_value
  
  function lemma' [#"/Users/xavier/Code/cdsat/src/theory.rs" 229 4 229 41] (self : Model'0.t_model) (t : Term'0.t_term) (v : Value'0.t_value) : ()
    
  
  goal vc_lemma' : ([%#stheory3] inv'0 self)
   -> ([%#stheory2] invariant'0 self)
   -> ([%#stheory1] sort'1 t = Sort'0.C_Boolean)
   -> ([%#stheory0] sort'0 v = Sort'0.C_Boolean)
   -> ([%#stheory5] inv'0 self)
  /\ (([%#stheory6] invariant'0 self  -> sort'0 (interp'0 self t) = sort'1 t)
   -> match interp'0 self t with
    | Value'0.C_Bool _ -> [%#stheory4] satisfies'0 self (t, v) \/ satisfies'0 self (t, negate'0 v)
    | _ -> [%#stheory4] satisfies'0 self (t, v) \/ satisfies'0 self (t, negate'0 v)
    end)
end
module Cdsat_Theory_Impl7_LearnJustified_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 1010 15 1010 31
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 1011 15 1011 27
  
  let%span stheory2 = "/Users/xavier/Code/cdsat/src/theory.rs" 1012 4 1012 37
  
  let%span stheory3 = "/Users/xavier/Code/cdsat/src/theory.rs" 1013 4 1013 51
  
  let%span stheory4 = "/Users/xavier/Code/cdsat/src/theory.rs" 1014 4 1014 108
  
  let%span span5 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span6 = "/Users/xavier/Code/cdsat/src/theory.rs" 157 8 159 9
  
  let%span span7 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span8 = "/Users/xavier/Code/cdsat/src/theory.rs" 167 18 167 22
  
  let%span span9 = "/Users/xavier/Code/cdsat/src/theory.rs" 166 4 166 62
  
  let%span span10 = "/Users/xavier/Code/cdsat/src/theory.rs" 168 8 188 9
  
  let%span span11 = "/Users/xavier/Code/cdsat/src/theory.rs" 82 8 82 36
  
  let%span span12 = "/Users/xavier/Code/cdsat/src/theory.rs" 96 15 96 29
  
  let%span span13 = "/Users/xavier/Code/cdsat/src/theory.rs" 97 14 97 30
  
  let%span span14 = "/Users/xavier/Code/cdsat/src/theory.rs" 99 8 102 9
  
  let%span span15 = "/Users/xavier/Code/cdsat/src/theory.rs" 194 8 194 31
  
  let%span span16 = "/Users/xavier/Code/cdsat/src/theory.rs" 225 15 225 40
  
  let%span span17 = "/Users/xavier/Code/cdsat/src/theory.rs" 226 15 226 40
  
  let%span span18 = "/Users/xavier/Code/cdsat/src/theory.rs" 227 15 227 31
  
  let%span span19 = "/Users/xavier/Code/cdsat/src/theory.rs" 229 17 229 21
  
  let%span span20 = "/Users/xavier/Code/cdsat/src/theory.rs" 228 14 228 71
  
  let%span span21 = "/Users/xavier/Code/cdsat/src/theory.rs" 230 8 233 9
  
  let%span span22 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 16 8 16 26
  
  let%span span23 = "/Users/xavier/Code/cdsat/src/theory.rs" 200 8 200 71
  
  let%span span24 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 53 8 53 26
  
  let%span span25 = "/Users/xavier/Code/cdsat/src/theory.rs" 60 8 60 36
  
  let%span span26 = "/Users/xavier/Code/cdsat/src/theory.rs" 142 8 147 9
  
  let%span span27 = "/Users/xavier/Code/cdsat/src/theory.rs" 262 8 265 9
  
  let%span span28 = "/Users/xavier/Code/cdsat/src/theory.rs" 999 8 999 91
  
  let%span span29 = "/Users/xavier/Code/cdsat/src/theory.rs" 122 8 126 9
  
  let%span span30 = "/Users/xavier/Code/cdsat/src/theory.rs" 346 8 349 9
  
  let%span span31 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span32 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  let%span span33 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span span34 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span35 = "/Users/xavier/Code/cdsat/src/theory.rs" 601 8 605 9
  
  let%span span36 = "/Users/xavier/Code/cdsat/src/theory.rs" 337 8 340 9
  
  let%span span37 = "/Users/xavier/Code/cdsat/src/theory.rs" 132 8 136 9
  
  let%span span38 = "/Users/xavier/Code/cdsat/src/theory.rs" 465 14 468 5
  
  let%span span39 = "/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 111
  
  let%span span40 = "/Users/xavier/Code/cdsat/src/theory.rs" 470 4 470 104
  
  let%span span41 = "/Users/xavier/Code/cdsat/src/theory.rs" 472 8 481 9
  
  let%span span42 = "/Users/xavier/Code/cdsat/src/theory.rs" 417 4 417 87
  
  let%span span43 = "/Users/xavier/Code/cdsat/src/theory.rs" 419 8 422 9
  
  let%span span44 = "/Users/xavier/Code/cdsat/src/theory.rs" 374 8 382 9
  
  let%span span45 = "/Users/xavier/Code/cdsat/src/theory.rs" 355 8 368 9
  
  let%span span46 = "/Users/xavier/Code/cdsat/src/theory.rs" 406 15 406 38
  
  let%span span47 = "/Users/xavier/Code/cdsat/src/theory.rs" 407 14 407 51
  
  let%span span48 = "/Users/xavier/Code/cdsat/src/theory.rs" 409 8 412 9
  
  let%span span49 = "/Users/xavier/Code/cdsat/src/theory.rs" 281 15 281 38
  
  let%span span50 = "/Users/xavier/Code/cdsat/src/theory.rs" 282 4 282 74
  
  let%span span51 = "/Users/xavier/Code/cdsat/src/theory.rs" 283 4 283 94
  
  let%span span52 = "/Users/xavier/Code/cdsat/src/theory.rs" 284 4 284 48
  
  let%span span53 = "/Users/xavier/Code/cdsat/src/theory.rs" 285 14 285 25
  
  let%span span54 = "/Users/xavier/Code/cdsat/src/theory.rs" 286 14 286 36
  
  let%span span55 = "/Users/xavier/Code/cdsat/src/theory.rs" 280 14 280 21
  
  let%span span56 = "/Users/xavier/Code/cdsat/src/theory.rs" 278 4 278 12
  
  let%span span57 = "/Users/xavier/Code/cdsat/src/theory.rs" 321 8 331 9
  
  let%span span58 = "/Users/xavier/Code/cdsat/src/theory.rs" 388 8 392 38
  
  let%span span59 = "/Users/xavier/Code/cdsat/src/theory.rs" 992 8 992 131
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  use Cdsat_Theory_Value_Type as Value'0
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span5] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  use map.Map
  
  use Cdsat_Theory_Model_Type as Cdsat_Theory_Model_Type
  
  use Cdsat_Theory_Var_Type as Var'0
  
  use Cdsat_Theory_Model_Type as Model'0
  
  predicate invariant'2 [#"/Users/xavier/Code/cdsat/src/theory.rs" 156 4 156 30] (self : Model'0.t_model) =
    [%#span6] forall v : Value'0.t_value . forall k : Var'0.t_var . Map.get (Cdsat_Theory_Model_Type.model_0 self) k = v
     -> Cdsat_Theory_Var_Type.var_1 k = sort'1 v
  
  predicate inv'0 (_x : Model'0.t_model)
  
  axiom inv'0 : forall x : Model'0.t_model . inv'0 x
  = (invariant'2 x
  /\ match x with
    | Model'0.C_Model a_0 -> true
    end)
  
  use prelude.prelude.Real
  
  use prelude.prelude.Int
  
  function from_int'0 (_1 : int) : Real.real
  
  use Cdsat_Theory_Term_Type as Term'0
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span7] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'1 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  function interp'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 167 4 167 41] (self : Model'0.t_model) (t : Term'0.t_term) : Value'0.t_value
    
   =
    [%#span10] match t with
      | Term'0.C_Variable v -> Map.get (Cdsat_Theory_Model_Type.model_0 self) v
      | Term'0.C_Value v -> v
      | Term'0.C_Plus l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Rat r1, Value'0.C_Rat r2) -> Value'0.C_Rat r1
        | _ -> Value'0.C_Rat (from_int'0 (- 1))
        end
      | Term'0.C_Conj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 /\ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Disj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 \/ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Eq l r -> Value'0.C_Bool (interp'0 self l = interp'0 self r)
      | Term'0.C_Neg t -> match interp'0 self t with
        | Value'0.C_Bool b -> Value'0.C_Bool (not b)
        | _ -> Value'0.C_Bool false
        end
      end
  
  axiom interp'0_spec : forall self : Model'0.t_model, t : Term'0.t_term . ([%#span8] inv'0 self)
   -> ([%#span9] invariant'2 self  -> sort'1 (interp'0 self t) = sort'0 t)
  
  predicate is_bool'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 81 4 81 32] (self : Value'0.t_value) =
    [%#span11] sort'1 self = Sort'0.C_Boolean
  
  function negate'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 98 4 98 31] (self : Value'0.t_value) : Value'0.t_value =
    [%#span14] match self with
      | Value'0.C_Bool b -> Value'0.C_Bool (not b)
      | _ -> self
      end
  
  axiom negate'0_spec : forall self : Value'0.t_value . ([%#span12] is_bool'1 self)
   -> ([%#span13] is_bool'1 (negate'0 self))
  
  predicate satisfies'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 193 4 193 52] (self : Model'0.t_model) (v : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span15] interp'0 self (let (a, _) = v in a) = (let (_, a) = v in a)
  
  function lemma'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 229 4 229 41] (self : Model'0.t_model) (t : Term'0.t_term) (v : Value'0.t_value) : ()
    
   =
    [%#span21] match interp'0 self t with
      | Value'0.C_Bool _ -> ()
      | _ -> ()
      end
  
  axiom lemma'0_spec : forall self : Model'0.t_model, t : Term'0.t_term, v : Value'0.t_value . ([%#span16] sort'1 v
  = Sort'0.C_Boolean)
   -> ([%#span17] sort'0 t = Sort'0.C_Boolean)
   -> ([%#span18] invariant'2 self)
   -> ([%#span19] inv'0 self)  -> ([%#span20] satisfies'0 self (t, v) \/ satisfies'0 self (t, negate'0 v))
  
  use Cdsat_Theory_Conflict_Type as Conflict'0
  
  use set.Fset
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (e : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span22] Fset.mem e self
  
  predicate satisfy_set'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 199 4 199 60] (self : Model'0.t_model) (v : Fset.fset (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span23] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 v a  -> satisfies'0 self a
  
  use set.Fset
  
  function remove'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (a : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span24] Fset.remove a self
  
  predicate is_bool'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 59 4 59 32] (self : Term'0.t_term) =
    [%#span25] sort'0 self = Sort'0.C_Boolean
  
  use Cdsat_Theory_Conflict_Type as Cdsat_Theory_Conflict_Type
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  predicate justified_sound'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 141 4 141 40] (self : Assign'0.t_assign) =
    [%#span26] match self with
      | Assign'0.C_Justified just t val' -> forall m : Model'0.t_model . inv'0 m
       -> satisfy_set'0 m just  -> satisfies'0 m (t, val')
      | _ -> true
      end
  
  predicate sound'1 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 261 4 261 30] (self : Trail'0.t_trail)
   =
    [%#span27] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a _ tl -> sound'1 tl /\ justified_sound'0 a
      end
  
  predicate sound'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 998 4 998 30] (self : Conflict'0.t_conflict)
    
   =
    [%#span28] sound'1 (Cdsat_Theory_Conflict_Type.conflict_0 self)
    /\ (forall m : Model'0.t_model . inv'0 m  -> satisfy_set'0 m (Cdsat_Theory_Conflict_Type.conflict_1 self)  -> false)
  
  use prelude.prelude.Int
  
  predicate invariant'3 [#"/Users/xavier/Code/cdsat/src/theory.rs" 121 4 121 34] (self : Assign'0.t_assign) =
    [%#span29] match self with
      | Assign'0.C_Decision t v -> sort'0 t = sort'1 v
      | Assign'0.C_Justified _ t v -> sort'0 t = sort'1 v /\ sort'0 t = Sort'0.C_Boolean
      | Assign'0.C_Input t v -> sort'0 t = sort'1 v
      end
  
  predicate invariant_assign'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 345 4 345 41] (self : Trail'0.t_trail) =
    [%#span30] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_assign'0 tl /\ invariant'3 a
      end
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span32] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span31] len'0 self >= 0
  
  function level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int =
    [%#span35] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> 1 + level'0 tl
      | Trail'0.C_Assign _ _ tl -> level'0 tl
      end
  
  axiom level'0_spec : forall self : Trail'0.t_trail . ([%#span34] level'0 self <= len'0 self)
  && ([%#span33] level'0 self >= 0)
  
  predicate invariant_nonneg'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 336 4 336 41] (self : Trail'0.t_trail) =
    [%#span36] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_nonneg'0 tl /\ l >= 0 /\ l <= level'0 self
      end
  
  function to_pair'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 131 4 131 41] (self : Assign'0.t_assign) : (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span37] match self with
      | Assign'0.C_Decision t val' -> (t, val')
      | Assign'0.C_Input t val' -> (t, val')
      | Assign'0.C_Justified _ t val' -> (t, val')
      end
  
  use Core_Option_Option_Type as Option'0
  
  function find'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 471 4 471 64] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Option'0.t_option (Assign'0.t_assign, int)
    
   =
    [%#span41] match self with
      | Trail'0.C_Empty -> Option'0.C_None
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then Option'0.C_Some (a, l) else find'0 tl d
      end
  
  axiom find'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span40] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)))
  && ([%#span39] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
  && ([%#span38] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
  
  predicate contains'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 418 4 418 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span43] match find'0 self d with
      | Option'0.C_Some ix -> true
      | Option'0.C_None -> false
      end
  
  axiom contains'1_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . [%#span42] invariant_assign'0 self
   -> contains'1 self d = true  -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)
  
  predicate trail_unique'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 373 4 373 37] (self : Trail'0.t_trail) =
    [%#span44] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> let ap = to_pair'0 a in not contains'1 tl ap
      /\ trail_unique'0 tl
      /\ (if is_bool'1 (let (_, a) = ap in a) then
        not contains'1 tl ((let (a, _) = ap in a), negate'0 (let (_, a) = ap in a))
      else
        true
      )
      end
  
  predicate invariant_contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 354 4 354 43] (self : Trail'0.t_trail) =
    [%#span45] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_contains'0 tl
      /\ match a with
        | Assign'0.C_Justified j _ _ -> forall a : (Term'0.t_term, Value'0.t_value) . contains'0 j a  -> contains'1 tl a
        | _ -> true
        end
      end
  
  use set.Fset
  
  use set.Fset
  
  use set.Fset
  
  function level_of'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 408 4 408 50] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : int
    
   =
    [%#span48] match find'0 self d with
      | Option'0.C_Some (_, l) -> l
      | Option'0.C_None -> 0
      end
  
  axiom level_of'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span46] invariant_nonneg'0 self)
   -> ([%#span47] level_of'0 self d >= 0 /\ level_of'0 self d <= level'0 self)
  
  function set_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 287 4 287 57] (self : Trail'0.t_trail) (s : Fset.fset (Term'0.t_term, Value'0.t_value)) : int
    
  
  axiom set_level'0_def : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . set_level'0 self s
  = ([%#span56] if Fset.cardinal s = 0 then
    0
  else
    if Fset.cardinal s = 1 then
      level_of'0 self (Fset.pick s)
    else
      let a = Fset.pick s in let rec' = set_level'0 self (remove'0 s a) in if level_of'0 self a >= rec' then
        level_of'0 self a
      else
        rec'
      
    
  )
  
  axiom set_level'0_spec : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . ([%#span49] invariant_nonneg'0 self)
   -> ([%#span54] set_level'0 self s <= level'0 self)
  && ([%#span53] set_level'0 self s >= 0)
  && ([%#span52] s = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))  -> set_level'0 self s = 0)
  && ([%#span51] s <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
   -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'0 s i /\ level_of'0 self i = set_level'0 self s))
  && ([%#span50] forall i : (Term'0.t_term, Value'0.t_value) . contains'0 s i
   -> level_of'0 self i <= set_level'0 self s)
  
  predicate invariant_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 320 4 320 40] (self : Trail'0.t_trail) =
    [%#span57] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_level'0 tl
      /\ match a with
        | Assign'0.C_Input _ _ -> l = 0
        | Assign'0.C_Decision _ _ -> level'0 tl + 1 = l
        | Assign'0.C_Justified j _ _ -> set_level'0 tl j = l
        end
      end
  
  predicate invariant'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 387 4 387 34] (self : Trail'0.t_trail) =
    [%#span58] invariant_level'0 self
    /\ invariant_contains'0 self /\ trail_unique'0 self /\ invariant_nonneg'0 self /\ invariant_assign'0 self
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 991 4 991 34] (self : Conflict'0.t_conflict) =
    [%#span59] set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (Cdsat_Theory_Conflict_Type.conflict_1 self) > 0
    /\ invariant'1 (Cdsat_Theory_Conflict_Type.conflict_0 self)
    /\ (forall a : (Term'0.t_term, Value'0.t_value) . contains'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) a
     -> contains'1 (Cdsat_Theory_Conflict_Type.conflict_0 self) a)
  
  constant self  : Conflict'0.t_conflict
  
  constant ass  : (Term'0.t_term, Value'0.t_value)
  
  function learn_justified [#"/Users/xavier/Code/cdsat/src/theory.rs" 1015 4 1015 52] (self : Conflict'0.t_conflict) (ass : (Term'0.t_term, Value'0.t_value)) : ()
    
  
  goal vc_learn_justified : ([%#stheory3] is_bool'0 (let (a, _) = ass in a) /\ is_bool'1 (let (_, a) = ass in a))
   -> ([%#stheory2] contains'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) ass)
   -> ([%#stheory1] sound'0 self)
   -> ([%#stheory0] invariant'0 self)
   -> (let _ = lemma'0 in [%#stheory4] forall m : Model'0.t_model . inv'0 m
   -> satisfy_set'0 m (remove'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) ass)
   -> satisfies'0 m ((let (a, _) = ass in a), negate'0 (let (_, a) = ass in a)))
end
module Cdsat_Theory_Impl7_Backjump2_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 1104 15 1104 31
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 1105 15 1105 27
  
  let%span stheory2 = "/Users/xavier/Code/cdsat/src/theory.rs" 1106 4 1106 35
  
  let%span stheory3 = "/Users/xavier/Code/cdsat/src/theory.rs" 1107 4 1107 47
  
  let%span stheory4 = "/Users/xavier/Code/cdsat/src/theory.rs" 1108 4 1108 103
  
  let%span stheory5 = "/Users/xavier/Code/cdsat/src/theory.rs" 1109 4 1109 36
  
  let%span stheory6 = "/Users/xavier/Code/cdsat/src/theory.rs" 1110 14 1110 28
  
  let%span stheory7 = "/Users/xavier/Code/cdsat/src/theory.rs" 1111 4 1111 38
  
  let%span stheory8 = "/Users/xavier/Code/cdsat/src/theory.rs" 281 15 281 38
  
  let%span stheory9 = "/Users/xavier/Code/cdsat/src/theory.rs" 282 4 282 74
  
  let%span stheory10 = "/Users/xavier/Code/cdsat/src/theory.rs" 283 4 283 94
  
  let%span stheory11 = "/Users/xavier/Code/cdsat/src/theory.rs" 284 4 284 48
  
  let%span stheory12 = "/Users/xavier/Code/cdsat/src/theory.rs" 285 14 285 25
  
  let%span stheory13 = "/Users/xavier/Code/cdsat/src/theory.rs" 286 14 286 36
  
  let%span stheory14 = "/Users/xavier/Code/cdsat/src/theory.rs" 280 14 280 21
  
  let%span stheory15 = "/Users/xavier/Code/cdsat/src/theory.rs" 96 15 96 29
  
  let%span stheory16 = "/Users/xavier/Code/cdsat/src/theory.rs" 97 14 97 30
  
  let%span span17 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span18 = "/Users/xavier/Code/cdsat/src/theory.rs" 157 8 159 9
  
  let%span span19 = "/Users/xavier/Code/cdsat/src/theory.rs" 82 8 82 36
  
  let%span span20 = "/Users/xavier/Code/cdsat/src/theory.rs" 99 8 102 9
  
  let%span span21 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span22 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  let%span span23 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span span24 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span25 = "/Users/xavier/Code/cdsat/src/theory.rs" 601 8 605 9
  
  let%span span26 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span27 = "/Users/xavier/Code/cdsat/src/theory.rs" 122 8 126 9
  
  let%span span28 = "/Users/xavier/Code/cdsat/src/theory.rs" 346 8 349 9
  
  let%span span29 = "/Users/xavier/Code/cdsat/src/theory.rs" 337 8 340 9
  
  let%span span30 = "/Users/xavier/Code/cdsat/src/theory.rs" 132 8 136 9
  
  let%span span31 = "/Users/xavier/Code/cdsat/src/theory.rs" 465 14 468 5
  
  let%span span32 = "/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 111
  
  let%span span33 = "/Users/xavier/Code/cdsat/src/theory.rs" 470 4 470 104
  
  let%span span34 = "/Users/xavier/Code/cdsat/src/theory.rs" 472 8 481 9
  
  let%span span35 = "/Users/xavier/Code/cdsat/src/theory.rs" 406 15 406 38
  
  let%span span36 = "/Users/xavier/Code/cdsat/src/theory.rs" 407 14 407 51
  
  let%span span37 = "/Users/xavier/Code/cdsat/src/theory.rs" 409 8 412 9
  
  let%span span38 = "/Users/xavier/Code/cdsat/src/theory.rs" 417 4 417 87
  
  let%span span39 = "/Users/xavier/Code/cdsat/src/theory.rs" 419 8 422 9
  
  let%span span40 = "/Users/xavier/Code/cdsat/src/theory.rs" 374 8 382 9
  
  let%span span41 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 16 8 16 26
  
  let%span span42 = "/Users/xavier/Code/cdsat/src/theory.rs" 355 8 368 9
  
  let%span span43 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 53 8 53 26
  
  let%span span44 = "/Users/xavier/Code/cdsat/src/theory.rs" 278 4 278 12
  
  let%span span45 = "/Users/xavier/Code/cdsat/src/theory.rs" 321 8 331 9
  
  let%span span46 = "/Users/xavier/Code/cdsat/src/theory.rs" 388 8 392 38
  
  let%span span47 = "/Users/xavier/Code/cdsat/src/theory.rs" 741 15 741 31
  
  let%span span48 = "/Users/xavier/Code/cdsat/src/theory.rs" 742 4 742 83
  
  let%span span49 = "/Users/xavier/Code/cdsat/src/theory.rs" 744 8 749 9
  
  let%span span50 = "/Users/xavier/Code/cdsat/src/theory.rs" 562 8 573 9
  
  let%span span51 = "/Users/xavier/Code/cdsat/src/theory.rs" 167 18 167 22
  
  let%span span52 = "/Users/xavier/Code/cdsat/src/theory.rs" 166 4 166 62
  
  let%span span53 = "/Users/xavier/Code/cdsat/src/theory.rs" 168 8 188 9
  
  let%span span54 = "/Users/xavier/Code/cdsat/src/theory.rs" 194 8 194 31
  
  let%span span55 = "/Users/xavier/Code/cdsat/src/theory.rs" 225 15 225 40
  
  let%span span56 = "/Users/xavier/Code/cdsat/src/theory.rs" 226 15 226 40
  
  let%span span57 = "/Users/xavier/Code/cdsat/src/theory.rs" 227 15 227 31
  
  let%span span58 = "/Users/xavier/Code/cdsat/src/theory.rs" 229 17 229 21
  
  let%span span59 = "/Users/xavier/Code/cdsat/src/theory.rs" 228 14 228 71
  
  let%span span60 = "/Users/xavier/Code/cdsat/src/theory.rs" 230 8 233 9
  
  let%span span61 = "/Users/xavier/Code/cdsat/src/theory.rs" 200 8 200 71
  
  let%span span62 = "/Users/xavier/Code/cdsat/src/theory.rs" 60 8 60 36
  
  let%span span63 = "/Users/xavier/Code/cdsat/src/theory.rs" 142 8 147 9
  
  let%span span64 = "/Users/xavier/Code/cdsat/src/theory.rs" 262 8 265 9
  
  let%span span65 = "/Users/xavier/Code/cdsat/src/theory.rs" 999 8 999 91
  
  let%span span66 = "/Users/xavier/Code/cdsat/src/theory.rs" 992 8 992 131
  
  let%span span67 = "/Users/xavier/Code/cdsat/src/theory.rs" 1010 15 1010 31
  
  let%span span68 = "/Users/xavier/Code/cdsat/src/theory.rs" 1011 15 1011 27
  
  let%span span69 = "/Users/xavier/Code/cdsat/src/theory.rs" 1012 4 1012 37
  
  let%span span70 = "/Users/xavier/Code/cdsat/src/theory.rs" 1013 4 1013 51
  
  let%span span71 = "/Users/xavier/Code/cdsat/src/theory.rs" 1014 4 1014 108
  
  let%span span72 = "/Users/xavier/Code/cdsat/src/theory.rs" 1008 4 1008 12
  
  let%span span73 = "/Users/xavier/Code/cdsat/src/theory.rs" 107 15 107 29
  
  let%span span74 = "/Users/xavier/Code/cdsat/src/theory.rs" 108 14 108 44
  
  let%span span75 = "/Users/xavier/Code/cdsat/src/theory.rs" 105 4 105 12
  
  let%span span76 = "/Users/xavier/Code/cdsat/src/theory.rs" 774 15 774 31
  
  let%span span77 = "/Users/xavier/Code/cdsat/src/theory.rs" 775 15 775 33
  
  let%span span78 = "/Users/xavier/Code/cdsat/src/theory.rs" 776 15 776 23
  
  let%span span79 = "/Users/xavier/Code/cdsat/src/theory.rs" 777 14 777 65
  
  let%span span80 = "/Users/xavier/Code/cdsat/src/theory.rs" 779 8 782 9
  
  let%span span81 = "/Users/xavier/Code/cdsat/src/theory.rs" 787 15 787 31
  
  let%span span82 = "/Users/xavier/Code/cdsat/src/theory.rs" 788 15 788 31
  
  let%span span83 = "/Users/xavier/Code/cdsat/src/theory.rs" 789 4 789 30
  
  let%span span84 = "/Users/xavier/Code/cdsat/src/theory.rs" 790 14 790 49
  
  let%span span85 = "/Users/xavier/Code/cdsat/src/theory.rs" 792 8 801 9
  
  let%span span86 = "/Users/xavier/Code/cdsat/src/theory.rs" 705 15 705 27
  
  let%span span87 = "/Users/xavier/Code/cdsat/src/theory.rs" 706 14 706 42
  
  let%span span88 = "/Users/xavier/Code/cdsat/src/theory.rs" 708 8 713 9
  
  let%span span89 = "/Users/xavier/Code/cdsat/src/theory.rs" 678 8 678 71
  
  let%span span90 = "/Users/xavier/Code/cdsat/src/theory.rs" 685 8 685 82
  
  let%span span91 = "/Users/xavier/Code/cdsat/src/theory.rs" 696 4 696 55
  
  let%span span92 = "/Users/xavier/Code/cdsat/src/theory.rs" 698 8 698 108
  
  let%span span93 = "/Users/xavier/Code/cdsat/src/theory.rs" 826 4 826 16
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  use Cdsat_Theory_Value_Type as Value'0
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span17] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  use map.Map
  
  use Cdsat_Theory_Model_Type as Cdsat_Theory_Model_Type
  
  use Cdsat_Theory_Var_Type as Var'0
  
  use Cdsat_Theory_Model_Type as Model'0
  
  predicate invariant'3 [#"/Users/xavier/Code/cdsat/src/theory.rs" 156 4 156 30] (self : Model'0.t_model) =
    [%#span18] forall v : Value'0.t_value . forall k : Var'0.t_var . Map.get (Cdsat_Theory_Model_Type.model_0 self) k
    = v  -> Cdsat_Theory_Var_Type.var_1 k = sort'0 v
  
  predicate inv'0 (_x : Model'0.t_model)
  
  axiom inv'0 : forall x : Model'0.t_model . inv'0 x
  = (invariant'3 x
  /\ match x with
    | Model'0.C_Model a_0 -> true
    end)
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  predicate is_bool'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 81 4 81 32] (self : Value'0.t_value) =
    [%#span19] sort'0 self = Sort'0.C_Boolean
  
  function negate'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 98 4 98 31] (self : Value'0.t_value) : Value'0.t_value =
    [%#span20] match self with
      | Value'0.C_Bool b -> Value'0.C_Bool (not b)
      | _ -> self
      end
  
  axiom negate'0_spec : forall self : Value'0.t_value . ([%#stheory15] is_bool'0 self)
   -> ([%#stheory16] is_bool'0 (negate'0 self))
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  use prelude.prelude.Int
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span22] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span21] len'0 self >= 0
  
  function level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int =
    [%#span25] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> 1 + level'0 tl
      | Trail'0.C_Assign _ _ tl -> level'0 tl
      end
  
  axiom level'0_spec : forall self : Trail'0.t_trail . ([%#span24] level'0 self <= len'0 self)
  && ([%#span23] level'0 self >= 0)
  
  use prelude.prelude.Int
  
  use Cdsat_Theory_Term_Type as Term'0
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span26] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'0 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  predicate invariant'2 [#"/Users/xavier/Code/cdsat/src/theory.rs" 121 4 121 34] (self : Assign'0.t_assign) =
    [%#span27] match self with
      | Assign'0.C_Decision t v -> sort'1 t = sort'0 v
      | Assign'0.C_Justified _ t v -> sort'1 t = sort'0 v /\ sort'1 t = Sort'0.C_Boolean
      | Assign'0.C_Input t v -> sort'1 t = sort'0 v
      end
  
  predicate invariant_assign'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 345 4 345 41] (self : Trail'0.t_trail) =
    [%#span28] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_assign'0 tl /\ invariant'2 a
      end
  
  predicate invariant_nonneg'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 336 4 336 41] (self : Trail'0.t_trail) =
    [%#span29] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_nonneg'0 tl /\ l >= 0 /\ l <= level'0 self
      end
  
  function to_pair'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 131 4 131 41] (self : Assign'0.t_assign) : (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span30] match self with
      | Assign'0.C_Decision t val' -> (t, val')
      | Assign'0.C_Input t val' -> (t, val')
      | Assign'0.C_Justified _ t val' -> (t, val')
      end
  
  use Core_Option_Option_Type as Option'0
  
  function find'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 471 4 471 64] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Option'0.t_option (Assign'0.t_assign, int)
    
   =
    [%#span34] match self with
      | Trail'0.C_Empty -> Option'0.C_None
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then Option'0.C_Some (a, l) else find'0 tl d
      end
  
  axiom find'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span33] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'1 (let (a, _) = d in a) = sort'0 (let (_, a) = d in a)))
  && ([%#span32] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
  && ([%#span31] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
  
  function level_of'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 408 4 408 50] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : int
    
   =
    [%#span37] match find'0 self d with
      | Option'0.C_Some (_, l) -> l
      | Option'0.C_None -> 0
      end
  
  axiom level_of'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span35] invariant_nonneg'0 self)
   -> ([%#span36] level_of'0 self d >= 0 /\ level_of'0 self d <= level'0 self)
  
  predicate contains'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 418 4 418 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span39] match find'0 self d with
      | Option'0.C_Some ix -> true
      | Option'0.C_None -> false
      end
  
  axiom contains'1_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . [%#span38] invariant_assign'0 self
   -> contains'1 self d = true  -> sort'1 (let (a, _) = d in a) = sort'0 (let (_, a) = d in a)
  
  predicate trail_unique'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 373 4 373 37] (self : Trail'0.t_trail) =
    [%#span40] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> let ap = to_pair'0 a in not contains'1 tl ap
      /\ trail_unique'0 tl
      /\ (if is_bool'0 (let (_, a) = ap in a) then
        not contains'1 tl ((let (a, _) = ap in a), negate'0 (let (_, a) = ap in a))
      else
        true
      )
      end
  
  use set.Fset
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (e : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span41] Fset.mem e self
  
  predicate invariant_contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 354 4 354 43] (self : Trail'0.t_trail) =
    [%#span42] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_contains'0 tl
      /\ match a with
        | Assign'0.C_Justified j _ _ -> forall a : (Term'0.t_term, Value'0.t_value) . contains'0 j a  -> contains'1 tl a
        | _ -> true
        end
      end
  
  use set.Fset
  
  function remove'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (a : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span43] Fset.remove a self
  
  use set.Fset
  
  use set.Fset
  
  use set.Fset
  
  function set_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 287 4 287 57] (self : Trail'0.t_trail) (s : Fset.fset (Term'0.t_term, Value'0.t_value)) : int
    
  
  axiom set_level'0_def : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . set_level'0 self s
  = ([%#span44] if Fset.cardinal s = 0 then
    0
  else
    if Fset.cardinal s = 1 then
      level_of'0 self (Fset.pick s)
    else
      let a = Fset.pick s in let rec' = set_level'0 self (remove'0 s a) in if level_of'0 self a >= rec' then
        level_of'0 self a
      else
        rec'
      
    
  )
  
  axiom set_level'0_spec : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . ([%#stheory8] invariant_nonneg'0 self)
   -> ([%#stheory13] set_level'0 self s <= level'0 self)
  && ([%#stheory12] set_level'0 self s >= 0)
  && ([%#stheory11] s = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))  -> set_level'0 self s = 0)
  && ([%#stheory10] s <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
   -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'0 s i /\ level_of'0 self i = set_level'0 self s))
  && ([%#stheory9] forall i : (Term'0.t_term, Value'0.t_value) . contains'0 s i
   -> level_of'0 self i <= set_level'0 self s)
  
  predicate invariant_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 320 4 320 40] (self : Trail'0.t_trail) =
    [%#span45] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_level'0 tl
      /\ match a with
        | Assign'0.C_Input _ _ -> l = 0
        | Assign'0.C_Decision _ _ -> level'0 tl + 1 = l
        | Assign'0.C_Justified j _ _ -> set_level'0 tl j = l
        end
      end
  
  predicate invariant'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 387 4 387 34] (self : Trail'0.t_trail) =
    [%#span46] invariant_level'0 self
    /\ invariant_contains'0 self /\ trail_unique'0 self /\ invariant_nonneg'0 self /\ invariant_assign'0 self
  
  function count_bounds'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 743 4 743 35] (self : Trail'0.t_trail) : () =
    [%#span49] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign (Assign'0.C_Input _ _) _ tl -> count_bounds'0 tl
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> count_bounds'0 tl
      | Trail'0.C_Assign (Assign'0.C_Justified _ _ _) _ tl -> count_bounds'0 tl
      end
  
  axiom count_bounds'0_spec : forall self : Trail'0.t_trail . ([%#span47] invariant'1 self)
   -> ([%#span48] forall a : (Term'0.t_term, Value'0.t_value) . contains'1 self a  -> level_of'0 self a <= level'0 self)
  
  function restrict'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 561 4 561 45] (self : Trail'0.t_trail) (level : int) : Trail'0.t_trail
    
   =
    [%#span50] match self with
      | Trail'0.C_Empty -> Trail'0.C_Empty
      | Trail'0.C_Assign a l tl -> let tl = restrict'0 tl level in let _ = count_bounds'0 tl in if l <= level then
        Trail'0.C_Assign a l tl
      else
        tl
      
      end
  
  use prelude.prelude.Real
  
  function from_int'0 (_1 : int) : Real.real
  
  function interp'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 167 4 167 41] (self : Model'0.t_model) (t : Term'0.t_term) : Value'0.t_value
    
   =
    [%#span53] match t with
      | Term'0.C_Variable v -> Map.get (Cdsat_Theory_Model_Type.model_0 self) v
      | Term'0.C_Value v -> v
      | Term'0.C_Plus l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Rat r1, Value'0.C_Rat r2) -> Value'0.C_Rat r1
        | _ -> Value'0.C_Rat (from_int'0 (- 1))
        end
      | Term'0.C_Conj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 /\ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Disj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 \/ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Eq l r -> Value'0.C_Bool (interp'0 self l = interp'0 self r)
      | Term'0.C_Neg t -> match interp'0 self t with
        | Value'0.C_Bool b -> Value'0.C_Bool (not b)
        | _ -> Value'0.C_Bool false
        end
      end
  
  axiom interp'0_spec : forall self : Model'0.t_model, t : Term'0.t_term . ([%#span51] inv'0 self)
   -> ([%#span52] invariant'3 self  -> sort'0 (interp'0 self t) = sort'1 t)
  
  predicate satisfies'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 193 4 193 52] (self : Model'0.t_model) (v : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span54] interp'0 self (let (a, _) = v in a) = (let (_, a) = v in a)
  
  function lemma'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 229 4 229 41] (self : Model'0.t_model) (t : Term'0.t_term) (v : Value'0.t_value) : ()
    
   =
    [%#span60] match interp'0 self t with
      | Value'0.C_Bool _ -> ()
      | _ -> ()
      end
  
  axiom lemma'0_spec : forall self : Model'0.t_model, t : Term'0.t_term, v : Value'0.t_value . ([%#span55] sort'0 v
  = Sort'0.C_Boolean)
   -> ([%#span56] sort'1 t = Sort'0.C_Boolean)
   -> ([%#span57] invariant'3 self)
   -> ([%#span58] inv'0 self)  -> ([%#span59] satisfies'0 self (t, v) \/ satisfies'0 self (t, negate'0 v))
  
  use Cdsat_Theory_Conflict_Type as Conflict'0
  
  predicate satisfy_set'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 199 4 199 60] (self : Model'0.t_model) (v : Fset.fset (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span61] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 v a  -> satisfies'0 self a
  
  predicate is_bool'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 59 4 59 32] (self : Term'0.t_term) =
    [%#span62] sort'1 self = Sort'0.C_Boolean
  
  use Cdsat_Theory_Conflict_Type as Cdsat_Theory_Conflict_Type
  
  predicate justified_sound'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 141 4 141 40] (self : Assign'0.t_assign) =
    [%#span63] match self with
      | Assign'0.C_Justified just t val' -> forall m : Model'0.t_model . inv'0 m
       -> satisfy_set'0 m just  -> satisfies'0 m (t, val')
      | _ -> true
      end
  
  predicate sound'2 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 261 4 261 30] (self : Trail'0.t_trail)
   =
    [%#span64] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a _ tl -> sound'2 tl /\ justified_sound'0 a
      end
  
  predicate sound'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 998 4 998 30] (self : Conflict'0.t_conflict)
    
   =
    [%#span65] sound'2 (Cdsat_Theory_Conflict_Type.conflict_0 self)
    /\ (forall m : Model'0.t_model . inv'0 m  -> satisfy_set'0 m (Cdsat_Theory_Conflict_Type.conflict_1 self)  -> false)
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 991 4 991 34] (self : Conflict'0.t_conflict) =
    [%#span66] set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (Cdsat_Theory_Conflict_Type.conflict_1 self) > 0
    /\ invariant'1 (Cdsat_Theory_Conflict_Type.conflict_0 self)
    /\ (forall a : (Term'0.t_term, Value'0.t_value) . contains'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) a
     -> contains'1 (Cdsat_Theory_Conflict_Type.conflict_0 self) a)
  
  function learn_justified'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 1015 4 1015 52] (self : Conflict'0.t_conflict) (ass : (Term'0.t_term, Value'0.t_value)) : ()
    
   =
    [%#span72] let _ = () in ()
  
  axiom learn_justified'0_spec : forall self : Conflict'0.t_conflict, ass : (Term'0.t_term, Value'0.t_value) . ([%#span67] invariant'0 self)
   -> ([%#span68] sound'0 self)
   -> ([%#span69] contains'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) ass)
   -> ([%#span70] is_bool'1 (let (a, _) = ass in a) /\ is_bool'0 (let (_, a) = ass in a))
   -> ([%#span71] forall m : Model'0.t_model . inv'0 m
   -> satisfy_set'0 m (remove'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) ass)
   -> satisfies'0 m ((let (a, _) = ass in a), negate'0 (let (_, a) = ass in a)))
  
  function negate_involutive'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 109 4 109 34] (self : Value'0.t_value) : () =
    [%#span75] ()
  
  axiom negate_involutive'0_spec : forall self : Value'0.t_value . ([%#span73] is_bool'0 self)
   -> ([%#span74] negate'0 (negate'0 self) = self)
  
  function restrict_idempotent'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 778 4 778 54] (self : Trail'0.t_trail) (l1 : int) (l2 : int) : ()
    
   =
    [%#span80] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign _ _ tl -> restrict_idempotent'0 tl l1 l2
      end
  
  axiom restrict_idempotent'0_spec : forall self : Trail'0.t_trail, l1 : int, l2 : int . ([%#span76] invariant'1 self)
   -> ([%#span77] l1 >= 0 /\ l2 >= 0)
   -> ([%#span78] l1 <= l2)  -> ([%#span79] restrict'0 self l1 = restrict'0 (restrict'0 self l2) l1)
  
  function trail_plausible'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 791 4 791 50] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : ()
    
   =
    [%#span85] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then () else let _ = trail_plausible'0 tl d in ()
      end
  
  axiom trail_plausible'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span81] invariant'1 self)
   -> ([%#span82] contains'1 self d)
   -> ([%#span83] is_bool'0 (let (_, a) = d in a))
   -> ([%#span84] not contains'1 self ((let (a, _) = d in a), negate'0 (let (_, a) = d in a)))
  
  function restrict_sound'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 707 4 707 43] (self : Trail'0.t_trail) (level : int) : ()
    
   =
    [%#span88] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign a l tl -> let _ = restrict_sound'0 tl level in ()
      end
  
  axiom restrict_sound'0_spec : forall self : Trail'0.t_trail, level : int . ([%#span86] sound'2 self)
   -> ([%#span87] sound'2 (restrict'0 self level))
  
  use Cdsat_Theory_Normal_Type as Normal'0
  
  predicate satisfied_by'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 677 4 677 47] (self : Trail'0.t_trail) (m : Model'0.t_model)
    
   =
    [%#span89] forall a : (Term'0.t_term, Value'0.t_value) . contains'1 self a  -> satisfies'0 m a
  
  predicate unsat'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 684 4 684 30] (self : Trail'0.t_trail) =
    [%#span90] forall m : Model'0.t_model . inv'0 m  -> satisfied_by'0 (restrict'0 self 0) m  -> false
  
  predicate impls'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 697 4 697 41] (self : Trail'0.t_trail) (rhs : Trail'0.t_trail)
    
   =
    [%#span92] forall m : Model'0.t_model . inv'0 m
     -> satisfied_by'0 (restrict'0 self 0) m  -> satisfied_by'0 (restrict'0 rhs 0) m
  
  axiom impls'0_spec : forall self : Trail'0.t_trail, rhs : Trail'0.t_trail . [%#span91] impls'0 self rhs
   -> unsat'0 rhs  -> unsat'0 self
  
  use Cdsat_Theory_Normal_Type as Cdsat_Theory_Normal_Type
  
  predicate sound'1 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 829 4 829 30] (self : Normal'0.t_normal)
    
   =
    [%#span93] sound'2 (Cdsat_Theory_Normal_Type.normal_0 self)
  
  constant self  : Conflict'0.t_conflict
  
  constant l  : (Term'0.t_term, Value'0.t_value)
  
  function backjump2 [#"/Users/xavier/Code/cdsat/src/theory.rs" 1113 4 1113 54] (self : Conflict'0.t_conflict) (l : (Term'0.t_term, Value'0.t_value)) : Normal'0.t_normal
    
  
  goal vc_backjump2 : ([%#stheory4] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) a
   -> level_of'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) a
  < level_of'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) l
  \/ a = l)
   -> ([%#stheory3] is_bool'0 (let (_, a) = l in a) /\ is_bool'1 (let (a, _) = l in a))
   -> ([%#stheory2] contains'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) l)
   -> ([%#stheory1] sound'0 self)
   -> ([%#stheory0] invariant'0 self)
   -> (let e = remove'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) l in let _ = restrict_sound'0 in let _ = trail_plausible'0 in let _ = restrict_idempotent'0 in let _ = negate_involutive'0 in let _ = learn_justified'0 in ([%#stheory8] invariant_nonneg'0 (Cdsat_Theory_Conflict_Type.conflict_0 self))
  /\ (([%#stheory13] set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) e
  <= level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self))
  && ([%#stheory12] set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) e >= 0)
  && ([%#stheory11] e = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
   -> set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) e = 0)
  && ([%#stheory10] e <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
   -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'0 e i
  /\ level_of'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) i
  = set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) e))
  && ([%#stheory9] forall i : (Term'0.t_term, Value'0.t_value) . contains'0 e i
   -> level_of'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) i
  <= set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) e)
   -> (let restricted = restrict'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) e) in ([%#stheory15] is_bool'0 (let (_, a) = l in a))
  /\ (([%#stheory16] is_bool'0 (negate'0 (let (_, a) = l in a)))
   -> ([%#stheory8] invariant_nonneg'0 restricted)
  /\ (([%#stheory13] set_level'0 restricted e <= level'0 restricted)
  && ([%#stheory12] set_level'0 restricted e >= 0)
  && ([%#stheory11] e = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))  -> set_level'0 restricted e = 0)
  && ([%#stheory10] e <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
   -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'0 e i
  /\ level_of'0 restricted i = set_level'0 restricted e))
  && ([%#stheory9] forall i : (Term'0.t_term, Value'0.t_value) . contains'0 e i
   -> level_of'0 restricted i <= set_level'0 restricted e)
   -> (let result = Normal'0.C_Normal (Trail'0.C_Assign (Assign'0.C_Justified e (let (a, _) = l in a) (negate'0 (let (_, a) = l in a))) (set_level'0 restricted e) restricted) in ([%#stheory7] impls'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (Cdsat_Theory_Normal_Type.normal_0 result))
  && ([%#stheory6] sound'1 result) && ([%#stheory5] invariant'1 (Cdsat_Theory_Normal_Type.normal_0 result))))))))
end
module Cdsat_Theory_Impl5_IsInputInv_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 532 15 532 31
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 533 15 533 31
  
  let%span stheory2 = "/Users/xavier/Code/cdsat/src/theory.rs" 534 14 534 35
  
  let%span span3 = "/Users/xavier/Code/cdsat/src/theory.rs" 132 8 136 9
  
  let%span span4 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span5 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span6 = "/Users/xavier/Code/cdsat/src/theory.rs" 122 8 126 9
  
  let%span span7 = "/Users/xavier/Code/cdsat/src/theory.rs" 346 8 349 9
  
  let%span span8 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span9 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  let%span span10 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span span11 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span12 = "/Users/xavier/Code/cdsat/src/theory.rs" 601 8 605 9
  
  let%span span13 = "/Users/xavier/Code/cdsat/src/theory.rs" 337 8 340 9
  
  let%span span14 = "/Users/xavier/Code/cdsat/src/theory.rs" 465 14 468 5
  
  let%span span15 = "/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 111
  
  let%span span16 = "/Users/xavier/Code/cdsat/src/theory.rs" 470 4 470 104
  
  let%span span17 = "/Users/xavier/Code/cdsat/src/theory.rs" 472 8 481 9
  
  let%span span18 = "/Users/xavier/Code/cdsat/src/theory.rs" 406 15 406 38
  
  let%span span19 = "/Users/xavier/Code/cdsat/src/theory.rs" 407 14 407 51
  
  let%span span20 = "/Users/xavier/Code/cdsat/src/theory.rs" 409 8 412 9
  
  let%span span21 = "/Users/xavier/Code/cdsat/src/theory.rs" 524 8 527 9
  
  let%span span22 = "/Users/xavier/Code/cdsat/src/theory.rs" 82 8 82 36
  
  let%span span23 = "/Users/xavier/Code/cdsat/src/theory.rs" 96 15 96 29
  
  let%span span24 = "/Users/xavier/Code/cdsat/src/theory.rs" 97 14 97 30
  
  let%span span25 = "/Users/xavier/Code/cdsat/src/theory.rs" 99 8 102 9
  
  let%span span26 = "/Users/xavier/Code/cdsat/src/theory.rs" 417 4 417 87
  
  let%span span27 = "/Users/xavier/Code/cdsat/src/theory.rs" 419 8 422 9
  
  let%span span28 = "/Users/xavier/Code/cdsat/src/theory.rs" 374 8 382 9
  
  let%span span29 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 16 8 16 26
  
  let%span span30 = "/Users/xavier/Code/cdsat/src/theory.rs" 355 8 368 9
  
  let%span span31 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 53 8 53 26
  
  let%span span32 = "/Users/xavier/Code/cdsat/src/theory.rs" 281 15 281 38
  
  let%span span33 = "/Users/xavier/Code/cdsat/src/theory.rs" 282 4 282 74
  
  let%span span34 = "/Users/xavier/Code/cdsat/src/theory.rs" 283 4 283 94
  
  let%span span35 = "/Users/xavier/Code/cdsat/src/theory.rs" 284 4 284 48
  
  let%span span36 = "/Users/xavier/Code/cdsat/src/theory.rs" 285 14 285 25
  
  let%span span37 = "/Users/xavier/Code/cdsat/src/theory.rs" 286 14 286 36
  
  let%span span38 = "/Users/xavier/Code/cdsat/src/theory.rs" 280 14 280 21
  
  let%span span39 = "/Users/xavier/Code/cdsat/src/theory.rs" 278 4 278 12
  
  let%span span40 = "/Users/xavier/Code/cdsat/src/theory.rs" 321 8 331 9
  
  let%span span41 = "/Users/xavier/Code/cdsat/src/theory.rs" 388 8 392 38
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  use Cdsat_Theory_Value_Type as Value'0
  
  use Cdsat_Theory_Term_Type as Term'0
  
  function to_pair'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 131 4 131 41] (self : Assign'0.t_assign) : (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span3] match self with
      | Assign'0.C_Decision t val' -> (t, val')
      | Assign'0.C_Input t val' -> (t, val')
      | Assign'0.C_Justified _ t val' -> (t, val')
      end
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  use prelude.prelude.Int
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span4] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span5] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'1 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  predicate invariant'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 121 4 121 34] (self : Assign'0.t_assign) =
    [%#span6] match self with
      | Assign'0.C_Decision t v -> sort'0 t = sort'1 v
      | Assign'0.C_Justified _ t v -> sort'0 t = sort'1 v /\ sort'0 t = Sort'0.C_Boolean
      | Assign'0.C_Input t v -> sort'0 t = sort'1 v
      end
  
  predicate invariant_assign'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 345 4 345 41] (self : Trail'0.t_trail) =
    [%#span7] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_assign'0 tl /\ invariant'1 a
      end
  
  use prelude.prelude.Int
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span9] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span8] len'0 self >= 0
  
  function level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int =
    [%#span12] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> 1 + level'0 tl
      | Trail'0.C_Assign _ _ tl -> level'0 tl
      end
  
  axiom level'0_spec : forall self : Trail'0.t_trail . ([%#span11] level'0 self <= len'0 self)
  && ([%#span10] level'0 self >= 0)
  
  predicate invariant_nonneg'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 336 4 336 41] (self : Trail'0.t_trail) =
    [%#span13] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_nonneg'0 tl /\ l >= 0 /\ l <= level'0 self
      end
  
  use Core_Option_Option_Type as Option'0
  
  function find'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 471 4 471 64] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Option'0.t_option (Assign'0.t_assign, int)
    
   =
    [%#span17] match self with
      | Trail'0.C_Empty -> Option'0.C_None
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then Option'0.C_Some (a, l) else find'0 tl d
      end
  
  axiom find'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span16] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)))
  && ([%#span15] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
  && ([%#span14] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
  
  function level_of'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 408 4 408 50] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : int
    
   =
    [%#span20] match find'0 self d with
      | Option'0.C_Some (_, l) -> l
      | Option'0.C_None -> 0
      end
  
  axiom level_of'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span18] invariant_nonneg'0 self)
   -> ([%#span19] level_of'0 self d >= 0 /\ level_of'0 self d <= level'0 self)
  
  predicate is_input'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 523 4 523 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span21] match find'0 self d with
      | Option'0.C_Some (Assign'0.C_Input _ _, _) -> true
      | _ -> false
      end
  
  predicate is_bool'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 81 4 81 32] (self : Value'0.t_value) =
    [%#span22] sort'1 self = Sort'0.C_Boolean
  
  function negate'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 98 4 98 31] (self : Value'0.t_value) : Value'0.t_value =
    [%#span25] match self with
      | Value'0.C_Bool b -> Value'0.C_Bool (not b)
      | _ -> self
      end
  
  axiom negate'0_spec : forall self : Value'0.t_value . ([%#span23] is_bool'0 self)
   -> ([%#span24] is_bool'0 (negate'0 self))
  
  predicate contains'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 418 4 418 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span27] match find'0 self d with
      | Option'0.C_Some ix -> true
      | Option'0.C_None -> false
      end
  
  axiom contains'1_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . [%#span26] invariant_assign'0 self
   -> contains'1 self d = true  -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)
  
  predicate trail_unique'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 373 4 373 37] (self : Trail'0.t_trail) =
    [%#span28] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> let ap = to_pair'0 a in not contains'1 tl ap
      /\ trail_unique'0 tl
      /\ (if is_bool'0 (let (_, a) = ap in a) then
        not contains'1 tl ((let (a, _) = ap in a), negate'0 (let (_, a) = ap in a))
      else
        true
      )
      end
  
  use set.Fset
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (e : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span29] Fset.mem e self
  
  predicate invariant_contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 354 4 354 43] (self : Trail'0.t_trail) =
    [%#span30] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_contains'0 tl
      /\ match a with
        | Assign'0.C_Justified j _ _ -> forall a : (Term'0.t_term, Value'0.t_value) . contains'0 j a  -> contains'1 tl a
        | _ -> true
        end
      end
  
  use set.Fset
  
  function remove'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (a : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span31] Fset.remove a self
  
  use set.Fset
  
  use set.Fset
  
  use set.Fset
  
  function set_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 287 4 287 57] (self : Trail'0.t_trail) (s : Fset.fset (Term'0.t_term, Value'0.t_value)) : int
    
  
  axiom set_level'0_def : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . set_level'0 self s
  = ([%#span39] if Fset.cardinal s = 0 then
    0
  else
    if Fset.cardinal s = 1 then
      level_of'0 self (Fset.pick s)
    else
      let a = Fset.pick s in let rec' = set_level'0 self (remove'0 s a) in if level_of'0 self a >= rec' then
        level_of'0 self a
      else
        rec'
      
    
  )
  
  axiom set_level'0_spec : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . ([%#span32] invariant_nonneg'0 self)
   -> ([%#span37] set_level'0 self s <= level'0 self)
  && ([%#span36] set_level'0 self s >= 0)
  && ([%#span35] s = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))  -> set_level'0 self s = 0)
  && ([%#span34] s <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
   -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'0 s i /\ level_of'0 self i = set_level'0 self s))
  && ([%#span33] forall i : (Term'0.t_term, Value'0.t_value) . contains'0 s i
   -> level_of'0 self i <= set_level'0 self s)
  
  predicate invariant_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 320 4 320 40] (self : Trail'0.t_trail) =
    [%#span40] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_level'0 tl
      /\ match a with
        | Assign'0.C_Input _ _ -> l = 0
        | Assign'0.C_Decision _ _ -> level'0 tl + 1 = l
        | Assign'0.C_Justified j _ _ -> set_level'0 tl j = l
        end
      end
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 387 4 387 34] (self : Trail'0.t_trail) =
    [%#span41] invariant_level'0 self
    /\ invariant_contains'0 self /\ trail_unique'0 self /\ invariant_nonneg'0 self /\ invariant_assign'0 self
  
  constant self  : Trail'0.t_trail
  
  constant d  : (Term'0.t_term, Value'0.t_value)
  
  function is_input_inv [#"/Users/xavier/Code/cdsat/src/theory.rs" 535 4 535 47] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : ()
    
  
  goal vc_is_input_inv : ([%#stheory1] is_input'0 self d)
   -> ([%#stheory0] invariant'0 self)
   -> match self with
    | Trail'0.C_Empty -> [%#stheory2] level_of'0 self d = 0
    | Trail'0.C_Assign a _ tl -> match to_pair'0 a = d with
      | True -> [%#stheory2] level_of'0 self d = 0
      | False -> (([%#stheory1] is_input'0 tl d) && ([%#stheory0] invariant'0 tl))
      /\ (([%#stheory2] level_of'0 tl d = 0)  -> ([%#stheory2] level_of'0 self d = 0))
      end
    end
end
module Cdsat_Theory_Impl5_RestrictFind_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 578 15 578 31
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 579 15 579 25
  
  let%span stheory2 = "/Users/xavier/Code/cdsat/src/theory.rs" 580 15 580 47
  
  let%span stheory3 = "/Users/xavier/Code/cdsat/src/theory.rs" 581 14 581 58
  
  let%span span4 = "/Users/xavier/Code/cdsat/src/theory.rs" 132 8 136 9
  
  let%span span5 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span6 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span7 = "/Users/xavier/Code/cdsat/src/theory.rs" 122 8 126 9
  
  let%span span8 = "/Users/xavier/Code/cdsat/src/theory.rs" 346 8 349 9
  
  let%span span9 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span10 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  let%span span11 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span span12 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span13 = "/Users/xavier/Code/cdsat/src/theory.rs" 601 8 605 9
  
  let%span span14 = "/Users/xavier/Code/cdsat/src/theory.rs" 337 8 340 9
  
  let%span span15 = "/Users/xavier/Code/cdsat/src/theory.rs" 465 14 468 5
  
  let%span span16 = "/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 111
  
  let%span span17 = "/Users/xavier/Code/cdsat/src/theory.rs" 470 4 470 104
  
  let%span span18 = "/Users/xavier/Code/cdsat/src/theory.rs" 472 8 481 9
  
  let%span span19 = "/Users/xavier/Code/cdsat/src/theory.rs" 417 4 417 87
  
  let%span span20 = "/Users/xavier/Code/cdsat/src/theory.rs" 419 8 422 9
  
  let%span span21 = "/Users/xavier/Code/cdsat/src/theory.rs" 406 15 406 38
  
  let%span span22 = "/Users/xavier/Code/cdsat/src/theory.rs" 407 14 407 51
  
  let%span span23 = "/Users/xavier/Code/cdsat/src/theory.rs" 409 8 412 9
  
  let%span span24 = "/Users/xavier/Code/cdsat/src/theory.rs" 82 8 82 36
  
  let%span span25 = "/Users/xavier/Code/cdsat/src/theory.rs" 96 15 96 29
  
  let%span span26 = "/Users/xavier/Code/cdsat/src/theory.rs" 97 14 97 30
  
  let%span span27 = "/Users/xavier/Code/cdsat/src/theory.rs" 99 8 102 9
  
  let%span span28 = "/Users/xavier/Code/cdsat/src/theory.rs" 374 8 382 9
  
  let%span span29 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 16 8 16 26
  
  let%span span30 = "/Users/xavier/Code/cdsat/src/theory.rs" 355 8 368 9
  
  let%span span31 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 53 8 53 26
  
  let%span span32 = "/Users/xavier/Code/cdsat/src/theory.rs" 281 15 281 38
  
  let%span span33 = "/Users/xavier/Code/cdsat/src/theory.rs" 282 4 282 74
  
  let%span span34 = "/Users/xavier/Code/cdsat/src/theory.rs" 283 4 283 94
  
  let%span span35 = "/Users/xavier/Code/cdsat/src/theory.rs" 284 4 284 48
  
  let%span span36 = "/Users/xavier/Code/cdsat/src/theory.rs" 285 14 285 25
  
  let%span span37 = "/Users/xavier/Code/cdsat/src/theory.rs" 286 14 286 36
  
  let%span span38 = "/Users/xavier/Code/cdsat/src/theory.rs" 280 14 280 21
  
  let%span span39 = "/Users/xavier/Code/cdsat/src/theory.rs" 278 4 278 12
  
  let%span span40 = "/Users/xavier/Code/cdsat/src/theory.rs" 321 8 331 9
  
  let%span span41 = "/Users/xavier/Code/cdsat/src/theory.rs" 388 8 392 38
  
  let%span span42 = "/Users/xavier/Code/cdsat/src/theory.rs" 741 15 741 31
  
  let%span span43 = "/Users/xavier/Code/cdsat/src/theory.rs" 742 4 742 83
  
  let%span span44 = "/Users/xavier/Code/cdsat/src/theory.rs" 744 8 749 9
  
  let%span span45 = "/Users/xavier/Code/cdsat/src/theory.rs" 562 8 573 9
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  use Cdsat_Theory_Value_Type as Value'0
  
  use Cdsat_Theory_Term_Type as Term'0
  
  function to_pair'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 131 4 131 41] (self : Assign'0.t_assign) : (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span4] match self with
      | Assign'0.C_Decision t val' -> (t, val')
      | Assign'0.C_Input t val' -> (t, val')
      | Assign'0.C_Justified _ t val' -> (t, val')
      end
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  use prelude.prelude.Int
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span5] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span6] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'1 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  predicate invariant'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 121 4 121 34] (self : Assign'0.t_assign) =
    [%#span7] match self with
      | Assign'0.C_Decision t v -> sort'0 t = sort'1 v
      | Assign'0.C_Justified _ t v -> sort'0 t = sort'1 v /\ sort'0 t = Sort'0.C_Boolean
      | Assign'0.C_Input t v -> sort'0 t = sort'1 v
      end
  
  predicate invariant_assign'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 345 4 345 41] (self : Trail'0.t_trail) =
    [%#span8] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_assign'0 tl /\ invariant'1 a
      end
  
  use prelude.prelude.Int
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span10] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span9] len'0 self >= 0
  
  function level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int =
    [%#span13] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> 1 + level'0 tl
      | Trail'0.C_Assign _ _ tl -> level'0 tl
      end
  
  axiom level'0_spec : forall self : Trail'0.t_trail . ([%#span12] level'0 self <= len'0 self)
  && ([%#span11] level'0 self >= 0)
  
  predicate invariant_nonneg'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 336 4 336 41] (self : Trail'0.t_trail) =
    [%#span14] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_nonneg'0 tl /\ l >= 0 /\ l <= level'0 self
      end
  
  use Core_Option_Option_Type as Option'0
  
  function find'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 471 4 471 64] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Option'0.t_option (Assign'0.t_assign, int)
    
   =
    [%#span18] match self with
      | Trail'0.C_Empty -> Option'0.C_None
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then Option'0.C_Some (a, l) else find'0 tl d
      end
  
  axiom find'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span17] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)))
  && ([%#span16] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
  && ([%#span15] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
  
  predicate contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 418 4 418 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span20] match find'0 self d with
      | Option'0.C_Some ix -> true
      | Option'0.C_None -> false
      end
  
  axiom contains'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . [%#span19] invariant_assign'0 self
   -> contains'0 self d = true  -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)
  
  function level_of'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 408 4 408 50] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : int
    
   =
    [%#span23] match find'0 self d with
      | Option'0.C_Some (_, l) -> l
      | Option'0.C_None -> 0
      end
  
  axiom level_of'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span21] invariant_nonneg'0 self)
   -> ([%#span22] level_of'0 self d >= 0 /\ level_of'0 self d <= level'0 self)
  
  predicate is_bool'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 81 4 81 32] (self : Value'0.t_value) =
    [%#span24] sort'1 self = Sort'0.C_Boolean
  
  function negate'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 98 4 98 31] (self : Value'0.t_value) : Value'0.t_value =
    [%#span27] match self with
      | Value'0.C_Bool b -> Value'0.C_Bool (not b)
      | _ -> self
      end
  
  axiom negate'0_spec : forall self : Value'0.t_value . ([%#span25] is_bool'0 self)
   -> ([%#span26] is_bool'0 (negate'0 self))
  
  predicate trail_unique'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 373 4 373 37] (self : Trail'0.t_trail) =
    [%#span28] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> let ap = to_pair'0 a in not contains'0 tl ap
      /\ trail_unique'0 tl
      /\ (if is_bool'0 (let (_, a) = ap in a) then
        not contains'0 tl ((let (a, _) = ap in a), negate'0 (let (_, a) = ap in a))
      else
        true
      )
      end
  
  use set.Fset
  
  use set.Fset
  
  predicate contains'1 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (e : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span29] Fset.mem e self
  
  predicate invariant_contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 354 4 354 43] (self : Trail'0.t_trail) =
    [%#span30] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_contains'0 tl
      /\ match a with
        | Assign'0.C_Justified j _ _ -> forall a : (Term'0.t_term, Value'0.t_value) . contains'1 j a  -> contains'0 tl a
        | _ -> true
        end
      end
  
  use set.Fset
  
  function remove'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (a : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span31] Fset.remove a self
  
  use set.Fset
  
  use set.Fset
  
  use set.Fset
  
  function set_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 287 4 287 57] (self : Trail'0.t_trail) (s : Fset.fset (Term'0.t_term, Value'0.t_value)) : int
    
  
  axiom set_level'0_def : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . set_level'0 self s
  = ([%#span39] if Fset.cardinal s = 0 then
    0
  else
    if Fset.cardinal s = 1 then
      level_of'0 self (Fset.pick s)
    else
      let a = Fset.pick s in let rec' = set_level'0 self (remove'0 s a) in if level_of'0 self a >= rec' then
        level_of'0 self a
      else
        rec'
      
    
  )
  
  axiom set_level'0_spec : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . ([%#span32] invariant_nonneg'0 self)
   -> ([%#span37] set_level'0 self s <= level'0 self)
  && ([%#span36] set_level'0 self s >= 0)
  && ([%#span35] s = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))  -> set_level'0 self s = 0)
  && ([%#span34] s <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
   -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'1 s i /\ level_of'0 self i = set_level'0 self s))
  && ([%#span33] forall i : (Term'0.t_term, Value'0.t_value) . contains'1 s i
   -> level_of'0 self i <= set_level'0 self s)
  
  predicate invariant_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 320 4 320 40] (self : Trail'0.t_trail) =
    [%#span40] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_level'0 tl
      /\ match a with
        | Assign'0.C_Input _ _ -> l = 0
        | Assign'0.C_Decision _ _ -> level'0 tl + 1 = l
        | Assign'0.C_Justified j _ _ -> set_level'0 tl j = l
        end
      end
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 387 4 387 34] (self : Trail'0.t_trail) =
    [%#span41] invariant_level'0 self
    /\ invariant_contains'0 self /\ trail_unique'0 self /\ invariant_nonneg'0 self /\ invariant_assign'0 self
  
  function count_bounds'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 743 4 743 35] (self : Trail'0.t_trail) : () =
    [%#span44] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign (Assign'0.C_Input _ _) _ tl -> count_bounds'0 tl
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> count_bounds'0 tl
      | Trail'0.C_Assign (Assign'0.C_Justified _ _ _) _ tl -> count_bounds'0 tl
      end
  
  axiom count_bounds'0_spec : forall self : Trail'0.t_trail . ([%#span42] invariant'0 self)
   -> ([%#span43] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 self a  -> level_of'0 self a <= level'0 self)
  
  function restrict'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 561 4 561 45] (self : Trail'0.t_trail) (level : int) : Trail'0.t_trail
    
   =
    [%#span45] match self with
      | Trail'0.C_Empty -> Trail'0.C_Empty
      | Trail'0.C_Assign a l tl -> let tl = restrict'0 tl level in let _ = count_bounds'0 tl in if l <= level then
        Trail'0.C_Assign a l tl
      else
        tl
      
      end
  
  constant self  : Trail'0.t_trail
  
  constant level  : int
  
  constant d  : (Term'0.t_term, Value'0.t_value)
  
  function restrict_find [#"/Users/xavier/Code/cdsat/src/theory.rs" 582 4 582 60] (self : Trail'0.t_trail) (level : int) (d : (Term'0.t_term, Value'0.t_value)) : ()
    
  
  goal vc_restrict_find : ([%#stheory2] contains'0 (restrict'0 self level) d)
   -> ([%#stheory1] level >= 0)
   -> ([%#stheory0] invariant'0 self)
   -> match self with
    | Trail'0.C_Empty -> [%#stheory3] find'0 (restrict'0 self level) d = find'0 self d
    | Trail'0.C_Assign a _ tl -> match to_pair'0 a = d with
      | True -> [%#stheory3] find'0 (restrict'0 self level) d = find'0 self d
      | False -> (([%#stheory2] contains'0 (restrict'0 tl level) d)
      && ([%#stheory1] level >= 0) && ([%#stheory0] invariant'0 tl))
      /\ (([%#stheory3] find'0 (restrict'0 tl level) d = find'0 tl d)
       -> ([%#stheory3] find'0 (restrict'0 self level) d = find'0 self d))
      end
    end
end
module Cdsat_Theory_Impl5_RestrictKindUnchanged_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 718 15 718 31
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 719 15 719 25
  
  let%span stheory2 = "/Users/xavier/Code/cdsat/src/theory.rs" 720 15 720 47
  
  let%span stheory3 = "/Users/xavier/Code/cdsat/src/theory.rs" 721 14 721 74
  
  let%span stheory4 = "/Users/xavier/Code/cdsat/src/theory.rs" 722 14 722 76
  
  let%span stheory5 = "/Users/xavier/Code/cdsat/src/theory.rs" 723 14 723 72
  
  let%span stheory6 = "/Users/xavier/Code/cdsat/src/theory.rs" 724 14 724 66
  
  let%span stheory7 = "/Users/xavier/Code/cdsat/src/theory.rs" 578 15 578 31
  
  let%span stheory8 = "/Users/xavier/Code/cdsat/src/theory.rs" 579 15 579 25
  
  let%span stheory9 = "/Users/xavier/Code/cdsat/src/theory.rs" 580 15 580 47
  
  let%span stheory10 = "/Users/xavier/Code/cdsat/src/theory.rs" 581 14 581 58
  
  let%span span11 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span12 = "/Users/xavier/Code/cdsat/src/theory.rs" 157 8 159 9
  
  let%span span13 = "/Users/xavier/Code/cdsat/src/theory.rs" 132 8 136 9
  
  let%span span14 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span15 = "/Users/xavier/Code/cdsat/src/theory.rs" 122 8 126 9
  
  let%span span16 = "/Users/xavier/Code/cdsat/src/theory.rs" 346 8 349 9
  
  let%span span17 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span18 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  let%span span19 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span span20 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span21 = "/Users/xavier/Code/cdsat/src/theory.rs" 601 8 605 9
  
  let%span span22 = "/Users/xavier/Code/cdsat/src/theory.rs" 337 8 340 9
  
  let%span span23 = "/Users/xavier/Code/cdsat/src/theory.rs" 465 14 468 5
  
  let%span span24 = "/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 111
  
  let%span span25 = "/Users/xavier/Code/cdsat/src/theory.rs" 470 4 470 104
  
  let%span span26 = "/Users/xavier/Code/cdsat/src/theory.rs" 472 8 481 9
  
  let%span span27 = "/Users/xavier/Code/cdsat/src/theory.rs" 417 4 417 87
  
  let%span span28 = "/Users/xavier/Code/cdsat/src/theory.rs" 419 8 422 9
  
  let%span span29 = "/Users/xavier/Code/cdsat/src/theory.rs" 406 15 406 38
  
  let%span span30 = "/Users/xavier/Code/cdsat/src/theory.rs" 407 14 407 51
  
  let%span span31 = "/Users/xavier/Code/cdsat/src/theory.rs" 409 8 412 9
  
  let%span span32 = "/Users/xavier/Code/cdsat/src/theory.rs" 82 8 82 36
  
  let%span span33 = "/Users/xavier/Code/cdsat/src/theory.rs" 96 15 96 29
  
  let%span span34 = "/Users/xavier/Code/cdsat/src/theory.rs" 97 14 97 30
  
  let%span span35 = "/Users/xavier/Code/cdsat/src/theory.rs" 99 8 102 9
  
  let%span span36 = "/Users/xavier/Code/cdsat/src/theory.rs" 374 8 382 9
  
  let%span span37 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 16 8 16 26
  
  let%span span38 = "/Users/xavier/Code/cdsat/src/theory.rs" 355 8 368 9
  
  let%span span39 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 53 8 53 26
  
  let%span span40 = "/Users/xavier/Code/cdsat/src/theory.rs" 281 15 281 38
  
  let%span span41 = "/Users/xavier/Code/cdsat/src/theory.rs" 282 4 282 74
  
  let%span span42 = "/Users/xavier/Code/cdsat/src/theory.rs" 283 4 283 94
  
  let%span span43 = "/Users/xavier/Code/cdsat/src/theory.rs" 284 4 284 48
  
  let%span span44 = "/Users/xavier/Code/cdsat/src/theory.rs" 285 14 285 25
  
  let%span span45 = "/Users/xavier/Code/cdsat/src/theory.rs" 286 14 286 36
  
  let%span span46 = "/Users/xavier/Code/cdsat/src/theory.rs" 280 14 280 21
  
  let%span span47 = "/Users/xavier/Code/cdsat/src/theory.rs" 278 4 278 12
  
  let%span span48 = "/Users/xavier/Code/cdsat/src/theory.rs" 321 8 331 9
  
  let%span span49 = "/Users/xavier/Code/cdsat/src/theory.rs" 388 8 392 38
  
  let%span span50 = "/Users/xavier/Code/cdsat/src/theory.rs" 741 15 741 31
  
  let%span span51 = "/Users/xavier/Code/cdsat/src/theory.rs" 742 4 742 83
  
  let%span span52 = "/Users/xavier/Code/cdsat/src/theory.rs" 744 8 749 9
  
  let%span span53 = "/Users/xavier/Code/cdsat/src/theory.rs" 562 8 573 9
  
  let%span span54 = "/Users/xavier/Code/cdsat/src/theory.rs" 583 8 592 9
  
  let%span span55 = "/Users/xavier/Code/cdsat/src/theory.rs" 524 8 527 9
  
  let%span span56 = "/Users/xavier/Code/cdsat/src/theory.rs" 514 8 517 9
  
  let%span span57 = "/Users/xavier/Code/cdsat/src/theory.rs" 167 18 167 22
  
  let%span span58 = "/Users/xavier/Code/cdsat/src/theory.rs" 166 4 166 62
  
  let%span span59 = "/Users/xavier/Code/cdsat/src/theory.rs" 168 8 188 9
  
  let%span span60 = "/Users/xavier/Code/cdsat/src/theory.rs" 194 8 194 31
  
  let%span span61 = "/Users/xavier/Code/cdsat/src/theory.rs" 200 8 200 71
  
  let%span span62 = "/Users/xavier/Code/cdsat/src/theory.rs" 142 8 147 9
  
  let%span span63 = "/Users/xavier/Code/cdsat/src/theory.rs" 262 8 265 9
  
  let%span span64 = "/Users/xavier/Code/cdsat/src/theory.rs" 619 15 619 27
  
  let%span span65 = "/Users/xavier/Code/cdsat/src/theory.rs" 620 15 620 32
  
  let%span span66 = "/Users/xavier/Code/cdsat/src/theory.rs" 621 4 621 90
  
  let%span span67 = "/Users/xavier/Code/cdsat/src/theory.rs" 623 8 632 9
  
  let%span span68 = "/Users/xavier/Code/cdsat/src/theory.rs" 206 8 206 84
  
  let%span span69 = "/Users/xavier/Code/cdsat/src/theory.rs" 504 8 507 9
  
  let%span span70 = "/Users/xavier/Code/cdsat/src/theory.rs" 486 15 486 31
  
  let%span span71 = "/Users/xavier/Code/cdsat/src/theory.rs" 487 15 487 35
  
  let%span span72 = "/Users/xavier/Code/cdsat/src/theory.rs" 488 15 488 27
  
  let%span span73 = "/Users/xavier/Code/cdsat/src/theory.rs" 489 4 489 54
  
  let%span span74 = "/Users/xavier/Code/cdsat/src/theory.rs" 490 4 490 58
  
  let%span span75 = "/Users/xavier/Code/cdsat/src/theory.rs" 491 4 491 61
  
  let%span span76 = "/Users/xavier/Code/cdsat/src/theory.rs" 493 8 493 30
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  use Cdsat_Theory_Value_Type as Value'0
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span11] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  use map.Map
  
  use Cdsat_Theory_Model_Type as Cdsat_Theory_Model_Type
  
  use Cdsat_Theory_Var_Type as Var'0
  
  use Cdsat_Theory_Model_Type as Model'0
  
  predicate invariant'2 [#"/Users/xavier/Code/cdsat/src/theory.rs" 156 4 156 30] (self : Model'0.t_model) =
    [%#span12] forall v : Value'0.t_value . forall k : Var'0.t_var . Map.get (Cdsat_Theory_Model_Type.model_0 self) k
    = v  -> Cdsat_Theory_Var_Type.var_1 k = sort'1 v
  
  predicate inv'0 (_x : Model'0.t_model)
  
  axiom inv'0 : forall x : Model'0.t_model . inv'0 x
  = (invariant'2 x
  /\ match x with
    | Model'0.C_Model a_0 -> true
    end)
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  use Cdsat_Theory_Term_Type as Term'0
  
  function to_pair'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 131 4 131 41] (self : Assign'0.t_assign) : (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span13] match self with
      | Assign'0.C_Decision t val' -> (t, val')
      | Assign'0.C_Input t val' -> (t, val')
      | Assign'0.C_Justified _ t val' -> (t, val')
      end
  
  use prelude.prelude.Int
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span14] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'1 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  predicate invariant'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 121 4 121 34] (self : Assign'0.t_assign) =
    [%#span15] match self with
      | Assign'0.C_Decision t v -> sort'0 t = sort'1 v
      | Assign'0.C_Justified _ t v -> sort'0 t = sort'1 v /\ sort'0 t = Sort'0.C_Boolean
      | Assign'0.C_Input t v -> sort'0 t = sort'1 v
      end
  
  predicate invariant_assign'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 345 4 345 41] (self : Trail'0.t_trail) =
    [%#span16] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_assign'0 tl /\ invariant'1 a
      end
  
  use prelude.prelude.Int
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span18] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span17] len'0 self >= 0
  
  function level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int =
    [%#span21] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> 1 + level'0 tl
      | Trail'0.C_Assign _ _ tl -> level'0 tl
      end
  
  axiom level'0_spec : forall self : Trail'0.t_trail . ([%#span20] level'0 self <= len'0 self)
  && ([%#span19] level'0 self >= 0)
  
  predicate invariant_nonneg'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 336 4 336 41] (self : Trail'0.t_trail) =
    [%#span22] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_nonneg'0 tl /\ l >= 0 /\ l <= level'0 self
      end
  
  use Core_Option_Option_Type as Option'0
  
  function find'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 471 4 471 64] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Option'0.t_option (Assign'0.t_assign, int)
    
   =
    [%#span26] match self with
      | Trail'0.C_Empty -> Option'0.C_None
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then Option'0.C_Some (a, l) else find'0 tl d
      end
  
  axiom find'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span25] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)))
  && ([%#span24] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
  && ([%#span23] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
  
  predicate contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 418 4 418 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span28] match find'0 self d with
      | Option'0.C_Some ix -> true
      | Option'0.C_None -> false
      end
  
  axiom contains'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . [%#span27] invariant_assign'0 self
   -> contains'0 self d = true  -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)
  
  function level_of'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 408 4 408 50] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : int
    
   =
    [%#span31] match find'0 self d with
      | Option'0.C_Some (_, l) -> l
      | Option'0.C_None -> 0
      end
  
  axiom level_of'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span29] invariant_nonneg'0 self)
   -> ([%#span30] level_of'0 self d >= 0 /\ level_of'0 self d <= level'0 self)
  
  predicate is_bool'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 81 4 81 32] (self : Value'0.t_value) =
    [%#span32] sort'1 self = Sort'0.C_Boolean
  
  function negate'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 98 4 98 31] (self : Value'0.t_value) : Value'0.t_value =
    [%#span35] match self with
      | Value'0.C_Bool b -> Value'0.C_Bool (not b)
      | _ -> self
      end
  
  axiom negate'0_spec : forall self : Value'0.t_value . ([%#span33] is_bool'0 self)
   -> ([%#span34] is_bool'0 (negate'0 self))
  
  predicate trail_unique'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 373 4 373 37] (self : Trail'0.t_trail) =
    [%#span36] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> let ap = to_pair'0 a in not contains'0 tl ap
      /\ trail_unique'0 tl
      /\ (if is_bool'0 (let (_, a) = ap in a) then
        not contains'0 tl ((let (a, _) = ap in a), negate'0 (let (_, a) = ap in a))
      else
        true
      )
      end
  
  use set.Fset
  
  use set.Fset
  
  predicate contains'1 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (e : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span37] Fset.mem e self
  
  predicate invariant_contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 354 4 354 43] (self : Trail'0.t_trail) =
    [%#span38] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_contains'0 tl
      /\ match a with
        | Assign'0.C_Justified j _ _ -> forall a : (Term'0.t_term, Value'0.t_value) . contains'1 j a  -> contains'0 tl a
        | _ -> true
        end
      end
  
  use set.Fset
  
  function remove'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (a : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span39] Fset.remove a self
  
  use set.Fset
  
  use set.Fset
  
  use set.Fset
  
  function set_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 287 4 287 57] (self : Trail'0.t_trail) (s : Fset.fset (Term'0.t_term, Value'0.t_value)) : int
    
  
  axiom set_level'0_def : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . set_level'0 self s
  = ([%#span47] if Fset.cardinal s = 0 then
    0
  else
    if Fset.cardinal s = 1 then
      level_of'0 self (Fset.pick s)
    else
      let a = Fset.pick s in let rec' = set_level'0 self (remove'0 s a) in if level_of'0 self a >= rec' then
        level_of'0 self a
      else
        rec'
      
    
  )
  
  axiom set_level'0_spec : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . ([%#span40] invariant_nonneg'0 self)
   -> ([%#span45] set_level'0 self s <= level'0 self)
  && ([%#span44] set_level'0 self s >= 0)
  && ([%#span43] s = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))  -> set_level'0 self s = 0)
  && ([%#span42] s <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
   -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'1 s i /\ level_of'0 self i = set_level'0 self s))
  && ([%#span41] forall i : (Term'0.t_term, Value'0.t_value) . contains'1 s i
   -> level_of'0 self i <= set_level'0 self s)
  
  predicate invariant_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 320 4 320 40] (self : Trail'0.t_trail) =
    [%#span48] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_level'0 tl
      /\ match a with
        | Assign'0.C_Input _ _ -> l = 0
        | Assign'0.C_Decision _ _ -> level'0 tl + 1 = l
        | Assign'0.C_Justified j _ _ -> set_level'0 tl j = l
        end
      end
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 387 4 387 34] (self : Trail'0.t_trail) =
    [%#span49] invariant_level'0 self
    /\ invariant_contains'0 self /\ trail_unique'0 self /\ invariant_nonneg'0 self /\ invariant_assign'0 self
  
  function count_bounds'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 743 4 743 35] (self : Trail'0.t_trail) : () =
    [%#span52] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign (Assign'0.C_Input _ _) _ tl -> count_bounds'0 tl
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> count_bounds'0 tl
      | Trail'0.C_Assign (Assign'0.C_Justified _ _ _) _ tl -> count_bounds'0 tl
      end
  
  axiom count_bounds'0_spec : forall self : Trail'0.t_trail . ([%#span50] invariant'0 self)
   -> ([%#span51] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 self a  -> level_of'0 self a <= level'0 self)
  
  function restrict'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 561 4 561 45] (self : Trail'0.t_trail) (level : int) : Trail'0.t_trail
    
   =
    [%#span53] match self with
      | Trail'0.C_Empty -> Trail'0.C_Empty
      | Trail'0.C_Assign a l tl -> let tl = restrict'0 tl level in let _ = count_bounds'0 tl in if l <= level then
        Trail'0.C_Assign a l tl
      else
        tl
      
      end
  
  function restrict_find'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 582 4 582 60] (self : Trail'0.t_trail) (level : int) (d : (Term'0.t_term, Value'0.t_value)) : ()
    
   =
    [%#span54] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign a _ tl -> if to_pair'0 a = d then () else restrict_find'0 tl level d
      end
  
  axiom restrict_find'0_spec : forall self : Trail'0.t_trail, level : int, d : (Term'0.t_term, Value'0.t_value) . ([%#stheory7] invariant'0 self)
   -> ([%#stheory8] level >= 0)
   -> ([%#stheory9] contains'0 (restrict'0 self level) d)
   -> ([%#stheory10] find'0 (restrict'0 self level) d = find'0 self d)
  
  predicate is_input'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 523 4 523 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span55] match find'0 self d with
      | Option'0.C_Some (Assign'0.C_Input _ _, _) -> true
      | _ -> false
      end
  
  predicate is_decision'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 513 4 513 54] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span56] match find'0 self d with
      | Option'0.C_Some (Assign'0.C_Decision _ _, _) -> true
      | _ -> false
      end
  
  use prelude.prelude.Real
  
  function from_int'0 (_1 : int) : Real.real
  
  function interp'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 167 4 167 41] (self : Model'0.t_model) (t : Term'0.t_term) : Value'0.t_value
    
   =
    [%#span59] match t with
      | Term'0.C_Variable v -> Map.get (Cdsat_Theory_Model_Type.model_0 self) v
      | Term'0.C_Value v -> v
      | Term'0.C_Plus l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Rat r1, Value'0.C_Rat r2) -> Value'0.C_Rat r1
        | _ -> Value'0.C_Rat (from_int'0 (- 1))
        end
      | Term'0.C_Conj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 /\ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Disj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 \/ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Eq l r -> Value'0.C_Bool (interp'0 self l = interp'0 self r)
      | Term'0.C_Neg t -> match interp'0 self t with
        | Value'0.C_Bool b -> Value'0.C_Bool (not b)
        | _ -> Value'0.C_Bool false
        end
      end
  
  axiom interp'0_spec : forall self : Model'0.t_model, t : Term'0.t_term . ([%#span57] inv'0 self)
   -> ([%#span58] invariant'2 self  -> sort'1 (interp'0 self t) = sort'0 t)
  
  predicate satisfies'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 193 4 193 52] (self : Model'0.t_model) (v : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span60] interp'0 self (let (a, _) = v in a) = (let (_, a) = v in a)
  
  predicate satisfy_set'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 199 4 199 60] (self : Model'0.t_model) (v : Fset.fset (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span61] forall a : (Term'0.t_term, Value'0.t_value) . contains'1 v a  -> satisfies'0 self a
  
  predicate justified_sound'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 141 4 141 40] (self : Assign'0.t_assign) =
    [%#span62] match self with
      | Assign'0.C_Justified just t val' -> forall m : Model'0.t_model . inv'0 m
       -> satisfy_set'0 m just  -> satisfies'0 m (t, val')
      | _ -> true
      end
  
  predicate sound'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 261 4 261 30] (self : Trail'0.t_trail)
   =
    [%#span63] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a _ tl -> sound'0 tl /\ justified_sound'0 a
      end
  
  function find_justified'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 622 4 622 46] (self : Trail'0.t_trail) (kv : (Term'0.t_term, Value'0.t_value)) : ()
    
   =
    [%#span67] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = kv then () else find_justified'0 tl kv
      end
  
  axiom find_justified'0_spec : forall self : Trail'0.t_trail, kv : (Term'0.t_term, Value'0.t_value) . ([%#span64] sound'0 self)
   -> ([%#span65] contains'0 self kv)
   -> ([%#span66] forall l : int . forall a : Assign'0.t_assign . find'0 self kv = Option'0.C_Some (a, l)
   -> justified_sound'0 a)
  
  predicate entails'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 205 4 205 74] (self : Model'0.t_model) (j : Fset.fset (Term'0.t_term, Value'0.t_value)) (c : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span68] invariant'2 self  -> satisfy_set'0 self j  -> satisfies'0 self c
  
  predicate is_justified'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 503 4 503 55] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span69] match find'0 self d with
      | Option'0.C_Some (Assign'0.C_Justified _ _ _, _) -> true
      | _ -> false
      end
  
  function justification'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 492 4 492 71] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span76] let _ = find_justified'0 self d in match find'0 self d with
      | Option'0.C_Some (Assign'0.C_Justified j _ _, _) -> j
      | _ -> Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value)
      end
  
  axiom justification'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span70] invariant'0 self)
   -> ([%#span71] is_justified'0 self d)
   -> ([%#span72] sound'0 self)
   -> ([%#span75] is_decision'0 self d
   -> justification'0 self d = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value)))
  && ([%#span74] is_input'0 self d
   -> justification'0 self d = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value)))
  && ([%#span73] forall m : Model'0.t_model . inv'0 m  -> entails'0 m (justification'0 self d) d)
  
  constant self  : Trail'0.t_trail
  
  constant level  : int
  
  constant d  : (Term'0.t_term, Value'0.t_value)
  
  function restrict_kind_unchanged [#"/Users/xavier/Code/cdsat/src/theory.rs" 725 4 725 70] (self : Trail'0.t_trail) (level : int) (d : (Term'0.t_term, Value'0.t_value)) : ()
    
  
  goal vc_restrict_kind_unchanged : ([%#stheory2] contains'0 (restrict'0 self level) d)
   -> ([%#stheory1] level >= 0)
   -> ([%#stheory0] invariant'0 self)
   -> (([%#stheory9] contains'0 (restrict'0 self level) d)
  && ([%#stheory8] level >= 0) && ([%#stheory7] invariant'0 self))
  /\ (([%#stheory10] find'0 (restrict'0 self level) d = find'0 self d)
   -> (let _ = restrict_find'0 self level d in match self with
    | Trail'0.C_Empty -> ([%#stheory6] is_input'0 self d = is_input'0 (restrict'0 self level) d)
    && ([%#stheory5] is_decision'0 self d = is_decision'0 (restrict'0 self level) d)
    && ([%#stheory4] justification'0 self d = justification'0 (restrict'0 self level) d)
    && ([%#stheory3] is_justified'0 self d = is_justified'0 (restrict'0 self level) d)
    | Trail'0.C_Assign a _ tl -> match to_pair'0 a = d with
      | True -> ([%#stheory6] is_input'0 self d = is_input'0 (restrict'0 self level) d)
      && ([%#stheory5] is_decision'0 self d = is_decision'0 (restrict'0 self level) d)
      && ([%#stheory4] justification'0 self d = justification'0 (restrict'0 self level) d)
      && ([%#stheory3] is_justified'0 self d = is_justified'0 (restrict'0 self level) d)
      | False -> (([%#stheory2] contains'0 (restrict'0 tl level) d)
      && ([%#stheory1] level >= 0) && ([%#stheory0] invariant'0 tl))
      /\ (([%#stheory6] is_input'0 tl d = is_input'0 (restrict'0 tl level) d)
      && ([%#stheory5] is_decision'0 tl d = is_decision'0 (restrict'0 tl level) d)
      && ([%#stheory4] justification'0 tl d = justification'0 (restrict'0 tl level) d)
      && ([%#stheory3] is_justified'0 tl d = is_justified'0 (restrict'0 tl level) d)
       -> (let _ = restrict_kind_unchanged tl level d in ([%#stheory6] is_input'0 self d
      = is_input'0 (restrict'0 self level) d)
      && ([%#stheory5] is_decision'0 self d = is_decision'0 (restrict'0 self level) d)
      && ([%#stheory4] justification'0 self d = justification'0 (restrict'0 self level) d)
      && ([%#stheory3] is_justified'0 self d = is_justified'0 (restrict'0 self level) d)))
      end
    end))
end
module Cdsat_Theory_Impl6_Deducef_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 890 15 890 35
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 891 15 891 27
  
  let%span stheory2 = "/Users/xavier/Code/cdsat/src/theory.rs" 892 15 892 26
  
  let%span stheory3 = "/Users/xavier/Code/cdsat/src/theory.rs" 893 4 893 40
  
  let%span stheory4 = "/Users/xavier/Code/cdsat/src/theory.rs" 894 4 894 71
  
  let%span stheory5 = "/Users/xavier/Code/cdsat/src/theory.rs" 895 4 895 58
  
  let%span stheory6 = "/Users/xavier/Code/cdsat/src/theory.rs" 896 4 896 36
  
  let%span stheory7 = "/Users/xavier/Code/cdsat/src/theory.rs" 897 14 897 28
  
  let%span stheory8 = "/Users/xavier/Code/cdsat/src/theory.rs" 898 4 898 38
  
  let%span stheory9 = "/Users/xavier/Code/cdsat/src/theory.rs" 741 15 741 31
  
  let%span stheory10 = "/Users/xavier/Code/cdsat/src/theory.rs" 742 4 742 83
  
  let%span stheory11 = "/Users/xavier/Code/cdsat/src/theory.rs" 281 15 281 38
  
  let%span stheory12 = "/Users/xavier/Code/cdsat/src/theory.rs" 282 4 282 74
  
  let%span stheory13 = "/Users/xavier/Code/cdsat/src/theory.rs" 283 4 283 94
  
  let%span stheory14 = "/Users/xavier/Code/cdsat/src/theory.rs" 284 4 284 48
  
  let%span stheory15 = "/Users/xavier/Code/cdsat/src/theory.rs" 285 14 285 25
  
  let%span stheory16 = "/Users/xavier/Code/cdsat/src/theory.rs" 286 14 286 36
  
  let%span stheory17 = "/Users/xavier/Code/cdsat/src/theory.rs" 280 14 280 21
  
  let%span span18 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span19 = "/Users/xavier/Code/cdsat/src/theory.rs" 157 8 159 9
  
  let%span span20 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span21 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  let%span span22 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span span23 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span24 = "/Users/xavier/Code/cdsat/src/theory.rs" 601 8 605 9
  
  let%span span25 = "/Users/xavier/Code/cdsat/src/theory.rs" 337 8 340 9
  
  let%span span26 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 53 8 53 26
  
  let%span span27 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span28 = "/Users/xavier/Code/cdsat/src/theory.rs" 122 8 126 9
  
  let%span span29 = "/Users/xavier/Code/cdsat/src/theory.rs" 346 8 349 9
  
  let%span span30 = "/Users/xavier/Code/cdsat/src/theory.rs" 132 8 136 9
  
  let%span span31 = "/Users/xavier/Code/cdsat/src/theory.rs" 465 14 468 5
  
  let%span span32 = "/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 111
  
  let%span span33 = "/Users/xavier/Code/cdsat/src/theory.rs" 470 4 470 104
  
  let%span span34 = "/Users/xavier/Code/cdsat/src/theory.rs" 472 8 481 9
  
  let%span span35 = "/Users/xavier/Code/cdsat/src/theory.rs" 406 15 406 38
  
  let%span span36 = "/Users/xavier/Code/cdsat/src/theory.rs" 407 14 407 51
  
  let%span span37 = "/Users/xavier/Code/cdsat/src/theory.rs" 409 8 412 9
  
  let%span span38 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 16 8 16 26
  
  let%span span39 = "/Users/xavier/Code/cdsat/src/theory.rs" 278 4 278 12
  
  let%span span40 = "/Users/xavier/Code/cdsat/src/theory.rs" 417 4 417 87
  
  let%span span41 = "/Users/xavier/Code/cdsat/src/theory.rs" 419 8 422 9
  
  let%span span42 = "/Users/xavier/Code/cdsat/src/theory.rs" 82 8 82 36
  
  let%span span43 = "/Users/xavier/Code/cdsat/src/theory.rs" 96 15 96 29
  
  let%span span44 = "/Users/xavier/Code/cdsat/src/theory.rs" 97 14 97 30
  
  let%span span45 = "/Users/xavier/Code/cdsat/src/theory.rs" 99 8 102 9
  
  let%span span46 = "/Users/xavier/Code/cdsat/src/theory.rs" 374 8 382 9
  
  let%span span47 = "/Users/xavier/Code/cdsat/src/theory.rs" 355 8 368 9
  
  let%span span48 = "/Users/xavier/Code/cdsat/src/theory.rs" 321 8 331 9
  
  let%span span49 = "/Users/xavier/Code/cdsat/src/theory.rs" 388 8 392 38
  
  let%span span50 = "/Users/xavier/Code/cdsat/src/theory.rs" 744 8 749 9
  
  let%span span51 = "/Users/xavier/Code/cdsat/src/theory.rs" 167 18 167 22
  
  let%span span52 = "/Users/xavier/Code/cdsat/src/theory.rs" 166 4 166 62
  
  let%span span53 = "/Users/xavier/Code/cdsat/src/theory.rs" 168 8 188 9
  
  let%span span54 = "/Users/xavier/Code/cdsat/src/theory.rs" 194 8 194 31
  
  let%span span55 = "/Users/xavier/Code/cdsat/src/theory.rs" 678 8 678 71
  
  let%span span56 = "/Users/xavier/Code/cdsat/src/theory.rs" 562 8 573 9
  
  let%span span57 = "/Users/xavier/Code/cdsat/src/theory.rs" 685 8 685 82
  
  let%span span58 = "/Users/xavier/Code/cdsat/src/theory.rs" 696 4 696 55
  
  let%span span59 = "/Users/xavier/Code/cdsat/src/theory.rs" 698 8 698 108
  
  let%span span60 = "/Users/xavier/Code/cdsat/src/theory.rs" 200 8 200 71
  
  let%span span61 = "/Users/xavier/Code/cdsat/src/theory.rs" 206 8 206 84
  
  let%span span62 = "/Users/xavier/Code/cdsat/src/theory.rs" 398 8 400 79
  
  let%span span63 = "/Users/xavier/Code/cdsat/src/theory.rs" 142 8 147 9
  
  let%span span64 = "/Users/xavier/Code/cdsat/src/theory.rs" 262 8 265 9
  
  let%span span65 = "/Users/xavier/Code/cdsat/src/theory.rs" 826 4 826 16
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  use Cdsat_Theory_Value_Type as Value'0
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span18] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  use map.Map
  
  use Cdsat_Theory_Model_Type as Cdsat_Theory_Model_Type
  
  use Cdsat_Theory_Var_Type as Var'0
  
  use Cdsat_Theory_Model_Type as Model'0
  
  predicate invariant'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 156 4 156 30] (self : Model'0.t_model) =
    [%#span19] forall v : Value'0.t_value . forall k : Var'0.t_var . Map.get (Cdsat_Theory_Model_Type.model_0 self) k
    = v  -> Cdsat_Theory_Var_Type.var_1 k = sort'0 v
  
  predicate inv'0 (_x : Model'0.t_model)
  
  axiom inv'0 : forall x : Model'0.t_model . inv'0 x
  = (invariant'1 x
  /\ match x with
    | Model'0.C_Model a_0 -> true
    end)
  
  use set.Fset
  
  use set.Fset
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  use prelude.prelude.Int
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span21] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span20] len'0 self >= 0
  
  function level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int =
    [%#span24] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> 1 + level'0 tl
      | Trail'0.C_Assign _ _ tl -> level'0 tl
      end
  
  axiom level'0_spec : forall self : Trail'0.t_trail . ([%#span23] level'0 self <= len'0 self)
  && ([%#span22] level'0 self >= 0)
  
  predicate invariant_nonneg'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 336 4 336 41] (self : Trail'0.t_trail) =
    [%#span25] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_nonneg'0 tl /\ l >= 0 /\ l <= level'0 self
      end
  
  use set.Fset
  
  use Cdsat_Theory_Term_Type as Term'0
  
  use set.Fset
  
  function remove'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (a : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span26] Fset.remove a self
  
  use set.Fset
  
  use prelude.prelude.Int
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span27] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'0 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  predicate invariant'2 [#"/Users/xavier/Code/cdsat/src/theory.rs" 121 4 121 34] (self : Assign'0.t_assign) =
    [%#span28] match self with
      | Assign'0.C_Decision t v -> sort'1 t = sort'0 v
      | Assign'0.C_Justified _ t v -> sort'1 t = sort'0 v /\ sort'1 t = Sort'0.C_Boolean
      | Assign'0.C_Input t v -> sort'1 t = sort'0 v
      end
  
  predicate invariant_assign'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 345 4 345 41] (self : Trail'0.t_trail) =
    [%#span29] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_assign'0 tl /\ invariant'2 a
      end
  
  function to_pair'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 131 4 131 41] (self : Assign'0.t_assign) : (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span30] match self with
      | Assign'0.C_Decision t val' -> (t, val')
      | Assign'0.C_Input t val' -> (t, val')
      | Assign'0.C_Justified _ t val' -> (t, val')
      end
  
  use Core_Option_Option_Type as Option'0
  
  function find'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 471 4 471 64] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Option'0.t_option (Assign'0.t_assign, int)
    
   =
    [%#span34] match self with
      | Trail'0.C_Empty -> Option'0.C_None
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then Option'0.C_Some (a, l) else find'0 tl d
      end
  
  axiom find'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span33] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'1 (let (a, _) = d in a) = sort'0 (let (_, a) = d in a)))
  && ([%#span32] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
  && ([%#span31] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
  
  function level_of'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 408 4 408 50] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : int
    
   =
    [%#span37] match find'0 self d with
      | Option'0.C_Some (_, l) -> l
      | Option'0.C_None -> 0
      end
  
  axiom level_of'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span35] invariant_nonneg'0 self)
   -> ([%#span36] level_of'0 self d >= 0 /\ level_of'0 self d <= level'0 self)
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (e : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span38] Fset.mem e self
  
  function set_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 287 4 287 57] (self : Trail'0.t_trail) (s : Fset.fset (Term'0.t_term, Value'0.t_value)) : int
    
  
  axiom set_level'0_def : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . set_level'0 self s
  = ([%#span39] if Fset.cardinal s = 0 then
    0
  else
    if Fset.cardinal s = 1 then
      level_of'0 self (Fset.pick s)
    else
      let a = Fset.pick s in let rec' = set_level'0 self (remove'0 s a) in if level_of'0 self a >= rec' then
        level_of'0 self a
      else
        rec'
      
    
  )
  
  axiom set_level'0_spec : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . ([%#stheory11] invariant_nonneg'0 self)
   -> ([%#stheory16] set_level'0 self s <= level'0 self)
  && ([%#stheory15] set_level'0 self s >= 0)
  && ([%#stheory14] s = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))  -> set_level'0 self s = 0)
  && ([%#stheory13] s <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
   -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'0 s i /\ level_of'0 self i = set_level'0 self s))
  && ([%#stheory12] forall i : (Term'0.t_term, Value'0.t_value) . contains'0 s i
   -> level_of'0 self i <= set_level'0 self s)
  
  predicate contains'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 418 4 418 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span41] match find'0 self d with
      | Option'0.C_Some ix -> true
      | Option'0.C_None -> false
      end
  
  axiom contains'1_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . [%#span40] invariant_assign'0 self
   -> contains'1 self d = true  -> sort'1 (let (a, _) = d in a) = sort'0 (let (_, a) = d in a)
  
  predicate is_bool'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 81 4 81 32] (self : Value'0.t_value) =
    [%#span42] sort'0 self = Sort'0.C_Boolean
  
  function negate'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 98 4 98 31] (self : Value'0.t_value) : Value'0.t_value =
    [%#span45] match self with
      | Value'0.C_Bool b -> Value'0.C_Bool (not b)
      | _ -> self
      end
  
  axiom negate'0_spec : forall self : Value'0.t_value . ([%#span43] is_bool'0 self)
   -> ([%#span44] is_bool'0 (negate'0 self))
  
  predicate trail_unique'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 373 4 373 37] (self : Trail'0.t_trail) =
    [%#span46] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> let ap = to_pair'0 a in not contains'1 tl ap
      /\ trail_unique'0 tl
      /\ (if is_bool'0 (let (_, a) = ap in a) then
        not contains'1 tl ((let (a, _) = ap in a), negate'0 (let (_, a) = ap in a))
      else
        true
      )
      end
  
  predicate invariant_contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 354 4 354 43] (self : Trail'0.t_trail) =
    [%#span47] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_contains'0 tl
      /\ match a with
        | Assign'0.C_Justified j _ _ -> forall a : (Term'0.t_term, Value'0.t_value) . contains'0 j a  -> contains'1 tl a
        | _ -> true
        end
      end
  
  predicate invariant_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 320 4 320 40] (self : Trail'0.t_trail) =
    [%#span48] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_level'0 tl
      /\ match a with
        | Assign'0.C_Input _ _ -> l = 0
        | Assign'0.C_Decision _ _ -> level'0 tl + 1 = l
        | Assign'0.C_Justified j _ _ -> set_level'0 tl j = l
        end
      end
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 387 4 387 34] (self : Trail'0.t_trail) =
    [%#span49] invariant_level'0 self
    /\ invariant_contains'0 self /\ trail_unique'0 self /\ invariant_nonneg'0 self /\ invariant_assign'0 self
  
  function count_bounds'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 743 4 743 35] (self : Trail'0.t_trail) : () =
    [%#span50] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign (Assign'0.C_Input _ _) _ tl -> count_bounds'0 tl
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> count_bounds'0 tl
      | Trail'0.C_Assign (Assign'0.C_Justified _ _ _) _ tl -> count_bounds'0 tl
      end
  
  axiom count_bounds'0_spec : forall self : Trail'0.t_trail . ([%#stheory9] invariant'0 self)
   -> ([%#stheory10] forall a : (Term'0.t_term, Value'0.t_value) . contains'1 self a
   -> level_of'0 self a <= level'0 self)
  
  use Cdsat_Theory_Normal_Type as Normal'0
  
  use prelude.prelude.Real
  
  function from_int'0 (_1 : int) : Real.real
  
  function interp'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 167 4 167 41] (self : Model'0.t_model) (t : Term'0.t_term) : Value'0.t_value
    
   =
    [%#span53] match t with
      | Term'0.C_Variable v -> Map.get (Cdsat_Theory_Model_Type.model_0 self) v
      | Term'0.C_Value v -> v
      | Term'0.C_Plus l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Rat r1, Value'0.C_Rat r2) -> Value'0.C_Rat r1
        | _ -> Value'0.C_Rat (from_int'0 (- 1))
        end
      | Term'0.C_Conj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 /\ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Disj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 \/ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Eq l r -> Value'0.C_Bool (interp'0 self l = interp'0 self r)
      | Term'0.C_Neg t -> match interp'0 self t with
        | Value'0.C_Bool b -> Value'0.C_Bool (not b)
        | _ -> Value'0.C_Bool false
        end
      end
  
  axiom interp'0_spec : forall self : Model'0.t_model, t : Term'0.t_term . ([%#span51] inv'0 self)
   -> ([%#span52] invariant'1 self  -> sort'0 (interp'0 self t) = sort'1 t)
  
  predicate satisfies'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 193 4 193 52] (self : Model'0.t_model) (v : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span54] interp'0 self (let (a, _) = v in a) = (let (_, a) = v in a)
  
  predicate satisfied_by'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 677 4 677 47] (self : Trail'0.t_trail) (m : Model'0.t_model)
    
   =
    [%#span55] forall a : (Term'0.t_term, Value'0.t_value) . contains'1 self a  -> satisfies'0 m a
  
  function restrict'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 561 4 561 45] (self : Trail'0.t_trail) (level : int) : Trail'0.t_trail
    
   =
    [%#span56] match self with
      | Trail'0.C_Empty -> Trail'0.C_Empty
      | Trail'0.C_Assign a l tl -> let tl = restrict'0 tl level in let _ = count_bounds'0 tl in if l <= level then
        Trail'0.C_Assign a l tl
      else
        tl
      
      end
  
  predicate unsat'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 684 4 684 30] (self : Trail'0.t_trail) =
    [%#span57] forall m : Model'0.t_model . inv'0 m  -> satisfied_by'0 (restrict'0 self 0) m  -> false
  
  predicate impls'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 697 4 697 41] (self : Trail'0.t_trail) (rhs : Trail'0.t_trail)
    
   =
    [%#span59] forall m : Model'0.t_model . inv'0 m
     -> satisfied_by'0 (restrict'0 self 0) m  -> satisfied_by'0 (restrict'0 rhs 0) m
  
  axiom impls'0_spec : forall self : Trail'0.t_trail, rhs : Trail'0.t_trail . [%#span58] impls'0 self rhs
   -> unsat'0 rhs  -> unsat'0 self
  
  predicate satisfy_set'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 199 4 199 60] (self : Model'0.t_model) (v : Fset.fset (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span60] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 v a  -> satisfies'0 self a
  
  predicate entails'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 205 4 205 74] (self : Model'0.t_model) (j : Fset.fset (Term'0.t_term, Value'0.t_value)) (c : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span61] invariant'1 self  -> satisfy_set'0 self j  -> satisfies'0 self c
  
  predicate acceptable'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 397 4 397 56] (self : Trail'0.t_trail) (t : Term'0.t_term) (val' : Value'0.t_value)
    
   =
    [%#span62] not contains'1 self (t, val')
    /\ sort'1 t = sort'0 val' /\ (is_bool'0 val'  -> not contains'1 self (t, negate'0 val'))
  
  predicate justified_sound'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 141 4 141 40] (self : Assign'0.t_assign) =
    [%#span63] match self with
      | Assign'0.C_Justified just t val' -> forall m : Model'0.t_model . inv'0 m
       -> satisfy_set'0 m just  -> satisfies'0 m (t, val')
      | _ -> true
      end
  
  predicate sound'1 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 261 4 261 30] (self : Trail'0.t_trail)
   =
    [%#span64] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a _ tl -> sound'1 tl /\ justified_sound'0 a
      end
  
  use Cdsat_Theory_Normal_Type as Cdsat_Theory_Normal_Type
  
  predicate sound'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 829 4 829 30] (self : Normal'0.t_normal)
    
   =
    [%#span65] sound'1 (Cdsat_Theory_Normal_Type.normal_0 self)
  
  constant self  : Normal'0.t_normal
  
  constant just  : Fset.fset (Term'0.t_term, Value'0.t_value)
  
  constant t  : Term'0.t_term
  
  constant v  : Value'0.t_value
  
  function deducef [#"/Users/xavier/Code/cdsat/src/theory.rs" 899 4 899 78] (self : Normal'0.t_normal) (just : Fset.fset (Term'0.t_term, Value'0.t_value)) (t : Term'0.t_term) (v : Value'0.t_value) : Normal'0.t_normal
    
  
  goal vc_deducef : ([%#stheory5] forall m : Model'0.t_model . inv'0 m  -> entails'0 m just (t, v))
   -> ([%#stheory4] forall j : (Term'0.t_term, Value'0.t_value) . contains'0 just j
   -> contains'1 (Cdsat_Theory_Normal_Type.normal_0 self) j)
   -> ([%#stheory3] acceptable'0 (Cdsat_Theory_Normal_Type.normal_0 self) t v)
   -> ([%#stheory2] is_bool'0 v)
   -> ([%#stheory1] sound'0 self)
   -> ([%#stheory0] invariant'0 (Cdsat_Theory_Normal_Type.normal_0 self))
   -> ([%#stheory9] invariant'0 (Cdsat_Theory_Normal_Type.normal_0 self))
  /\ (([%#stheory10] forall a : (Term'0.t_term, Value'0.t_value) . contains'1 (Cdsat_Theory_Normal_Type.normal_0 self) a
   -> level_of'0 (Cdsat_Theory_Normal_Type.normal_0 self) a <= level'0 (Cdsat_Theory_Normal_Type.normal_0 self))
   -> (let _ = count_bounds'0 (Cdsat_Theory_Normal_Type.normal_0 self) in ([%#stheory11] invariant_nonneg'0 (Cdsat_Theory_Normal_Type.normal_0 self))
  /\ (([%#stheory16] set_level'0 (Cdsat_Theory_Normal_Type.normal_0 self) just
  <= level'0 (Cdsat_Theory_Normal_Type.normal_0 self))
  && ([%#stheory15] set_level'0 (Cdsat_Theory_Normal_Type.normal_0 self) just >= 0)
  && ([%#stheory14] just = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
   -> set_level'0 (Cdsat_Theory_Normal_Type.normal_0 self) just = 0)
  && ([%#stheory13] just <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
   -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'0 just i
  /\ level_of'0 (Cdsat_Theory_Normal_Type.normal_0 self) i = set_level'0 (Cdsat_Theory_Normal_Type.normal_0 self) just))
  && ([%#stheory12] forall i : (Term'0.t_term, Value'0.t_value) . contains'0 just i
   -> level_of'0 (Cdsat_Theory_Normal_Type.normal_0 self) i
  <= set_level'0 (Cdsat_Theory_Normal_Type.normal_0 self) just)
   -> (let result = Normal'0.C_Normal (Trail'0.C_Assign (Assign'0.C_Justified just t v) (set_level'0 (Cdsat_Theory_Normal_Type.normal_0 self) just) (Cdsat_Theory_Normal_Type.normal_0 self)) in ([%#stheory8] impls'0 (Cdsat_Theory_Normal_Type.normal_0 self) (Cdsat_Theory_Normal_Type.normal_0 result))
  && ([%#stheory7] sound'0 result) && ([%#stheory6] invariant'0 (Cdsat_Theory_Normal_Type.normal_0 result))))))
end
module Cdsat_Theory_Impl5_JustStable_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 649 15 649 26
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 650 15 650 32
  
  let%span stheory2 = "/Users/xavier/Code/cdsat/src/theory.rs" 651 15 651 29
  
  let%span stheory3 = "/Users/xavier/Code/cdsat/src/theory.rs" 652 15 652 36
  
  let%span stheory4 = "/Users/xavier/Code/cdsat/src/theory.rs" 653 14 653 59
  
  let%span span5 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span6 = "/Users/xavier/Code/cdsat/src/theory.rs" 157 8 159 9
  
  let%span span7 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span8 = "/Users/xavier/Code/cdsat/src/theory.rs" 122 8 126 9
  
  let%span span9 = "/Users/xavier/Code/cdsat/src/theory.rs" 346 8 349 9
  
  let%span span10 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span11 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  let%span span12 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span span13 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span14 = "/Users/xavier/Code/cdsat/src/theory.rs" 601 8 605 9
  
  let%span span15 = "/Users/xavier/Code/cdsat/src/theory.rs" 337 8 340 9
  
  let%span span16 = "/Users/xavier/Code/cdsat/src/theory.rs" 132 8 136 9
  
  let%span span17 = "/Users/xavier/Code/cdsat/src/theory.rs" 465 14 468 5
  
  let%span span18 = "/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 111
  
  let%span span19 = "/Users/xavier/Code/cdsat/src/theory.rs" 470 4 470 104
  
  let%span span20 = "/Users/xavier/Code/cdsat/src/theory.rs" 472 8 481 9
  
  let%span span21 = "/Users/xavier/Code/cdsat/src/theory.rs" 167 18 167 22
  
  let%span span22 = "/Users/xavier/Code/cdsat/src/theory.rs" 166 4 166 62
  
  let%span span23 = "/Users/xavier/Code/cdsat/src/theory.rs" 168 8 188 9
  
  let%span span24 = "/Users/xavier/Code/cdsat/src/theory.rs" 194 8 194 31
  
  let%span span25 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 16 8 16 26
  
  let%span span26 = "/Users/xavier/Code/cdsat/src/theory.rs" 200 8 200 71
  
  let%span span27 = "/Users/xavier/Code/cdsat/src/theory.rs" 142 8 147 9
  
  let%span span28 = "/Users/xavier/Code/cdsat/src/theory.rs" 417 4 417 87
  
  let%span span29 = "/Users/xavier/Code/cdsat/src/theory.rs" 419 8 422 9
  
  let%span span30 = "/Users/xavier/Code/cdsat/src/theory.rs" 262 8 265 9
  
  let%span span31 = "/Users/xavier/Code/cdsat/src/theory.rs" 619 15 619 27
  
  let%span span32 = "/Users/xavier/Code/cdsat/src/theory.rs" 620 15 620 32
  
  let%span span33 = "/Users/xavier/Code/cdsat/src/theory.rs" 621 4 621 90
  
  let%span span34 = "/Users/xavier/Code/cdsat/src/theory.rs" 623 8 632 9
  
  let%span span35 = "/Users/xavier/Code/cdsat/src/theory.rs" 514 8 517 9
  
  let%span span36 = "/Users/xavier/Code/cdsat/src/theory.rs" 524 8 527 9
  
  let%span span37 = "/Users/xavier/Code/cdsat/src/theory.rs" 206 8 206 84
  
  let%span span38 = "/Users/xavier/Code/cdsat/src/theory.rs" 504 8 507 9
  
  let%span span39 = "/Users/xavier/Code/cdsat/src/theory.rs" 82 8 82 36
  
  let%span span40 = "/Users/xavier/Code/cdsat/src/theory.rs" 96 15 96 29
  
  let%span span41 = "/Users/xavier/Code/cdsat/src/theory.rs" 97 14 97 30
  
  let%span span42 = "/Users/xavier/Code/cdsat/src/theory.rs" 99 8 102 9
  
  let%span span43 = "/Users/xavier/Code/cdsat/src/theory.rs" 374 8 382 9
  
  let%span span44 = "/Users/xavier/Code/cdsat/src/theory.rs" 355 8 368 9
  
  let%span span45 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 53 8 53 26
  
  let%span span46 = "/Users/xavier/Code/cdsat/src/theory.rs" 406 15 406 38
  
  let%span span47 = "/Users/xavier/Code/cdsat/src/theory.rs" 407 14 407 51
  
  let%span span48 = "/Users/xavier/Code/cdsat/src/theory.rs" 409 8 412 9
  
  let%span span49 = "/Users/xavier/Code/cdsat/src/theory.rs" 281 15 281 38
  
  let%span span50 = "/Users/xavier/Code/cdsat/src/theory.rs" 282 4 282 74
  
  let%span span51 = "/Users/xavier/Code/cdsat/src/theory.rs" 283 4 283 94
  
  let%span span52 = "/Users/xavier/Code/cdsat/src/theory.rs" 284 4 284 48
  
  let%span span53 = "/Users/xavier/Code/cdsat/src/theory.rs" 285 14 285 25
  
  let%span span54 = "/Users/xavier/Code/cdsat/src/theory.rs" 286 14 286 36
  
  let%span span55 = "/Users/xavier/Code/cdsat/src/theory.rs" 280 14 280 21
  
  let%span span56 = "/Users/xavier/Code/cdsat/src/theory.rs" 278 4 278 12
  
  let%span span57 = "/Users/xavier/Code/cdsat/src/theory.rs" 321 8 331 9
  
  let%span span58 = "/Users/xavier/Code/cdsat/src/theory.rs" 388 8 392 38
  
  let%span span59 = "/Users/xavier/Code/cdsat/src/theory.rs" 486 15 486 31
  
  let%span span60 = "/Users/xavier/Code/cdsat/src/theory.rs" 487 15 487 35
  
  let%span span61 = "/Users/xavier/Code/cdsat/src/theory.rs" 488 15 488 27
  
  let%span span62 = "/Users/xavier/Code/cdsat/src/theory.rs" 489 4 489 54
  
  let%span span63 = "/Users/xavier/Code/cdsat/src/theory.rs" 490 4 490 58
  
  let%span span64 = "/Users/xavier/Code/cdsat/src/theory.rs" 491 4 491 61
  
  let%span span65 = "/Users/xavier/Code/cdsat/src/theory.rs" 493 8 493 30
  
  let%span span66 = "/Users/xavier/Code/cdsat/src/theory.rs" 638 8 644 9
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  use Cdsat_Theory_Value_Type as Value'0
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span5] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  use map.Map
  
  use Cdsat_Theory_Model_Type as Cdsat_Theory_Model_Type
  
  use Cdsat_Theory_Var_Type as Var'0
  
  use Cdsat_Theory_Model_Type as Model'0
  
  predicate invariant'2 [#"/Users/xavier/Code/cdsat/src/theory.rs" 156 4 156 30] (self : Model'0.t_model) =
    [%#span6] forall v : Value'0.t_value . forall k : Var'0.t_var . Map.get (Cdsat_Theory_Model_Type.model_0 self) k = v
     -> Cdsat_Theory_Var_Type.var_1 k = sort'1 v
  
  predicate inv'0 (_x : Model'0.t_model)
  
  axiom inv'0 : forall x : Model'0.t_model . inv'0 x
  = (invariant'2 x
  /\ match x with
    | Model'0.C_Model a_0 -> true
    end)
  
  use Cdsat_Theory_Term_Type as Term'0
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  use prelude.prelude.Int
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span7] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'1 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  predicate invariant'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 121 4 121 34] (self : Assign'0.t_assign) =
    [%#span8] match self with
      | Assign'0.C_Decision t v -> sort'0 t = sort'1 v
      | Assign'0.C_Justified _ t v -> sort'0 t = sort'1 v /\ sort'0 t = Sort'0.C_Boolean
      | Assign'0.C_Input t v -> sort'0 t = sort'1 v
      end
  
  predicate invariant_assign'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 345 4 345 41] (self : Trail'0.t_trail) =
    [%#span9] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_assign'0 tl /\ invariant'1 a
      end
  
  use prelude.prelude.Int
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span11] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span10] len'0 self >= 0
  
  function level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int =
    [%#span14] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> 1 + level'0 tl
      | Trail'0.C_Assign _ _ tl -> level'0 tl
      end
  
  axiom level'0_spec : forall self : Trail'0.t_trail . ([%#span13] level'0 self <= len'0 self)
  && ([%#span12] level'0 self >= 0)
  
  predicate invariant_nonneg'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 336 4 336 41] (self : Trail'0.t_trail) =
    [%#span15] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_nonneg'0 tl /\ l >= 0 /\ l <= level'0 self
      end
  
  function to_pair'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 131 4 131 41] (self : Assign'0.t_assign) : (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span16] match self with
      | Assign'0.C_Decision t val' -> (t, val')
      | Assign'0.C_Input t val' -> (t, val')
      | Assign'0.C_Justified _ t val' -> (t, val')
      end
  
  use Core_Option_Option_Type as Option'0
  
  function find'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 471 4 471 64] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Option'0.t_option (Assign'0.t_assign, int)
    
   =
    [%#span20] match self with
      | Trail'0.C_Empty -> Option'0.C_None
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then Option'0.C_Some (a, l) else find'0 tl d
      end
  
  axiom find'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span19] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)))
  && ([%#span18] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
  && ([%#span17] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
  
  use set.Fset
  
  use prelude.prelude.Real
  
  function from_int'0 (_1 : int) : Real.real
  
  function interp'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 167 4 167 41] (self : Model'0.t_model) (t : Term'0.t_term) : Value'0.t_value
    
   =
    [%#span23] match t with
      | Term'0.C_Variable v -> Map.get (Cdsat_Theory_Model_Type.model_0 self) v
      | Term'0.C_Value v -> v
      | Term'0.C_Plus l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Rat r1, Value'0.C_Rat r2) -> Value'0.C_Rat r1
        | _ -> Value'0.C_Rat (from_int'0 (- 1))
        end
      | Term'0.C_Conj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 /\ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Disj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 \/ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Eq l r -> Value'0.C_Bool (interp'0 self l = interp'0 self r)
      | Term'0.C_Neg t -> match interp'0 self t with
        | Value'0.C_Bool b -> Value'0.C_Bool (not b)
        | _ -> Value'0.C_Bool false
        end
      end
  
  axiom interp'0_spec : forall self : Model'0.t_model, t : Term'0.t_term . ([%#span21] inv'0 self)
   -> ([%#span22] invariant'2 self  -> sort'1 (interp'0 self t) = sort'0 t)
  
  predicate satisfies'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 193 4 193 52] (self : Model'0.t_model) (v : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span24] interp'0 self (let (a, _) = v in a) = (let (_, a) = v in a)
  
  use set.Fset
  
  predicate contains'1 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (e : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span25] Fset.mem e self
  
  predicate satisfy_set'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 199 4 199 60] (self : Model'0.t_model) (v : Fset.fset (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span26] forall a : (Term'0.t_term, Value'0.t_value) . contains'1 v a  -> satisfies'0 self a
  
  predicate justified_sound'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 141 4 141 40] (self : Assign'0.t_assign) =
    [%#span27] match self with
      | Assign'0.C_Justified just t val' -> forall m : Model'0.t_model . inv'0 m
       -> satisfy_set'0 m just  -> satisfies'0 m (t, val')
      | _ -> true
      end
  
  predicate contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 418 4 418 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span29] match find'0 self d with
      | Option'0.C_Some ix -> true
      | Option'0.C_None -> false
      end
  
  axiom contains'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . [%#span28] invariant_assign'0 self
   -> contains'0 self d = true  -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)
  
  predicate sound'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 261 4 261 30] (self : Trail'0.t_trail)
   =
    [%#span30] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a _ tl -> sound'0 tl /\ justified_sound'0 a
      end
  
  function find_justified'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 622 4 622 46] (self : Trail'0.t_trail) (kv : (Term'0.t_term, Value'0.t_value)) : ()
    
   =
    [%#span34] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = kv then () else find_justified'0 tl kv
      end
  
  axiom find_justified'0_spec : forall self : Trail'0.t_trail, kv : (Term'0.t_term, Value'0.t_value) . ([%#span31] sound'0 self)
   -> ([%#span32] contains'0 self kv)
   -> ([%#span33] forall l : int . forall a : Assign'0.t_assign . find'0 self kv = Option'0.C_Some (a, l)
   -> justified_sound'0 a)
  
  predicate is_decision'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 513 4 513 54] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span35] match find'0 self d with
      | Option'0.C_Some (Assign'0.C_Decision _ _, _) -> true
      | _ -> false
      end
  
  use set.Fset
  
  predicate is_input'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 523 4 523 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span36] match find'0 self d with
      | Option'0.C_Some (Assign'0.C_Input _ _, _) -> true
      | _ -> false
      end
  
  predicate entails'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 205 4 205 74] (self : Model'0.t_model) (j : Fset.fset (Term'0.t_term, Value'0.t_value)) (c : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span37] invariant'2 self  -> satisfy_set'0 self j  -> satisfies'0 self c
  
  predicate is_justified'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 503 4 503 55] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span38] match find'0 self d with
      | Option'0.C_Some (Assign'0.C_Justified _ _ _, _) -> true
      | _ -> false
      end
  
  predicate is_bool'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 81 4 81 32] (self : Value'0.t_value) =
    [%#span39] sort'1 self = Sort'0.C_Boolean
  
  function negate'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 98 4 98 31] (self : Value'0.t_value) : Value'0.t_value =
    [%#span42] match self with
      | Value'0.C_Bool b -> Value'0.C_Bool (not b)
      | _ -> self
      end
  
  axiom negate'0_spec : forall self : Value'0.t_value . ([%#span40] is_bool'0 self)
   -> ([%#span41] is_bool'0 (negate'0 self))
  
  predicate trail_unique'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 373 4 373 37] (self : Trail'0.t_trail) =
    [%#span43] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> let ap = to_pair'0 a in not contains'0 tl ap
      /\ trail_unique'0 tl
      /\ (if is_bool'0 (let (_, a) = ap in a) then
        not contains'0 tl ((let (a, _) = ap in a), negate'0 (let (_, a) = ap in a))
      else
        true
      )
      end
  
  predicate invariant_contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 354 4 354 43] (self : Trail'0.t_trail) =
    [%#span44] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_contains'0 tl
      /\ match a with
        | Assign'0.C_Justified j _ _ -> forall a : (Term'0.t_term, Value'0.t_value) . contains'1 j a  -> contains'0 tl a
        | _ -> true
        end
      end
  
  use set.Fset
  
  function remove'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (a : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span45] Fset.remove a self
  
  use set.Fset
  
  use set.Fset
  
  function level_of'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 408 4 408 50] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : int
    
   =
    [%#span48] match find'0 self d with
      | Option'0.C_Some (_, l) -> l
      | Option'0.C_None -> 0
      end
  
  axiom level_of'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span46] invariant_nonneg'0 self)
   -> ([%#span47] level_of'0 self d >= 0 /\ level_of'0 self d <= level'0 self)
  
  function set_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 287 4 287 57] (self : Trail'0.t_trail) (s : Fset.fset (Term'0.t_term, Value'0.t_value)) : int
    
  
  axiom set_level'0_def : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . set_level'0 self s
  = ([%#span56] if Fset.cardinal s = 0 then
    0
  else
    if Fset.cardinal s = 1 then
      level_of'0 self (Fset.pick s)
    else
      let a = Fset.pick s in let rec' = set_level'0 self (remove'0 s a) in if level_of'0 self a >= rec' then
        level_of'0 self a
      else
        rec'
      
    
  )
  
  axiom set_level'0_spec : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . ([%#span49] invariant_nonneg'0 self)
   -> ([%#span54] set_level'0 self s <= level'0 self)
  && ([%#span53] set_level'0 self s >= 0)
  && ([%#span52] s = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))  -> set_level'0 self s = 0)
  && ([%#span51] s <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
   -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'1 s i /\ level_of'0 self i = set_level'0 self s))
  && ([%#span50] forall i : (Term'0.t_term, Value'0.t_value) . contains'1 s i
   -> level_of'0 self i <= set_level'0 self s)
  
  predicate invariant_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 320 4 320 40] (self : Trail'0.t_trail) =
    [%#span57] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_level'0 tl
      /\ match a with
        | Assign'0.C_Input _ _ -> l = 0
        | Assign'0.C_Decision _ _ -> level'0 tl + 1 = l
        | Assign'0.C_Justified j _ _ -> set_level'0 tl j = l
        end
      end
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 387 4 387 34] (self : Trail'0.t_trail) =
    [%#span58] invariant_level'0 self
    /\ invariant_contains'0 self /\ trail_unique'0 self /\ invariant_nonneg'0 self /\ invariant_assign'0 self
  
  function justification'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 492 4 492 71] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span65] let _ = find_justified'0 self d in match find'0 self d with
      | Option'0.C_Some (Assign'0.C_Justified j _ _, _) -> j
      | _ -> Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value)
      end
  
  axiom justification'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span59] invariant'0 self)
   -> ([%#span60] is_justified'0 self d)
   -> ([%#span61] sound'0 self)
   -> ([%#span64] is_decision'0 self d
   -> justification'0 self d = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value)))
  && ([%#span63] is_input'0 self d
   -> justification'0 self d = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value)))
  && ([%#span62] forall m : Model'0.t_model . inv'0 m  -> entails'0 m (justification'0 self d) d)
  
  predicate ext'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 637 4 637 37] (self : Trail'0.t_trail) (o : Trail'0.t_trail)
    
   =
    [%#span66] if level'0 self <= level'0 o then
      forall kv : (Term'0.t_term, Value'0.t_value) . contains'0 self kv  -> find'0 self kv = find'0 o kv
    else
      forall kv : (Term'0.t_term, Value'0.t_value) . contains'0 o kv  -> find'0 o kv = find'0 self kv
    
  
  constant self  : Trail'0.t_trail
  
  constant o  : Trail'0.t_trail
  
  constant kv  : (Term'0.t_term, Value'0.t_value)
  
  function just_stable [#"/Users/xavier/Code/cdsat/src/theory.rs" 654 4 654 56] (self : Trail'0.t_trail) (o : Trail'0.t_trail) (kv : (Term'0.t_term, Value'0.t_value)) : ()
    
  
  goal vc_just_stable : ([%#stheory3] is_justified'0 self kv)
   -> ([%#stheory2] contains'0 o kv)
   -> ([%#stheory1] contains'0 self kv)
   -> ([%#stheory0] ext'0 self o)  -> ([%#stheory4] justification'0 self kv = justification'0 o kv)
end
module Cdsat_Theory_Impl6_Decidef_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 850 15 850 35
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 851 15 851 27
  
  let%span stheory2 = "/Users/xavier/Code/cdsat/src/theory.rs" 852 4 852 42
  
  let%span stheory3 = "/Users/xavier/Code/cdsat/src/theory.rs" 853 4 853 36
  
  let%span stheory4 = "/Users/xavier/Code/cdsat/src/theory.rs" 854 14 854 28
  
  let%span stheory5 = "/Users/xavier/Code/cdsat/src/theory.rs" 855 4 855 38
  
  let%span stheory6 = "/Users/xavier/Code/cdsat/src/theory.rs" 856 4 856 90
  
  let%span stheory7 = "/Users/xavier/Code/cdsat/src/theory.rs" 857 4 857 73
  
  let%span stheory8 = "/Users/xavier/Code/cdsat/src/theory.rs" 858 4 858 43
  
  let%span stheory9 = "/Users/xavier/Code/cdsat/src/theory.rs" 859 4 859 82
  
  let%span stheory10 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span stheory11 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span12 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span13 = "/Users/xavier/Code/cdsat/src/theory.rs" 157 8 159 9
  
  let%span span14 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span15 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  let%span span16 = "/Users/xavier/Code/cdsat/src/theory.rs" 601 8 605 9
  
  let%span span17 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span18 = "/Users/xavier/Code/cdsat/src/theory.rs" 122 8 126 9
  
  let%span span19 = "/Users/xavier/Code/cdsat/src/theory.rs" 346 8 349 9
  
  let%span span20 = "/Users/xavier/Code/cdsat/src/theory.rs" 337 8 340 9
  
  let%span span21 = "/Users/xavier/Code/cdsat/src/theory.rs" 132 8 136 9
  
  let%span span22 = "/Users/xavier/Code/cdsat/src/theory.rs" 465 14 468 5
  
  let%span span23 = "/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 111
  
  let%span span24 = "/Users/xavier/Code/cdsat/src/theory.rs" 470 4 470 104
  
  let%span span25 = "/Users/xavier/Code/cdsat/src/theory.rs" 472 8 481 9
  
  let%span span26 = "/Users/xavier/Code/cdsat/src/theory.rs" 167 18 167 22
  
  let%span span27 = "/Users/xavier/Code/cdsat/src/theory.rs" 166 4 166 62
  
  let%span span28 = "/Users/xavier/Code/cdsat/src/theory.rs" 168 8 188 9
  
  let%span span29 = "/Users/xavier/Code/cdsat/src/theory.rs" 194 8 194 31
  
  let%span span30 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 16 8 16 26
  
  let%span span31 = "/Users/xavier/Code/cdsat/src/theory.rs" 200 8 200 71
  
  let%span span32 = "/Users/xavier/Code/cdsat/src/theory.rs" 142 8 147 9
  
  let%span span33 = "/Users/xavier/Code/cdsat/src/theory.rs" 417 4 417 87
  
  let%span span34 = "/Users/xavier/Code/cdsat/src/theory.rs" 419 8 422 9
  
  let%span span35 = "/Users/xavier/Code/cdsat/src/theory.rs" 262 8 265 9
  
  let%span span36 = "/Users/xavier/Code/cdsat/src/theory.rs" 619 15 619 27
  
  let%span span37 = "/Users/xavier/Code/cdsat/src/theory.rs" 620 15 620 32
  
  let%span span38 = "/Users/xavier/Code/cdsat/src/theory.rs" 621 4 621 90
  
  let%span span39 = "/Users/xavier/Code/cdsat/src/theory.rs" 623 8 632 9
  
  let%span span40 = "/Users/xavier/Code/cdsat/src/theory.rs" 514 8 517 9
  
  let%span span41 = "/Users/xavier/Code/cdsat/src/theory.rs" 524 8 527 9
  
  let%span span42 = "/Users/xavier/Code/cdsat/src/theory.rs" 206 8 206 84
  
  let%span span43 = "/Users/xavier/Code/cdsat/src/theory.rs" 504 8 507 9
  
  let%span span44 = "/Users/xavier/Code/cdsat/src/theory.rs" 82 8 82 36
  
  let%span span45 = "/Users/xavier/Code/cdsat/src/theory.rs" 96 15 96 29
  
  let%span span46 = "/Users/xavier/Code/cdsat/src/theory.rs" 97 14 97 30
  
  let%span span47 = "/Users/xavier/Code/cdsat/src/theory.rs" 99 8 102 9
  
  let%span span48 = "/Users/xavier/Code/cdsat/src/theory.rs" 374 8 382 9
  
  let%span span49 = "/Users/xavier/Code/cdsat/src/theory.rs" 355 8 368 9
  
  let%span span50 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 53 8 53 26
  
  let%span span51 = "/Users/xavier/Code/cdsat/src/theory.rs" 406 15 406 38
  
  let%span span52 = "/Users/xavier/Code/cdsat/src/theory.rs" 407 14 407 51
  
  let%span span53 = "/Users/xavier/Code/cdsat/src/theory.rs" 409 8 412 9
  
  let%span span54 = "/Users/xavier/Code/cdsat/src/theory.rs" 281 15 281 38
  
  let%span span55 = "/Users/xavier/Code/cdsat/src/theory.rs" 282 4 282 74
  
  let%span span56 = "/Users/xavier/Code/cdsat/src/theory.rs" 283 4 283 94
  
  let%span span57 = "/Users/xavier/Code/cdsat/src/theory.rs" 284 4 284 48
  
  let%span span58 = "/Users/xavier/Code/cdsat/src/theory.rs" 285 14 285 25
  
  let%span span59 = "/Users/xavier/Code/cdsat/src/theory.rs" 286 14 286 36
  
  let%span span60 = "/Users/xavier/Code/cdsat/src/theory.rs" 280 14 280 21
  
  let%span span61 = "/Users/xavier/Code/cdsat/src/theory.rs" 278 4 278 12
  
  let%span span62 = "/Users/xavier/Code/cdsat/src/theory.rs" 321 8 331 9
  
  let%span span63 = "/Users/xavier/Code/cdsat/src/theory.rs" 388 8 392 38
  
  let%span span64 = "/Users/xavier/Code/cdsat/src/theory.rs" 486 15 486 31
  
  let%span span65 = "/Users/xavier/Code/cdsat/src/theory.rs" 487 15 487 35
  
  let%span span66 = "/Users/xavier/Code/cdsat/src/theory.rs" 488 15 488 27
  
  let%span span67 = "/Users/xavier/Code/cdsat/src/theory.rs" 489 4 489 54
  
  let%span span68 = "/Users/xavier/Code/cdsat/src/theory.rs" 490 4 490 58
  
  let%span span69 = "/Users/xavier/Code/cdsat/src/theory.rs" 491 4 491 61
  
  let%span span70 = "/Users/xavier/Code/cdsat/src/theory.rs" 493 8 493 30
  
  let%span span71 = "/Users/xavier/Code/cdsat/src/theory.rs" 678 8 678 71
  
  let%span span72 = "/Users/xavier/Code/cdsat/src/theory.rs" 741 15 741 31
  
  let%span span73 = "/Users/xavier/Code/cdsat/src/theory.rs" 742 4 742 83
  
  let%span span74 = "/Users/xavier/Code/cdsat/src/theory.rs" 744 8 749 9
  
  let%span span75 = "/Users/xavier/Code/cdsat/src/theory.rs" 562 8 573 9
  
  let%span span76 = "/Users/xavier/Code/cdsat/src/theory.rs" 685 8 685 82
  
  let%span span77 = "/Users/xavier/Code/cdsat/src/theory.rs" 696 4 696 55
  
  let%span span78 = "/Users/xavier/Code/cdsat/src/theory.rs" 698 8 698 108
  
  let%span span79 = "/Users/xavier/Code/cdsat/src/theory.rs" 398 8 400 79
  
  let%span span80 = "/Users/xavier/Code/cdsat/src/theory.rs" 826 4 826 16
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  use Cdsat_Theory_Value_Type as Value'0
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span12] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  use map.Map
  
  use Cdsat_Theory_Model_Type as Cdsat_Theory_Model_Type
  
  use Cdsat_Theory_Var_Type as Var'0
  
  use Cdsat_Theory_Model_Type as Model'0
  
  predicate invariant'2 [#"/Users/xavier/Code/cdsat/src/theory.rs" 156 4 156 30] (self : Model'0.t_model) =
    [%#span13] forall v : Value'0.t_value . forall k : Var'0.t_var . Map.get (Cdsat_Theory_Model_Type.model_0 self) k
    = v  -> Cdsat_Theory_Var_Type.var_1 k = sort'1 v
  
  predicate inv'0 (_x : Model'0.t_model)
  
  axiom inv'0 : forall x : Model'0.t_model . inv'0 x
  = (invariant'2 x
  /\ match x with
    | Model'0.C_Model a_0 -> true
    end)
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  use prelude.prelude.Int
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span15] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span14] len'0 self >= 0
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  function level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int =
    [%#span16] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> 1 + level'0 tl
      | Trail'0.C_Assign _ _ tl -> level'0 tl
      end
  
  axiom level'0_spec : forall self : Trail'0.t_trail . ([%#stheory11] level'0 self <= len'0 self)
  && ([%#stheory10] level'0 self >= 0)
  
  use Cdsat_Theory_Normal_Type as Normal'0
  
  use prelude.prelude.Int
  
  use Cdsat_Theory_Term_Type as Term'0
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span17] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'1 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  predicate invariant'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 121 4 121 34] (self : Assign'0.t_assign) =
    [%#span18] match self with
      | Assign'0.C_Decision t v -> sort'0 t = sort'1 v
      | Assign'0.C_Justified _ t v -> sort'0 t = sort'1 v /\ sort'0 t = Sort'0.C_Boolean
      | Assign'0.C_Input t v -> sort'0 t = sort'1 v
      end
  
  predicate invariant_assign'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 345 4 345 41] (self : Trail'0.t_trail) =
    [%#span19] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_assign'0 tl /\ invariant'1 a
      end
  
  predicate invariant_nonneg'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 336 4 336 41] (self : Trail'0.t_trail) =
    [%#span20] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_nonneg'0 tl /\ l >= 0 /\ l <= level'0 self
      end
  
  function to_pair'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 131 4 131 41] (self : Assign'0.t_assign) : (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span21] match self with
      | Assign'0.C_Decision t val' -> (t, val')
      | Assign'0.C_Input t val' -> (t, val')
      | Assign'0.C_Justified _ t val' -> (t, val')
      end
  
  use Core_Option_Option_Type as Option'0
  
  function find'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 471 4 471 64] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Option'0.t_option (Assign'0.t_assign, int)
    
   =
    [%#span25] match self with
      | Trail'0.C_Empty -> Option'0.C_None
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then Option'0.C_Some (a, l) else find'0 tl d
      end
  
  axiom find'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span24] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)))
  && ([%#span23] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
  && ([%#span22] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
  
  use set.Fset
  
  use prelude.prelude.Real
  
  function from_int'0 (_1 : int) : Real.real
  
  function interp'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 167 4 167 41] (self : Model'0.t_model) (t : Term'0.t_term) : Value'0.t_value
    
   =
    [%#span28] match t with
      | Term'0.C_Variable v -> Map.get (Cdsat_Theory_Model_Type.model_0 self) v
      | Term'0.C_Value v -> v
      | Term'0.C_Plus l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Rat r1, Value'0.C_Rat r2) -> Value'0.C_Rat r1
        | _ -> Value'0.C_Rat (from_int'0 (- 1))
        end
      | Term'0.C_Conj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 /\ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Disj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 \/ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Eq l r -> Value'0.C_Bool (interp'0 self l = interp'0 self r)
      | Term'0.C_Neg t -> match interp'0 self t with
        | Value'0.C_Bool b -> Value'0.C_Bool (not b)
        | _ -> Value'0.C_Bool false
        end
      end
  
  axiom interp'0_spec : forall self : Model'0.t_model, t : Term'0.t_term . ([%#span26] inv'0 self)
   -> ([%#span27] invariant'2 self  -> sort'1 (interp'0 self t) = sort'0 t)
  
  predicate satisfies'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 193 4 193 52] (self : Model'0.t_model) (v : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span29] interp'0 self (let (a, _) = v in a) = (let (_, a) = v in a)
  
  use set.Fset
  
  predicate contains'1 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (e : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span30] Fset.mem e self
  
  predicate satisfy_set'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 199 4 199 60] (self : Model'0.t_model) (v : Fset.fset (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span31] forall a : (Term'0.t_term, Value'0.t_value) . contains'1 v a  -> satisfies'0 self a
  
  predicate justified_sound'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 141 4 141 40] (self : Assign'0.t_assign) =
    [%#span32] match self with
      | Assign'0.C_Justified just t val' -> forall m : Model'0.t_model . inv'0 m
       -> satisfy_set'0 m just  -> satisfies'0 m (t, val')
      | _ -> true
      end
  
  predicate contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 418 4 418 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span34] match find'0 self d with
      | Option'0.C_Some ix -> true
      | Option'0.C_None -> false
      end
  
  axiom contains'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . [%#span33] invariant_assign'0 self
   -> contains'0 self d = true  -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)
  
  predicate sound'1 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 261 4 261 30] (self : Trail'0.t_trail)
   =
    [%#span35] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a _ tl -> sound'1 tl /\ justified_sound'0 a
      end
  
  function find_justified'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 622 4 622 46] (self : Trail'0.t_trail) (kv : (Term'0.t_term, Value'0.t_value)) : ()
    
   =
    [%#span39] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = kv then () else find_justified'0 tl kv
      end
  
  axiom find_justified'0_spec : forall self : Trail'0.t_trail, kv : (Term'0.t_term, Value'0.t_value) . ([%#span36] sound'1 self)
   -> ([%#span37] contains'0 self kv)
   -> ([%#span38] forall l : int . forall a : Assign'0.t_assign . find'0 self kv = Option'0.C_Some (a, l)
   -> justified_sound'0 a)
  
  predicate is_decision'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 513 4 513 54] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span40] match find'0 self d with
      | Option'0.C_Some (Assign'0.C_Decision _ _, _) -> true
      | _ -> false
      end
  
  use set.Fset
  
  predicate is_input'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 523 4 523 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span41] match find'0 self d with
      | Option'0.C_Some (Assign'0.C_Input _ _, _) -> true
      | _ -> false
      end
  
  predicate entails'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 205 4 205 74] (self : Model'0.t_model) (j : Fset.fset (Term'0.t_term, Value'0.t_value)) (c : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span42] invariant'2 self  -> satisfy_set'0 self j  -> satisfies'0 self c
  
  predicate is_justified'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 503 4 503 55] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span43] match find'0 self d with
      | Option'0.C_Some (Assign'0.C_Justified _ _ _, _) -> true
      | _ -> false
      end
  
  predicate is_bool'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 81 4 81 32] (self : Value'0.t_value) =
    [%#span44] sort'1 self = Sort'0.C_Boolean
  
  function negate'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 98 4 98 31] (self : Value'0.t_value) : Value'0.t_value =
    [%#span47] match self with
      | Value'0.C_Bool b -> Value'0.C_Bool (not b)
      | _ -> self
      end
  
  axiom negate'0_spec : forall self : Value'0.t_value . ([%#span45] is_bool'0 self)
   -> ([%#span46] is_bool'0 (negate'0 self))
  
  predicate trail_unique'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 373 4 373 37] (self : Trail'0.t_trail) =
    [%#span48] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> let ap = to_pair'0 a in not contains'0 tl ap
      /\ trail_unique'0 tl
      /\ (if is_bool'0 (let (_, a) = ap in a) then
        not contains'0 tl ((let (a, _) = ap in a), negate'0 (let (_, a) = ap in a))
      else
        true
      )
      end
  
  predicate invariant_contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 354 4 354 43] (self : Trail'0.t_trail) =
    [%#span49] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_contains'0 tl
      /\ match a with
        | Assign'0.C_Justified j _ _ -> forall a : (Term'0.t_term, Value'0.t_value) . contains'1 j a  -> contains'0 tl a
        | _ -> true
        end
      end
  
  use set.Fset
  
  function remove'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (a : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span50] Fset.remove a self
  
  use set.Fset
  
  use set.Fset
  
  function level_of'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 408 4 408 50] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : int
    
   =
    [%#span53] match find'0 self d with
      | Option'0.C_Some (_, l) -> l
      | Option'0.C_None -> 0
      end
  
  axiom level_of'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span51] invariant_nonneg'0 self)
   -> ([%#span52] level_of'0 self d >= 0 /\ level_of'0 self d <= level'0 self)
  
  function set_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 287 4 287 57] (self : Trail'0.t_trail) (s : Fset.fset (Term'0.t_term, Value'0.t_value)) : int
    
  
  axiom set_level'0_def : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . set_level'0 self s
  = ([%#span61] if Fset.cardinal s = 0 then
    0
  else
    if Fset.cardinal s = 1 then
      level_of'0 self (Fset.pick s)
    else
      let a = Fset.pick s in let rec' = set_level'0 self (remove'0 s a) in if level_of'0 self a >= rec' then
        level_of'0 self a
      else
        rec'
      
    
  )
  
  axiom set_level'0_spec : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . ([%#span54] invariant_nonneg'0 self)
   -> ([%#span59] set_level'0 self s <= level'0 self)
  && ([%#span58] set_level'0 self s >= 0)
  && ([%#span57] s = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))  -> set_level'0 self s = 0)
  && ([%#span56] s <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
   -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'1 s i /\ level_of'0 self i = set_level'0 self s))
  && ([%#span55] forall i : (Term'0.t_term, Value'0.t_value) . contains'1 s i
   -> level_of'0 self i <= set_level'0 self s)
  
  predicate invariant_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 320 4 320 40] (self : Trail'0.t_trail) =
    [%#span62] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_level'0 tl
      /\ match a with
        | Assign'0.C_Input _ _ -> l = 0
        | Assign'0.C_Decision _ _ -> level'0 tl + 1 = l
        | Assign'0.C_Justified j _ _ -> set_level'0 tl j = l
        end
      end
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 387 4 387 34] (self : Trail'0.t_trail) =
    [%#span63] invariant_level'0 self
    /\ invariant_contains'0 self /\ trail_unique'0 self /\ invariant_nonneg'0 self /\ invariant_assign'0 self
  
  function justification'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 492 4 492 71] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span70] let _ = find_justified'0 self d in match find'0 self d with
      | Option'0.C_Some (Assign'0.C_Justified j _ _, _) -> j
      | _ -> Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value)
      end
  
  axiom justification'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span64] invariant'0 self)
   -> ([%#span65] is_justified'0 self d)
   -> ([%#span66] sound'1 self)
   -> ([%#span69] is_decision'0 self d
   -> justification'0 self d = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value)))
  && ([%#span68] is_input'0 self d
   -> justification'0 self d = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value)))
  && ([%#span67] forall m : Model'0.t_model . inv'0 m  -> entails'0 m (justification'0 self d) d)
  
  predicate satisfied_by'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 677 4 677 47] (self : Trail'0.t_trail) (m : Model'0.t_model)
    
   =
    [%#span71] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 self a  -> satisfies'0 m a
  
  function count_bounds'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 743 4 743 35] (self : Trail'0.t_trail) : () =
    [%#span74] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign (Assign'0.C_Input _ _) _ tl -> count_bounds'0 tl
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> count_bounds'0 tl
      | Trail'0.C_Assign (Assign'0.C_Justified _ _ _) _ tl -> count_bounds'0 tl
      end
  
  axiom count_bounds'0_spec : forall self : Trail'0.t_trail . ([%#span72] invariant'0 self)
   -> ([%#span73] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 self a  -> level_of'0 self a <= level'0 self)
  
  function restrict'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 561 4 561 45] (self : Trail'0.t_trail) (level : int) : Trail'0.t_trail
    
   =
    [%#span75] match self with
      | Trail'0.C_Empty -> Trail'0.C_Empty
      | Trail'0.C_Assign a l tl -> let tl = restrict'0 tl level in let _ = count_bounds'0 tl in if l <= level then
        Trail'0.C_Assign a l tl
      else
        tl
      
      end
  
  predicate unsat'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 684 4 684 30] (self : Trail'0.t_trail) =
    [%#span76] forall m : Model'0.t_model . inv'0 m  -> satisfied_by'0 (restrict'0 self 0) m  -> false
  
  predicate impls'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 697 4 697 41] (self : Trail'0.t_trail) (rhs : Trail'0.t_trail)
    
   =
    [%#span78] forall m : Model'0.t_model . inv'0 m
     -> satisfied_by'0 (restrict'0 self 0) m  -> satisfied_by'0 (restrict'0 rhs 0) m
  
  axiom impls'0_spec : forall self : Trail'0.t_trail, rhs : Trail'0.t_trail . [%#span77] impls'0 self rhs
   -> unsat'0 rhs  -> unsat'0 self
  
  predicate acceptable'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 397 4 397 56] (self : Trail'0.t_trail) (t : Term'0.t_term) (val' : Value'0.t_value)
    
   =
    [%#span79] not contains'0 self (t, val')
    /\ sort'0 t = sort'1 val' /\ (is_bool'0 val'  -> not contains'0 self (t, negate'0 val'))
  
  use Cdsat_Theory_Normal_Type as Cdsat_Theory_Normal_Type
  
  predicate sound'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 829 4 829 30] (self : Normal'0.t_normal)
    
   =
    [%#span80] sound'1 (Cdsat_Theory_Normal_Type.normal_0 self)
  
  constant self  : Normal'0.t_normal
  
  constant t  : Term'0.t_term
  
  constant val'  : Value'0.t_value
  
  function decidef [#"/Users/xavier/Code/cdsat/src/theory.rs" 860 4 860 54] (self : Normal'0.t_normal) (t : Term'0.t_term) (val' : Value'0.t_value) : Normal'0.t_normal
    
  
  goal vc_decidef : ([%#stheory2] acceptable'0 (Cdsat_Theory_Normal_Type.normal_0 self) t val')
   -> ([%#stheory1] sound'0 self)
   -> ([%#stheory0] invariant'0 (Cdsat_Theory_Normal_Type.normal_0 self))
   -> ([%#stheory11] level'0 (Cdsat_Theory_Normal_Type.normal_0 self) <= len'0 (Cdsat_Theory_Normal_Type.normal_0 self))
  && ([%#stheory10] level'0 (Cdsat_Theory_Normal_Type.normal_0 self) >= 0)
   -> (let result = Normal'0.C_Normal (Trail'0.C_Assign (Assign'0.C_Decision t val') (level'0 (Cdsat_Theory_Normal_Type.normal_0 self)
  + 1) (Cdsat_Theory_Normal_Type.normal_0 self)) in ([%#stheory9] forall a : (Term'0.t_term, Value'0.t_value) . justification'0 (Cdsat_Theory_Normal_Type.normal_0 self) a
  = justification'0 (Cdsat_Theory_Normal_Type.normal_0 result) a)
  && ([%#stheory8] contains'0 (Cdsat_Theory_Normal_Type.normal_0 result) (t, val'))
  && ([%#stheory7] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 (Cdsat_Theory_Normal_Type.normal_0 self) a
   -> contains'0 (Cdsat_Theory_Normal_Type.normal_0 result) a)
  && ([%#stheory6] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 (Cdsat_Theory_Normal_Type.normal_0 result) a
   -> contains'0 (Cdsat_Theory_Normal_Type.normal_0 self) a \/ a = (t, val'))
  && ([%#stheory5] impls'0 (Cdsat_Theory_Normal_Type.normal_0 self) (Cdsat_Theory_Normal_Type.normal_0 result))
  && ([%#stheory4] sound'0 result) && ([%#stheory3] invariant'0 (Cdsat_Theory_Normal_Type.normal_0 result)))
end
module Cdsat_Theory_Impl5_ContainsInverse_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 427 15 427 34
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 428 15 428 31
  
  let%span stheory2 = "/Users/xavier/Code/cdsat/src/theory.rs" 429 4 429 30
  
  let%span stheory3 = "/Users/xavier/Code/cdsat/src/theory.rs" 430 14 430 49
  
  let%span stheory4 = "/Users/xavier/Code/cdsat/src/theory.rs" 107 15 107 29
  
  let%span stheory5 = "/Users/xavier/Code/cdsat/src/theory.rs" 108 14 108 44
  
  let%span span6 = "/Users/xavier/Code/cdsat/src/theory.rs" 132 8 136 9
  
  let%span span7 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span8 = "/Users/xavier/Code/cdsat/src/theory.rs" 82 8 82 36
  
  let%span span9 = "/Users/xavier/Code/cdsat/src/theory.rs" 96 15 96 29
  
  let%span span10 = "/Users/xavier/Code/cdsat/src/theory.rs" 97 14 97 30
  
  let%span span11 = "/Users/xavier/Code/cdsat/src/theory.rs" 99 8 102 9
  
  let%span span12 = "/Users/xavier/Code/cdsat/src/theory.rs" 105 4 105 12
  
  let%span span13 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span14 = "/Users/xavier/Code/cdsat/src/theory.rs" 122 8 126 9
  
  let%span span15 = "/Users/xavier/Code/cdsat/src/theory.rs" 346 8 349 9
  
  let%span span16 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span17 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  let%span span18 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span span19 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span20 = "/Users/xavier/Code/cdsat/src/theory.rs" 601 8 605 9
  
  let%span span21 = "/Users/xavier/Code/cdsat/src/theory.rs" 337 8 340 9
  
  let%span span22 = "/Users/xavier/Code/cdsat/src/theory.rs" 465 14 468 5
  
  let%span span23 = "/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 111
  
  let%span span24 = "/Users/xavier/Code/cdsat/src/theory.rs" 470 4 470 104
  
  let%span span25 = "/Users/xavier/Code/cdsat/src/theory.rs" 472 8 481 9
  
  let%span span26 = "/Users/xavier/Code/cdsat/src/theory.rs" 417 4 417 87
  
  let%span span27 = "/Users/xavier/Code/cdsat/src/theory.rs" 419 8 422 9
  
  let%span span28 = "/Users/xavier/Code/cdsat/src/theory.rs" 374 8 382 9
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  use Cdsat_Theory_Value_Type as Value'0
  
  use Cdsat_Theory_Term_Type as Term'0
  
  function to_pair'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 131 4 131 41] (self : Assign'0.t_assign) : (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span6] match self with
      | Assign'0.C_Decision t val' -> (t, val')
      | Assign'0.C_Input t val' -> (t, val')
      | Assign'0.C_Justified _ t val' -> (t, val')
      end
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span7] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  predicate is_bool'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 81 4 81 32] (self : Value'0.t_value) =
    [%#span8] sort'1 self = Sort'0.C_Boolean
  
  function negate'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 98 4 98 31] (self : Value'0.t_value) : Value'0.t_value =
    [%#span11] match self with
      | Value'0.C_Bool b -> Value'0.C_Bool (not b)
      | _ -> self
      end
  
  axiom negate'0_spec : forall self : Value'0.t_value . ([%#span9] is_bool'0 self)
   -> ([%#span10] is_bool'0 (negate'0 self))
  
  function negate_involutive'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 109 4 109 34] (self : Value'0.t_value) : () =
    [%#span12] ()
  
  axiom negate_involutive'0_spec : forall self : Value'0.t_value . ([%#stheory4] is_bool'0 self)
   -> ([%#stheory5] negate'0 (negate'0 self) = self)
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  use prelude.prelude.Int
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span13] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'1 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 121 4 121 34] (self : Assign'0.t_assign) =
    [%#span14] match self with
      | Assign'0.C_Decision t v -> sort'0 t = sort'1 v
      | Assign'0.C_Justified _ t v -> sort'0 t = sort'1 v /\ sort'0 t = Sort'0.C_Boolean
      | Assign'0.C_Input t v -> sort'0 t = sort'1 v
      end
  
  predicate invariant_assign'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 345 4 345 41] (self : Trail'0.t_trail) =
    [%#span15] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_assign'0 tl /\ invariant'0 a
      end
  
  use prelude.prelude.Int
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span17] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span16] len'0 self >= 0
  
  function level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int =
    [%#span20] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> 1 + level'0 tl
      | Trail'0.C_Assign _ _ tl -> level'0 tl
      end
  
  axiom level'0_spec : forall self : Trail'0.t_trail . ([%#span19] level'0 self <= len'0 self)
  && ([%#span18] level'0 self >= 0)
  
  predicate invariant_nonneg'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 336 4 336 41] (self : Trail'0.t_trail) =
    [%#span21] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_nonneg'0 tl /\ l >= 0 /\ l <= level'0 self
      end
  
  use Core_Option_Option_Type as Option'0
  
  function find'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 471 4 471 64] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Option'0.t_option (Assign'0.t_assign, int)
    
   =
    [%#span25] match self with
      | Trail'0.C_Empty -> Option'0.C_None
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then Option'0.C_Some (a, l) else find'0 tl d
      end
  
  axiom find'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span24] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)))
  && ([%#span23] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
  && ([%#span22] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
  
  predicate contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 418 4 418 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span27] match find'0 self d with
      | Option'0.C_Some ix -> true
      | Option'0.C_None -> false
      end
  
  axiom contains'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . [%#span26] invariant_assign'0 self
   -> contains'0 self d = true  -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)
  
  predicate trail_unique'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 373 4 373 37] (self : Trail'0.t_trail) =
    [%#span28] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> let ap = to_pair'0 a in not contains'0 tl ap
      /\ trail_unique'0 tl
      /\ (if is_bool'0 (let (_, a) = ap in a) then
        not contains'0 tl ((let (a, _) = ap in a), negate'0 (let (_, a) = ap in a))
      else
        true
      )
      end
  
  constant self  : Trail'0.t_trail
  
  constant d  : (Term'0.t_term, Value'0.t_value)
  
  function contains_inverse [#"/Users/xavier/Code/cdsat/src/theory.rs" 431 4 431 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : ()
    
  
  goal vc_contains_inverse : ([%#stheory2] is_bool'0 (let (_, a) = d in a))
   -> ([%#stheory1] contains'0 self d)
   -> ([%#stheory0] trail_unique'0 self)
   -> ([%#stheory4] is_bool'0 (let (_, a) = d in a))
  /\ (([%#stheory5] negate'0 (negate'0 (let (_, a) = d in a)) = (let (_, a) = d in a))
   -> (let _ = negate_involutive'0 (let (_, a) = d in a) in match self with
    | Trail'0.C_Empty -> [%#stheory3] not contains'0 self ((let (a, _) = d in a), negate'0 (let (_, a) = d in a))
    | Trail'0.C_Assign a l tl -> match to_pair'0 a = d with
      | True -> [%#stheory3] not contains'0 self ((let (a, _) = d in a), negate'0 (let (_, a) = d in a))
      | False -> (([%#stheory2] is_bool'0 (let (_, a) = d in a))
      && ([%#stheory1] contains'0 tl d) && ([%#stheory0] trail_unique'0 tl))
      /\ (([%#stheory3] not contains'0 tl ((let (a, _) = d in a), negate'0 (let (_, a) = d in a)))
       -> ([%#stheory3] not contains'0 self ((let (a, _) = d in a), negate'0 (let (_, a) = d in a))))
      end
    end))
end
module Cdsat_Theory_Impl5_RestrictTooBig_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 754 15 754 25
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 755 15 755 31
  
  let%span stheory2 = "/Users/xavier/Code/cdsat/src/theory.rs" 756 15 756 31
  
  let%span stheory3 = "/Users/xavier/Code/cdsat/src/theory.rs" 757 15 757 39
  
  let%span stheory4 = "/Users/xavier/Code/cdsat/src/theory.rs" 758 14 758 47
  
  let%span span5 = "/Users/xavier/Code/cdsat/src/theory.rs" 132 8 136 9
  
  let%span span6 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span7 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  let%span span8 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span span9 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span10 = "/Users/xavier/Code/cdsat/src/theory.rs" 601 8 605 9
  
  let%span span11 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span12 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span13 = "/Users/xavier/Code/cdsat/src/theory.rs" 122 8 126 9
  
  let%span span14 = "/Users/xavier/Code/cdsat/src/theory.rs" 346 8 349 9
  
  let%span span15 = "/Users/xavier/Code/cdsat/src/theory.rs" 337 8 340 9
  
  let%span span16 = "/Users/xavier/Code/cdsat/src/theory.rs" 465 14 468 5
  
  let%span span17 = "/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 111
  
  let%span span18 = "/Users/xavier/Code/cdsat/src/theory.rs" 470 4 470 104
  
  let%span span19 = "/Users/xavier/Code/cdsat/src/theory.rs" 472 8 481 9
  
  let%span span20 = "/Users/xavier/Code/cdsat/src/theory.rs" 406 15 406 38
  
  let%span span21 = "/Users/xavier/Code/cdsat/src/theory.rs" 407 14 407 51
  
  let%span span22 = "/Users/xavier/Code/cdsat/src/theory.rs" 409 8 412 9
  
  let%span span23 = "/Users/xavier/Code/cdsat/src/theory.rs" 417 4 417 87
  
  let%span span24 = "/Users/xavier/Code/cdsat/src/theory.rs" 419 8 422 9
  
  let%span span25 = "/Users/xavier/Code/cdsat/src/theory.rs" 82 8 82 36
  
  let%span span26 = "/Users/xavier/Code/cdsat/src/theory.rs" 96 15 96 29
  
  let%span span27 = "/Users/xavier/Code/cdsat/src/theory.rs" 97 14 97 30
  
  let%span span28 = "/Users/xavier/Code/cdsat/src/theory.rs" 99 8 102 9
  
  let%span span29 = "/Users/xavier/Code/cdsat/src/theory.rs" 374 8 382 9
  
  let%span span30 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 16 8 16 26
  
  let%span span31 = "/Users/xavier/Code/cdsat/src/theory.rs" 355 8 368 9
  
  let%span span32 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 53 8 53 26
  
  let%span span33 = "/Users/xavier/Code/cdsat/src/theory.rs" 281 15 281 38
  
  let%span span34 = "/Users/xavier/Code/cdsat/src/theory.rs" 282 4 282 74
  
  let%span span35 = "/Users/xavier/Code/cdsat/src/theory.rs" 283 4 283 94
  
  let%span span36 = "/Users/xavier/Code/cdsat/src/theory.rs" 284 4 284 48
  
  let%span span37 = "/Users/xavier/Code/cdsat/src/theory.rs" 285 14 285 25
  
  let%span span38 = "/Users/xavier/Code/cdsat/src/theory.rs" 286 14 286 36
  
  let%span span39 = "/Users/xavier/Code/cdsat/src/theory.rs" 280 14 280 21
  
  let%span span40 = "/Users/xavier/Code/cdsat/src/theory.rs" 278 4 278 12
  
  let%span span41 = "/Users/xavier/Code/cdsat/src/theory.rs" 321 8 331 9
  
  let%span span42 = "/Users/xavier/Code/cdsat/src/theory.rs" 388 8 392 38
  
  let%span span43 = "/Users/xavier/Code/cdsat/src/theory.rs" 741 15 741 31
  
  let%span span44 = "/Users/xavier/Code/cdsat/src/theory.rs" 742 4 742 83
  
  let%span span45 = "/Users/xavier/Code/cdsat/src/theory.rs" 744 8 749 9
  
  let%span span46 = "/Users/xavier/Code/cdsat/src/theory.rs" 562 8 573 9
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  use Cdsat_Theory_Value_Type as Value'0
  
  use Cdsat_Theory_Term_Type as Term'0
  
  function to_pair'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 131 4 131 41] (self : Assign'0.t_assign) : (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span5] match self with
      | Assign'0.C_Decision t val' -> (t, val')
      | Assign'0.C_Input t val' -> (t, val')
      | Assign'0.C_Justified _ t val' -> (t, val')
      end
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  use prelude.prelude.Int
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span7] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span6] len'0 self >= 0
  
  function level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int =
    [%#span10] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> 1 + level'0 tl
      | Trail'0.C_Assign _ _ tl -> level'0 tl
      end
  
  axiom level'0_spec : forall self : Trail'0.t_trail . ([%#span9] level'0 self <= len'0 self)
  && ([%#span8] level'0 self >= 0)
  
  use prelude.prelude.Int
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span11] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span12] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'1 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  predicate invariant'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 121 4 121 34] (self : Assign'0.t_assign) =
    [%#span13] match self with
      | Assign'0.C_Decision t v -> sort'0 t = sort'1 v
      | Assign'0.C_Justified _ t v -> sort'0 t = sort'1 v /\ sort'0 t = Sort'0.C_Boolean
      | Assign'0.C_Input t v -> sort'0 t = sort'1 v
      end
  
  predicate invariant_assign'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 345 4 345 41] (self : Trail'0.t_trail) =
    [%#span14] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_assign'0 tl /\ invariant'1 a
      end
  
  predicate invariant_nonneg'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 336 4 336 41] (self : Trail'0.t_trail) =
    [%#span15] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_nonneg'0 tl /\ l >= 0 /\ l <= level'0 self
      end
  
  use Core_Option_Option_Type as Option'0
  
  function find'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 471 4 471 64] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Option'0.t_option (Assign'0.t_assign, int)
    
   =
    [%#span19] match self with
      | Trail'0.C_Empty -> Option'0.C_None
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then Option'0.C_Some (a, l) else find'0 tl d
      end
  
  axiom find'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span18] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)))
  && ([%#span17] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
  && ([%#span16] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
  
  function level_of'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 408 4 408 50] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : int
    
   =
    [%#span22] match find'0 self d with
      | Option'0.C_Some (_, l) -> l
      | Option'0.C_None -> 0
      end
  
  axiom level_of'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span20] invariant_nonneg'0 self)
   -> ([%#span21] level_of'0 self d >= 0 /\ level_of'0 self d <= level'0 self)
  
  predicate contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 418 4 418 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span24] match find'0 self d with
      | Option'0.C_Some ix -> true
      | Option'0.C_None -> false
      end
  
  axiom contains'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . [%#span23] invariant_assign'0 self
   -> contains'0 self d = true  -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)
  
  predicate is_bool'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 81 4 81 32] (self : Value'0.t_value) =
    [%#span25] sort'1 self = Sort'0.C_Boolean
  
  function negate'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 98 4 98 31] (self : Value'0.t_value) : Value'0.t_value =
    [%#span28] match self with
      | Value'0.C_Bool b -> Value'0.C_Bool (not b)
      | _ -> self
      end
  
  axiom negate'0_spec : forall self : Value'0.t_value . ([%#span26] is_bool'0 self)
   -> ([%#span27] is_bool'0 (negate'0 self))
  
  predicate trail_unique'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 373 4 373 37] (self : Trail'0.t_trail) =
    [%#span29] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> let ap = to_pair'0 a in not contains'0 tl ap
      /\ trail_unique'0 tl
      /\ (if is_bool'0 (let (_, a) = ap in a) then
        not contains'0 tl ((let (a, _) = ap in a), negate'0 (let (_, a) = ap in a))
      else
        true
      )
      end
  
  use set.Fset
  
  use set.Fset
  
  predicate contains'1 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (e : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span30] Fset.mem e self
  
  predicate invariant_contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 354 4 354 43] (self : Trail'0.t_trail) =
    [%#span31] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_contains'0 tl
      /\ match a with
        | Assign'0.C_Justified j _ _ -> forall a : (Term'0.t_term, Value'0.t_value) . contains'1 j a  -> contains'0 tl a
        | _ -> true
        end
      end
  
  use set.Fset
  
  function remove'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (a : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span32] Fset.remove a self
  
  use set.Fset
  
  use set.Fset
  
  use set.Fset
  
  function set_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 287 4 287 57] (self : Trail'0.t_trail) (s : Fset.fset (Term'0.t_term, Value'0.t_value)) : int
    
  
  axiom set_level'0_def : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . set_level'0 self s
  = ([%#span40] if Fset.cardinal s = 0 then
    0
  else
    if Fset.cardinal s = 1 then
      level_of'0 self (Fset.pick s)
    else
      let a = Fset.pick s in let rec' = set_level'0 self (remove'0 s a) in if level_of'0 self a >= rec' then
        level_of'0 self a
      else
        rec'
      
    
  )
  
  axiom set_level'0_spec : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . ([%#span33] invariant_nonneg'0 self)
   -> ([%#span38] set_level'0 self s <= level'0 self)
  && ([%#span37] set_level'0 self s >= 0)
  && ([%#span36] s = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))  -> set_level'0 self s = 0)
  && ([%#span35] s <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
   -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'1 s i /\ level_of'0 self i = set_level'0 self s))
  && ([%#span34] forall i : (Term'0.t_term, Value'0.t_value) . contains'1 s i
   -> level_of'0 self i <= set_level'0 self s)
  
  predicate invariant_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 320 4 320 40] (self : Trail'0.t_trail) =
    [%#span41] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_level'0 tl
      /\ match a with
        | Assign'0.C_Input _ _ -> l = 0
        | Assign'0.C_Decision _ _ -> level'0 tl + 1 = l
        | Assign'0.C_Justified j _ _ -> set_level'0 tl j = l
        end
      end
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 387 4 387 34] (self : Trail'0.t_trail) =
    [%#span42] invariant_level'0 self
    /\ invariant_contains'0 self /\ trail_unique'0 self /\ invariant_nonneg'0 self /\ invariant_assign'0 self
  
  function count_bounds'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 743 4 743 35] (self : Trail'0.t_trail) : () =
    [%#span45] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign (Assign'0.C_Input _ _) _ tl -> count_bounds'0 tl
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> count_bounds'0 tl
      | Trail'0.C_Assign (Assign'0.C_Justified _ _ _) _ tl -> count_bounds'0 tl
      end
  
  axiom count_bounds'0_spec : forall self : Trail'0.t_trail . ([%#span43] invariant'0 self)
   -> ([%#span44] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 self a  -> level_of'0 self a <= level'0 self)
  
  function restrict'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 561 4 561 45] (self : Trail'0.t_trail) (level : int) : Trail'0.t_trail
    
   =
    [%#span46] match self with
      | Trail'0.C_Empty -> Trail'0.C_Empty
      | Trail'0.C_Assign a l tl -> let tl = restrict'0 tl level in let _ = count_bounds'0 tl in if l <= level then
        Trail'0.C_Assign a l tl
      else
        tl
      
      end
  
  constant self  : Trail'0.t_trail
  
  constant level  : int
  
  constant d  : (Term'0.t_term, Value'0.t_value)
  
  function restrict_too_big [#"/Users/xavier/Code/cdsat/src/theory.rs" 759 4 759 63] (self : Trail'0.t_trail) (level : int) (d : (Term'0.t_term, Value'0.t_value)) : ()
    
  
  goal vc_restrict_too_big : ([%#stheory3] level < level_of'0 self d)
   -> ([%#stheory2] contains'0 self d)
   -> ([%#stheory1] invariant'0 self)
   -> ([%#stheory0] level >= 0)
   -> match self with
    | Trail'0.C_Empty -> [%#stheory4] not contains'0 (restrict'0 self level) d
    | Trail'0.C_Assign a l tl -> match to_pair'0 a = d with
      | True -> [%#stheory4] not contains'0 (restrict'0 self level) d
      | False -> (([%#stheory3] level < level_of'0 tl d)
      && ([%#stheory2] contains'0 tl d) && ([%#stheory1] invariant'0 tl) && ([%#stheory0] level >= 0))
      /\ (([%#stheory4] not contains'0 (restrict'0 tl level) d)
       -> (let _ = restrict_too_big tl level d in [%#stheory4] not contains'0 (restrict'0 self level) d))
      end
    end
end
module Cdsat_Theory_Impl6_Decide_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 836 15 836 35
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 837 15 837 27
  
  let%span stheory2 = "/Users/xavier/Code/cdsat/src/theory.rs" 838 4 838 46
  
  let%span stheory3 = "/Users/xavier/Code/cdsat/src/theory.rs" 839 4 839 38
  
  let%span stheory4 = "/Users/xavier/Code/cdsat/src/theory.rs" 840 4 840 46
  
  let%span stheory5 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span stheory6 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span7 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span8 = "/Users/xavier/Code/cdsat/src/theory.rs" 157 8 159 9
  
  let%span span9 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span10 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  let%span span11 = "/Users/xavier/Code/cdsat/src/theory.rs" 601 8 605 9
  
  let%span span12 = "/Users/xavier/Code/cdsat/src/theory.rs" 82 8 82 36
  
  let%span span13 = "/Users/xavier/Code/cdsat/src/theory.rs" 96 15 96 29
  
  let%span span14 = "/Users/xavier/Code/cdsat/src/theory.rs" 97 14 97 30
  
  let%span span15 = "/Users/xavier/Code/cdsat/src/theory.rs" 99 8 102 9
  
  let%span span16 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span17 = "/Users/xavier/Code/cdsat/src/theory.rs" 122 8 126 9
  
  let%span span18 = "/Users/xavier/Code/cdsat/src/theory.rs" 346 8 349 9
  
  let%span span19 = "/Users/xavier/Code/cdsat/src/theory.rs" 337 8 340 9
  
  let%span span20 = "/Users/xavier/Code/cdsat/src/theory.rs" 132 8 136 9
  
  let%span span21 = "/Users/xavier/Code/cdsat/src/theory.rs" 465 14 468 5
  
  let%span span22 = "/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 111
  
  let%span span23 = "/Users/xavier/Code/cdsat/src/theory.rs" 470 4 470 104
  
  let%span span24 = "/Users/xavier/Code/cdsat/src/theory.rs" 472 8 481 9
  
  let%span span25 = "/Users/xavier/Code/cdsat/src/theory.rs" 417 4 417 87
  
  let%span span26 = "/Users/xavier/Code/cdsat/src/theory.rs" 419 8 422 9
  
  let%span span27 = "/Users/xavier/Code/cdsat/src/theory.rs" 398 8 400 79
  
  let%span span28 = "/Users/xavier/Code/cdsat/src/theory.rs" 167 18 167 22
  
  let%span span29 = "/Users/xavier/Code/cdsat/src/theory.rs" 166 4 166 62
  
  let%span span30 = "/Users/xavier/Code/cdsat/src/theory.rs" 168 8 188 9
  
  let%span span31 = "/Users/xavier/Code/cdsat/src/theory.rs" 194 8 194 31
  
  let%span span32 = "/Users/xavier/Code/cdsat/src/theory.rs" 678 8 678 71
  
  let%span span33 = "/Users/xavier/Code/cdsat/src/theory.rs" 406 15 406 38
  
  let%span span34 = "/Users/xavier/Code/cdsat/src/theory.rs" 407 14 407 51
  
  let%span span35 = "/Users/xavier/Code/cdsat/src/theory.rs" 409 8 412 9
  
  let%span span36 = "/Users/xavier/Code/cdsat/src/theory.rs" 374 8 382 9
  
  let%span span37 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 16 8 16 26
  
  let%span span38 = "/Users/xavier/Code/cdsat/src/theory.rs" 355 8 368 9
  
  let%span span39 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 53 8 53 26
  
  let%span span40 = "/Users/xavier/Code/cdsat/src/theory.rs" 281 15 281 38
  
  let%span span41 = "/Users/xavier/Code/cdsat/src/theory.rs" 282 4 282 74
  
  let%span span42 = "/Users/xavier/Code/cdsat/src/theory.rs" 283 4 283 94
  
  let%span span43 = "/Users/xavier/Code/cdsat/src/theory.rs" 284 4 284 48
  
  let%span span44 = "/Users/xavier/Code/cdsat/src/theory.rs" 285 14 285 25
  
  let%span span45 = "/Users/xavier/Code/cdsat/src/theory.rs" 286 14 286 36
  
  let%span span46 = "/Users/xavier/Code/cdsat/src/theory.rs" 280 14 280 21
  
  let%span span47 = "/Users/xavier/Code/cdsat/src/theory.rs" 278 4 278 12
  
  let%span span48 = "/Users/xavier/Code/cdsat/src/theory.rs" 321 8 331 9
  
  let%span span49 = "/Users/xavier/Code/cdsat/src/theory.rs" 388 8 392 38
  
  let%span span50 = "/Users/xavier/Code/cdsat/src/theory.rs" 741 15 741 31
  
  let%span span51 = "/Users/xavier/Code/cdsat/src/theory.rs" 742 4 742 83
  
  let%span span52 = "/Users/xavier/Code/cdsat/src/theory.rs" 744 8 749 9
  
  let%span span53 = "/Users/xavier/Code/cdsat/src/theory.rs" 562 8 573 9
  
  let%span span54 = "/Users/xavier/Code/cdsat/src/theory.rs" 685 8 685 82
  
  let%span span55 = "/Users/xavier/Code/cdsat/src/theory.rs" 696 4 696 55
  
  let%span span56 = "/Users/xavier/Code/cdsat/src/theory.rs" 698 8 698 108
  
  let%span span57 = "/Users/xavier/Code/cdsat/src/theory.rs" 200 8 200 71
  
  let%span span58 = "/Users/xavier/Code/cdsat/src/theory.rs" 142 8 147 9
  
  let%span span59 = "/Users/xavier/Code/cdsat/src/theory.rs" 262 8 265 9
  
  let%span span60 = "/Users/xavier/Code/cdsat/src/theory.rs" 826 4 826 16
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  use Cdsat_Theory_Value_Type as Value'0
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span7] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  use map.Map
  
  use Cdsat_Theory_Model_Type as Cdsat_Theory_Model_Type
  
  use Cdsat_Theory_Var_Type as Var'0
  
  use Cdsat_Theory_Model_Type as Model'0
  
  predicate invariant'2 [#"/Users/xavier/Code/cdsat/src/theory.rs" 156 4 156 30] (self : Model'0.t_model) =
    [%#span8] forall v : Value'0.t_value . forall k : Var'0.t_var . Map.get (Cdsat_Theory_Model_Type.model_0 self) k = v
     -> Cdsat_Theory_Var_Type.var_1 k = sort'1 v
  
  predicate inv'0 (_x : Model'0.t_model)
  
  axiom inv'0 : forall x : Model'0.t_model . inv'0 x
  = (invariant'2 x
  /\ match x with
    | Model'0.C_Model a_0 -> true
    end)
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  use prelude.prelude.Int
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span10] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span9] len'0 self >= 0
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  function level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int =
    [%#span11] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> 1 + level'0 tl
      | Trail'0.C_Assign _ _ tl -> level'0 tl
      end
  
  axiom level'0_spec : forall self : Trail'0.t_trail . ([%#stheory6] level'0 self <= len'0 self)
  && ([%#stheory5] level'0 self >= 0)
  
  predicate is_bool'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 81 4 81 32] (self : Value'0.t_value) =
    [%#span12] sort'1 self = Sort'0.C_Boolean
  
  function negate'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 98 4 98 31] (self : Value'0.t_value) : Value'0.t_value =
    [%#span15] match self with
      | Value'0.C_Bool b -> Value'0.C_Bool (not b)
      | _ -> self
      end
  
  axiom negate'0_spec : forall self : Value'0.t_value . ([%#span13] is_bool'0 self)
   -> ([%#span14] is_bool'0 (negate'0 self))
  
  use Cdsat_Theory_Term_Type as Term'0
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span16] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'1 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  use prelude.prelude.Int
  
  predicate invariant'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 121 4 121 34] (self : Assign'0.t_assign) =
    [%#span17] match self with
      | Assign'0.C_Decision t v -> sort'0 t = sort'1 v
      | Assign'0.C_Justified _ t v -> sort'0 t = sort'1 v /\ sort'0 t = Sort'0.C_Boolean
      | Assign'0.C_Input t v -> sort'0 t = sort'1 v
      end
  
  predicate invariant_assign'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 345 4 345 41] (self : Trail'0.t_trail) =
    [%#span18] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_assign'0 tl /\ invariant'1 a
      end
  
  predicate invariant_nonneg'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 336 4 336 41] (self : Trail'0.t_trail) =
    [%#span19] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_nonneg'0 tl /\ l >= 0 /\ l <= level'0 self
      end
  
  function to_pair'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 131 4 131 41] (self : Assign'0.t_assign) : (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span20] match self with
      | Assign'0.C_Decision t val' -> (t, val')
      | Assign'0.C_Input t val' -> (t, val')
      | Assign'0.C_Justified _ t val' -> (t, val')
      end
  
  use Core_Option_Option_Type as Option'0
  
  function find'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 471 4 471 64] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Option'0.t_option (Assign'0.t_assign, int)
    
   =
    [%#span24] match self with
      | Trail'0.C_Empty -> Option'0.C_None
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then Option'0.C_Some (a, l) else find'0 tl d
      end
  
  axiom find'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span23] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)))
  && ([%#span22] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
  && ([%#span21] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
  
  predicate contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 418 4 418 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span26] match find'0 self d with
      | Option'0.C_Some ix -> true
      | Option'0.C_None -> false
      end
  
  axiom contains'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . [%#span25] invariant_assign'0 self
   -> contains'0 self d = true  -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)
  
  predicate acceptable'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 397 4 397 56] (self : Trail'0.t_trail) (t : Term'0.t_term) (val' : Value'0.t_value)
    
   =
    [%#span27] not contains'0 self (t, val')
    /\ sort'0 t = sort'1 val' /\ (is_bool'0 val'  -> not contains'0 self (t, negate'0 val'))
  
  use Cdsat_Theory_Normal_Type as Normal'0
  
  use prelude.prelude.Real
  
  function from_int'0 (_1 : int) : Real.real
  
  function interp'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 167 4 167 41] (self : Model'0.t_model) (t : Term'0.t_term) : Value'0.t_value
    
   =
    [%#span30] match t with
      | Term'0.C_Variable v -> Map.get (Cdsat_Theory_Model_Type.model_0 self) v
      | Term'0.C_Value v -> v
      | Term'0.C_Plus l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Rat r1, Value'0.C_Rat r2) -> Value'0.C_Rat r1
        | _ -> Value'0.C_Rat (from_int'0 (- 1))
        end
      | Term'0.C_Conj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 /\ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Disj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 \/ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Eq l r -> Value'0.C_Bool (interp'0 self l = interp'0 self r)
      | Term'0.C_Neg t -> match interp'0 self t with
        | Value'0.C_Bool b -> Value'0.C_Bool (not b)
        | _ -> Value'0.C_Bool false
        end
      end
  
  axiom interp'0_spec : forall self : Model'0.t_model, t : Term'0.t_term . ([%#span28] inv'0 self)
   -> ([%#span29] invariant'2 self  -> sort'1 (interp'0 self t) = sort'0 t)
  
  predicate satisfies'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 193 4 193 52] (self : Model'0.t_model) (v : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span31] interp'0 self (let (a, _) = v in a) = (let (_, a) = v in a)
  
  predicate satisfied_by'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 677 4 677 47] (self : Trail'0.t_trail) (m : Model'0.t_model)
    
   =
    [%#span32] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 self a  -> satisfies'0 m a
  
  function level_of'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 408 4 408 50] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : int
    
   =
    [%#span35] match find'0 self d with
      | Option'0.C_Some (_, l) -> l
      | Option'0.C_None -> 0
      end
  
  axiom level_of'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span33] invariant_nonneg'0 self)
   -> ([%#span34] level_of'0 self d >= 0 /\ level_of'0 self d <= level'0 self)
  
  predicate trail_unique'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 373 4 373 37] (self : Trail'0.t_trail) =
    [%#span36] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> let ap = to_pair'0 a in not contains'0 tl ap
      /\ trail_unique'0 tl
      /\ (if is_bool'0 (let (_, a) = ap in a) then
        not contains'0 tl ((let (a, _) = ap in a), negate'0 (let (_, a) = ap in a))
      else
        true
      )
      end
  
  use set.Fset
  
  use set.Fset
  
  predicate contains'1 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (e : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span37] Fset.mem e self
  
  predicate invariant_contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 354 4 354 43] (self : Trail'0.t_trail) =
    [%#span38] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_contains'0 tl
      /\ match a with
        | Assign'0.C_Justified j _ _ -> forall a : (Term'0.t_term, Value'0.t_value) . contains'1 j a  -> contains'0 tl a
        | _ -> true
        end
      end
  
  use set.Fset
  
  function remove'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (a : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span39] Fset.remove a self
  
  use set.Fset
  
  use set.Fset
  
  use set.Fset
  
  function set_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 287 4 287 57] (self : Trail'0.t_trail) (s : Fset.fset (Term'0.t_term, Value'0.t_value)) : int
    
  
  axiom set_level'0_def : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . set_level'0 self s
  = ([%#span47] if Fset.cardinal s = 0 then
    0
  else
    if Fset.cardinal s = 1 then
      level_of'0 self (Fset.pick s)
    else
      let a = Fset.pick s in let rec' = set_level'0 self (remove'0 s a) in if level_of'0 self a >= rec' then
        level_of'0 self a
      else
        rec'
      
    
  )
  
  axiom set_level'0_spec : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . ([%#span40] invariant_nonneg'0 self)
   -> ([%#span45] set_level'0 self s <= level'0 self)
  && ([%#span44] set_level'0 self s >= 0)
  && ([%#span43] s = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))  -> set_level'0 self s = 0)
  && ([%#span42] s <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
   -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'1 s i /\ level_of'0 self i = set_level'0 self s))
  && ([%#span41] forall i : (Term'0.t_term, Value'0.t_value) . contains'1 s i
   -> level_of'0 self i <= set_level'0 self s)
  
  predicate invariant_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 320 4 320 40] (self : Trail'0.t_trail) =
    [%#span48] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_level'0 tl
      /\ match a with
        | Assign'0.C_Input _ _ -> l = 0
        | Assign'0.C_Decision _ _ -> level'0 tl + 1 = l
        | Assign'0.C_Justified j _ _ -> set_level'0 tl j = l
        end
      end
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 387 4 387 34] (self : Trail'0.t_trail) =
    [%#span49] invariant_level'0 self
    /\ invariant_contains'0 self /\ trail_unique'0 self /\ invariant_nonneg'0 self /\ invariant_assign'0 self
  
  function count_bounds'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 743 4 743 35] (self : Trail'0.t_trail) : () =
    [%#span52] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign (Assign'0.C_Input _ _) _ tl -> count_bounds'0 tl
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> count_bounds'0 tl
      | Trail'0.C_Assign (Assign'0.C_Justified _ _ _) _ tl -> count_bounds'0 tl
      end
  
  axiom count_bounds'0_spec : forall self : Trail'0.t_trail . ([%#span50] invariant'0 self)
   -> ([%#span51] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 self a  -> level_of'0 self a <= level'0 self)
  
  function restrict'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 561 4 561 45] (self : Trail'0.t_trail) (level : int) : Trail'0.t_trail
    
   =
    [%#span53] match self with
      | Trail'0.C_Empty -> Trail'0.C_Empty
      | Trail'0.C_Assign a l tl -> let tl = restrict'0 tl level in let _ = count_bounds'0 tl in if l <= level then
        Trail'0.C_Assign a l tl
      else
        tl
      
      end
  
  predicate unsat'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 684 4 684 30] (self : Trail'0.t_trail) =
    [%#span54] forall m : Model'0.t_model . inv'0 m  -> satisfied_by'0 (restrict'0 self 0) m  -> false
  
  predicate impls'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 697 4 697 41] (self : Trail'0.t_trail) (rhs : Trail'0.t_trail)
    
   =
    [%#span56] forall m : Model'0.t_model . inv'0 m
     -> satisfied_by'0 (restrict'0 self 0) m  -> satisfied_by'0 (restrict'0 rhs 0) m
  
  axiom impls'0_spec : forall self : Trail'0.t_trail, rhs : Trail'0.t_trail . [%#span55] impls'0 self rhs
   -> unsat'0 rhs  -> unsat'0 self
  
  predicate satisfy_set'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 199 4 199 60] (self : Model'0.t_model) (v : Fset.fset (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span57] forall a : (Term'0.t_term, Value'0.t_value) . contains'1 v a  -> satisfies'0 self a
  
  predicate justified_sound'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 141 4 141 40] (self : Assign'0.t_assign) =
    [%#span58] match self with
      | Assign'0.C_Justified just t val' -> forall m : Model'0.t_model . inv'0 m
       -> satisfy_set'0 m just  -> satisfies'0 m (t, val')
      | _ -> true
      end
  
  predicate sound'1 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 261 4 261 30] (self : Trail'0.t_trail)
   =
    [%#span59] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a _ tl -> sound'1 tl /\ justified_sound'0 a
      end
  
  use Cdsat_Theory_Normal_Type as Cdsat_Theory_Normal_Type
  
  predicate sound'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 829 4 829 30] (self : Normal'0.t_normal)
    
   =
    [%#span60] sound'1 (Cdsat_Theory_Normal_Type.normal_0 self)
  
  constant self  : Normal'0.t_normal
  
  constant t  : Term'0.t_term
  
  constant val'  : Value'0.t_value
  
  constant tgt  : Normal'0.t_normal
  
  predicate decide [#"/Users/xavier/Code/cdsat/src/theory.rs" 841 4 841 63] (self : Normal'0.t_normal) (t : Term'0.t_term) (val' : Value'0.t_value) (tgt : Normal'0.t_normal)
    
  
  goal vc_decide : ([%#stheory1] sound'0 self)
   -> ([%#stheory0] invariant'0 (Cdsat_Theory_Normal_Type.normal_0 self))
   -> (if acceptable'0 (Cdsat_Theory_Normal_Type.normal_0 self) t val' then
    ([%#stheory6] level'0 (Cdsat_Theory_Normal_Type.normal_0 self) <= len'0 (Cdsat_Theory_Normal_Type.normal_0 self))
    && ([%#stheory5] level'0 (Cdsat_Theory_Normal_Type.normal_0 self) >= 0)
     -> (let result = Cdsat_Theory_Normal_Type.normal_0 tgt
    = Trail'0.C_Assign (Assign'0.C_Decision t val') (level'0 (Cdsat_Theory_Normal_Type.normal_0 self)
    + 1) (Cdsat_Theory_Normal_Type.normal_0 self) in ([%#stheory4] result
     -> impls'0 (Cdsat_Theory_Normal_Type.normal_0 self) (Cdsat_Theory_Normal_Type.normal_0 tgt))
    && ([%#stheory3] result  -> sound'0 tgt)
    && ([%#stheory2] result  -> invariant'0 (Cdsat_Theory_Normal_Type.normal_0 tgt)))
  else
    let result = false in ([%#stheory4] result
     -> impls'0 (Cdsat_Theory_Normal_Type.normal_0 self) (Cdsat_Theory_Normal_Type.normal_0 tgt))
    && ([%#stheory3] result  -> sound'0 tgt)
    && ([%#stheory2] result  -> invariant'0 (Cdsat_Theory_Normal_Type.normal_0 tgt))
  )
end
module Cdsat_Theory_Impl6_Deduce_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 868 15 868 35
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 869 15 869 27
  
  let%span stheory2 = "/Users/xavier/Code/cdsat/src/theory.rs" 870 4 870 46
  
  let%span stheory3 = "/Users/xavier/Code/cdsat/src/theory.rs" 871 4 871 38
  
  let%span stheory4 = "/Users/xavier/Code/cdsat/src/theory.rs" 872 4 872 46
  
  let%span stheory5 = "/Users/xavier/Code/cdsat/src/theory.rs" 741 15 741 31
  
  let%span stheory6 = "/Users/xavier/Code/cdsat/src/theory.rs" 742 4 742 83
  
  let%span stheory7 = "/Users/xavier/Code/cdsat/src/theory.rs" 417 4 417 87
  
  let%span stheory8 = "/Users/xavier/Code/cdsat/src/theory.rs" 877 15 877 84
  
  let%span stheory9 = "/Users/xavier/Code/cdsat/src/theory.rs" 878 15 878 82
  
  let%span stheory10 = "/Users/xavier/Code/cdsat/src/theory.rs" 281 15 281 38
  
  let%span stheory11 = "/Users/xavier/Code/cdsat/src/theory.rs" 282 4 282 74
  
  let%span stheory12 = "/Users/xavier/Code/cdsat/src/theory.rs" 283 4 283 94
  
  let%span stheory13 = "/Users/xavier/Code/cdsat/src/theory.rs" 284 4 284 48
  
  let%span stheory14 = "/Users/xavier/Code/cdsat/src/theory.rs" 285 14 285 25
  
  let%span stheory15 = "/Users/xavier/Code/cdsat/src/theory.rs" 286 14 286 36
  
  let%span stheory16 = "/Users/xavier/Code/cdsat/src/theory.rs" 280 14 280 21
  
  let%span span17 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span18 = "/Users/xavier/Code/cdsat/src/theory.rs" 157 8 159 9
  
  let%span span19 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span20 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  let%span span21 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span span22 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span23 = "/Users/xavier/Code/cdsat/src/theory.rs" 601 8 605 9
  
  let%span span24 = "/Users/xavier/Code/cdsat/src/theory.rs" 337 8 340 9
  
  let%span span25 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 53 8 53 26
  
  let%span span26 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span27 = "/Users/xavier/Code/cdsat/src/theory.rs" 122 8 126 9
  
  let%span span28 = "/Users/xavier/Code/cdsat/src/theory.rs" 346 8 349 9
  
  let%span span29 = "/Users/xavier/Code/cdsat/src/theory.rs" 132 8 136 9
  
  let%span span30 = "/Users/xavier/Code/cdsat/src/theory.rs" 465 14 468 5
  
  let%span span31 = "/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 111
  
  let%span span32 = "/Users/xavier/Code/cdsat/src/theory.rs" 470 4 470 104
  
  let%span span33 = "/Users/xavier/Code/cdsat/src/theory.rs" 472 8 481 9
  
  let%span span34 = "/Users/xavier/Code/cdsat/src/theory.rs" 406 15 406 38
  
  let%span span35 = "/Users/xavier/Code/cdsat/src/theory.rs" 407 14 407 51
  
  let%span span36 = "/Users/xavier/Code/cdsat/src/theory.rs" 409 8 412 9
  
  let%span span37 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 16 8 16 26
  
  let%span span38 = "/Users/xavier/Code/cdsat/src/theory.rs" 278 4 278 12
  
  let%span span39 = "/Users/xavier/Code/cdsat/src/theory.rs" 167 18 167 22
  
  let%span span40 = "/Users/xavier/Code/cdsat/src/theory.rs" 166 4 166 62
  
  let%span span41 = "/Users/xavier/Code/cdsat/src/theory.rs" 168 8 188 9
  
  let%span span42 = "/Users/xavier/Code/cdsat/src/theory.rs" 194 8 194 31
  
  let%span span43 = "/Users/xavier/Code/cdsat/src/theory.rs" 200 8 200 71
  
  let%span span44 = "/Users/xavier/Code/cdsat/src/theory.rs" 206 8 206 84
  
  let%span span45 = "/Users/xavier/Code/cdsat/src/theory.rs" 82 8 82 36
  
  let%span span46 = "/Users/xavier/Code/cdsat/src/theory.rs" 96 15 96 29
  
  let%span span47 = "/Users/xavier/Code/cdsat/src/theory.rs" 97 14 97 30
  
  let%span span48 = "/Users/xavier/Code/cdsat/src/theory.rs" 99 8 102 9
  
  let%span span49 = "/Users/xavier/Code/cdsat/src/theory.rs" 419 8 422 9
  
  let%span span50 = "/Users/xavier/Code/cdsat/src/theory.rs" 398 8 400 79
  
  let%span span51 = "/Users/xavier/Code/cdsat/src/theory.rs" 374 8 382 9
  
  let%span span52 = "/Users/xavier/Code/cdsat/src/theory.rs" 355 8 368 9
  
  let%span span53 = "/Users/xavier/Code/cdsat/src/theory.rs" 321 8 331 9
  
  let%span span54 = "/Users/xavier/Code/cdsat/src/theory.rs" 388 8 392 38
  
  let%span span55 = "/Users/xavier/Code/cdsat/src/theory.rs" 744 8 749 9
  
  let%span span56 = "/Users/xavier/Code/cdsat/src/theory.rs" 678 8 678 71
  
  let%span span57 = "/Users/xavier/Code/cdsat/src/theory.rs" 562 8 573 9
  
  let%span span58 = "/Users/xavier/Code/cdsat/src/theory.rs" 685 8 685 82
  
  let%span span59 = "/Users/xavier/Code/cdsat/src/theory.rs" 696 4 696 55
  
  let%span span60 = "/Users/xavier/Code/cdsat/src/theory.rs" 698 8 698 108
  
  let%span span61 = "/Users/xavier/Code/cdsat/src/theory.rs" 142 8 147 9
  
  let%span span62 = "/Users/xavier/Code/cdsat/src/theory.rs" 262 8 265 9
  
  let%span span63 = "/Users/xavier/Code/cdsat/src/theory.rs" 826 4 826 16
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  use Cdsat_Theory_Value_Type as Value'0
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span17] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  use map.Map
  
  use Cdsat_Theory_Model_Type as Cdsat_Theory_Model_Type
  
  use Cdsat_Theory_Var_Type as Var'0
  
  use Cdsat_Theory_Model_Type as Model'0
  
  predicate invariant'2 [#"/Users/xavier/Code/cdsat/src/theory.rs" 156 4 156 30] (self : Model'0.t_model) =
    [%#span18] forall v : Value'0.t_value . forall k : Var'0.t_var . Map.get (Cdsat_Theory_Model_Type.model_0 self) k
    = v  -> Cdsat_Theory_Var_Type.var_1 k = sort'1 v
  
  predicate inv'0 (_x : Model'0.t_model)
  
  axiom inv'0 : forall x : Model'0.t_model . inv'0 x
  = (invariant'2 x
  /\ match x with
    | Model'0.C_Model a_0 -> true
    end)
  
  use set.Fset
  
  use set.Fset
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  use prelude.prelude.Int
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span20] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span19] len'0 self >= 0
  
  function level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int =
    [%#span23] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> 1 + level'0 tl
      | Trail'0.C_Assign _ _ tl -> level'0 tl
      end
  
  axiom level'0_spec : forall self : Trail'0.t_trail . ([%#span22] level'0 self <= len'0 self)
  && ([%#span21] level'0 self >= 0)
  
  predicate invariant_nonneg'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 336 4 336 41] (self : Trail'0.t_trail) =
    [%#span24] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_nonneg'0 tl /\ l >= 0 /\ l <= level'0 self
      end
  
  use set.Fset
  
  use Cdsat_Theory_Term_Type as Term'0
  
  use set.Fset
  
  function remove'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (a : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span25] Fset.remove a self
  
  use set.Fset
  
  use prelude.prelude.Int
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span26] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'1 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  predicate invariant'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 121 4 121 34] (self : Assign'0.t_assign) =
    [%#span27] match self with
      | Assign'0.C_Decision t v -> sort'0 t = sort'1 v
      | Assign'0.C_Justified _ t v -> sort'0 t = sort'1 v /\ sort'0 t = Sort'0.C_Boolean
      | Assign'0.C_Input t v -> sort'0 t = sort'1 v
      end
  
  predicate invariant_assign'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 345 4 345 41] (self : Trail'0.t_trail) =
    [%#span28] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_assign'0 tl /\ invariant'1 a
      end
  
  function to_pair'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 131 4 131 41] (self : Assign'0.t_assign) : (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span29] match self with
      | Assign'0.C_Decision t val' -> (t, val')
      | Assign'0.C_Input t val' -> (t, val')
      | Assign'0.C_Justified _ t val' -> (t, val')
      end
  
  use Core_Option_Option_Type as Option'0
  
  function find'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 471 4 471 64] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Option'0.t_option (Assign'0.t_assign, int)
    
   =
    [%#span33] match self with
      | Trail'0.C_Empty -> Option'0.C_None
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then Option'0.C_Some (a, l) else find'0 tl d
      end
  
  axiom find'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span32] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)))
  && ([%#span31] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
  && ([%#span30] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
  
  function level_of'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 408 4 408 50] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : int
    
   =
    [%#span36] match find'0 self d with
      | Option'0.C_Some (_, l) -> l
      | Option'0.C_None -> 0
      end
  
  axiom level_of'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span34] invariant_nonneg'0 self)
   -> ([%#span35] level_of'0 self d >= 0 /\ level_of'0 self d <= level'0 self)
  
  use set.Fset
  
  predicate contains'1 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (e : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span37] Fset.mem e self
  
  function set_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 287 4 287 57] (self : Trail'0.t_trail) (s : Fset.fset (Term'0.t_term, Value'0.t_value)) : int
    
  
  axiom set_level'0_def : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . set_level'0 self s
  = ([%#span38] if Fset.cardinal s = 0 then
    0
  else
    if Fset.cardinal s = 1 then
      level_of'0 self (Fset.pick s)
    else
      let a = Fset.pick s in let rec' = set_level'0 self (remove'0 s a) in if level_of'0 self a >= rec' then
        level_of'0 self a
      else
        rec'
      
    
  )
  
  axiom set_level'0_spec : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . ([%#stheory10] invariant_nonneg'0 self)
   -> ([%#stheory15] set_level'0 self s <= level'0 self)
  && ([%#stheory14] set_level'0 self s >= 0)
  && ([%#stheory13] s = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))  -> set_level'0 self s = 0)
  && ([%#stheory12] s <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
   -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'1 s i /\ level_of'0 self i = set_level'0 self s))
  && ([%#stheory11] forall i : (Term'0.t_term, Value'0.t_value) . contains'1 s i
   -> level_of'0 self i <= set_level'0 self s)
  
  use prelude.prelude.Real
  
  function from_int'0 (_1 : int) : Real.real
  
  function interp'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 167 4 167 41] (self : Model'0.t_model) (t : Term'0.t_term) : Value'0.t_value
    
   =
    [%#span41] match t with
      | Term'0.C_Variable v -> Map.get (Cdsat_Theory_Model_Type.model_0 self) v
      | Term'0.C_Value v -> v
      | Term'0.C_Plus l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Rat r1, Value'0.C_Rat r2) -> Value'0.C_Rat r1
        | _ -> Value'0.C_Rat (from_int'0 (- 1))
        end
      | Term'0.C_Conj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 /\ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Disj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 \/ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Eq l r -> Value'0.C_Bool (interp'0 self l = interp'0 self r)
      | Term'0.C_Neg t -> match interp'0 self t with
        | Value'0.C_Bool b -> Value'0.C_Bool (not b)
        | _ -> Value'0.C_Bool false
        end
      end
  
  axiom interp'0_spec : forall self : Model'0.t_model, t : Term'0.t_term . ([%#span39] inv'0 self)
   -> ([%#span40] invariant'2 self  -> sort'1 (interp'0 self t) = sort'0 t)
  
  predicate satisfies'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 193 4 193 52] (self : Model'0.t_model) (v : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span42] interp'0 self (let (a, _) = v in a) = (let (_, a) = v in a)
  
  predicate satisfy_set'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 199 4 199 60] (self : Model'0.t_model) (v : Fset.fset (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span43] forall a : (Term'0.t_term, Value'0.t_value) . contains'1 v a  -> satisfies'0 self a
  
  predicate entails'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 205 4 205 74] (self : Model'0.t_model) (j : Fset.fset (Term'0.t_term, Value'0.t_value)) (c : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span44] invariant'2 self  -> satisfy_set'0 self j  -> satisfies'0 self c
  
  predicate is_bool'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 81 4 81 32] (self : Value'0.t_value) =
    [%#span45] sort'1 self = Sort'0.C_Boolean
  
  function negate'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 98 4 98 31] (self : Value'0.t_value) : Value'0.t_value =
    [%#span48] match self with
      | Value'0.C_Bool b -> Value'0.C_Bool (not b)
      | _ -> self
      end
  
  axiom negate'0_spec : forall self : Value'0.t_value . ([%#span46] is_bool'0 self)
   -> ([%#span47] is_bool'0 (negate'0 self))
  
  predicate contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 418 4 418 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span49] match find'0 self d with
      | Option'0.C_Some ix -> true
      | Option'0.C_None -> false
      end
  
  axiom contains'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . [%#stheory7] invariant_assign'0 self
   -> contains'0 self d = true  -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)
  
  predicate acceptable'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 397 4 397 56] (self : Trail'0.t_trail) (t : Term'0.t_term) (val' : Value'0.t_value)
    
   =
    [%#span50] not contains'0 self (t, val')
    /\ sort'0 t = sort'1 val' /\ (is_bool'0 val'  -> not contains'0 self (t, negate'0 val'))
  
  predicate trail_unique'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 373 4 373 37] (self : Trail'0.t_trail) =
    [%#span51] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> let ap = to_pair'0 a in not contains'0 tl ap
      /\ trail_unique'0 tl
      /\ (if is_bool'0 (let (_, a) = ap in a) then
        not contains'0 tl ((let (a, _) = ap in a), negate'0 (let (_, a) = ap in a))
      else
        true
      )
      end
  
  predicate invariant_contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 354 4 354 43] (self : Trail'0.t_trail) =
    [%#span52] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_contains'0 tl
      /\ match a with
        | Assign'0.C_Justified j _ _ -> forall a : (Term'0.t_term, Value'0.t_value) . contains'1 j a  -> contains'0 tl a
        | _ -> true
        end
      end
  
  predicate invariant_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 320 4 320 40] (self : Trail'0.t_trail) =
    [%#span53] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_level'0 tl
      /\ match a with
        | Assign'0.C_Input _ _ -> l = 0
        | Assign'0.C_Decision _ _ -> level'0 tl + 1 = l
        | Assign'0.C_Justified j _ _ -> set_level'0 tl j = l
        end
      end
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 387 4 387 34] (self : Trail'0.t_trail) =
    [%#span54] invariant_level'0 self
    /\ invariant_contains'0 self /\ trail_unique'0 self /\ invariant_nonneg'0 self /\ invariant_assign'0 self
  
  function count_bounds'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 743 4 743 35] (self : Trail'0.t_trail) : () =
    [%#span55] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign (Assign'0.C_Input _ _) _ tl -> count_bounds'0 tl
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> count_bounds'0 tl
      | Trail'0.C_Assign (Assign'0.C_Justified _ _ _) _ tl -> count_bounds'0 tl
      end
  
  axiom count_bounds'0_spec : forall self : Trail'0.t_trail . ([%#stheory5] invariant'0 self)
   -> ([%#stheory6] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 self a
   -> level_of'0 self a <= level'0 self)
  
  use Cdsat_Theory_Normal_Type as Normal'0
  
  predicate satisfied_by'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 677 4 677 47] (self : Trail'0.t_trail) (m : Model'0.t_model)
    
   =
    [%#span56] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 self a  -> satisfies'0 m a
  
  function restrict'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 561 4 561 45] (self : Trail'0.t_trail) (level : int) : Trail'0.t_trail
    
   =
    [%#span57] match self with
      | Trail'0.C_Empty -> Trail'0.C_Empty
      | Trail'0.C_Assign a l tl -> let tl = restrict'0 tl level in let _ = count_bounds'0 tl in if l <= level then
        Trail'0.C_Assign a l tl
      else
        tl
      
      end
  
  predicate unsat'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 684 4 684 30] (self : Trail'0.t_trail) =
    [%#span58] forall m : Model'0.t_model . inv'0 m  -> satisfied_by'0 (restrict'0 self 0) m  -> false
  
  predicate impls'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 697 4 697 41] (self : Trail'0.t_trail) (rhs : Trail'0.t_trail)
    
   =
    [%#span60] forall m : Model'0.t_model . inv'0 m
     -> satisfied_by'0 (restrict'0 self 0) m  -> satisfied_by'0 (restrict'0 rhs 0) m
  
  axiom impls'0_spec : forall self : Trail'0.t_trail, rhs : Trail'0.t_trail . [%#span59] impls'0 self rhs
   -> unsat'0 rhs  -> unsat'0 self
  
  predicate justified_sound'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 141 4 141 40] (self : Assign'0.t_assign) =
    [%#span61] match self with
      | Assign'0.C_Justified just t val' -> forall m : Model'0.t_model . inv'0 m
       -> satisfy_set'0 m just  -> satisfies'0 m (t, val')
      | _ -> true
      end
  
  predicate sound'1 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 261 4 261 30] (self : Trail'0.t_trail)
   =
    [%#span62] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a _ tl -> sound'1 tl /\ justified_sound'0 a
      end
  
  use Cdsat_Theory_Normal_Type as Cdsat_Theory_Normal_Type
  
  predicate sound'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 829 4 829 30] (self : Normal'0.t_normal)
    
   =
    [%#span63] sound'1 (Cdsat_Theory_Normal_Type.normal_0 self)
  
  constant self  : Normal'0.t_normal
  
  constant just  : (Fset.fset (Term'0.t_term, Value'0.t_value), Term'0.t_term, Value'0.t_value)
  
  constant tgt  : Normal'0.t_normal
  
  predicate deduce [#"/Users/xavier/Code/cdsat/src/theory.rs" 873 4 873 84] (self : Normal'0.t_normal) (just : (Fset.fset (Term'0.t_term, Value'0.t_value), Term'0.t_term, Value'0.t_value)) (tgt : Normal'0.t_normal)
    
  
  goal vc_deduce : ([%#stheory1] sound'0 self)
   -> ([%#stheory0] invariant'0 (Cdsat_Theory_Normal_Type.normal_0 self))
   -> ([%#stheory5] invariant'0 (Cdsat_Theory_Normal_Type.normal_0 self))
  /\ (([%#stheory6] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 (Cdsat_Theory_Normal_Type.normal_0 self) a
   -> level_of'0 (Cdsat_Theory_Normal_Type.normal_0 self) a <= level'0 (Cdsat_Theory_Normal_Type.normal_0 self))
   -> (let _ = count_bounds'0 (Cdsat_Theory_Normal_Type.normal_0 self) in if is_bool'0 (let (_, _, a) = just in a) then
    if acceptable'0 (Cdsat_Theory_Normal_Type.normal_0 self) (let (_, a, _) = just in a) (let (_, _, a) = just in a) then
      if [%#stheory8] forall j : (Term'0.t_term, Value'0.t_value) . contains'1 (let (a, _, _) = just in a) j
       -> contains'0 (Cdsat_Theory_Normal_Type.normal_0 self) j then
        if [%#stheory9] forall m : Model'0.t_model . inv'0 m
         -> entails'0 m (let (a, _, _) = just in a) ((let (_, a, _) = just in a), (let (_, _, a) = just in a)) then
          ([%#stheory10] invariant_nonneg'0 (Cdsat_Theory_Normal_Type.normal_0 self))
          /\ (([%#stheory15] set_level'0 (Cdsat_Theory_Normal_Type.normal_0 self) (let (a, _, _) = just in a)
          <= level'0 (Cdsat_Theory_Normal_Type.normal_0 self))
          && ([%#stheory14] set_level'0 (Cdsat_Theory_Normal_Type.normal_0 self) (let (a, _, _) = just in a) >= 0)
          && ([%#stheory13] (let (a, _, _) = just in a) = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
           -> set_level'0 (Cdsat_Theory_Normal_Type.normal_0 self) (let (a, _, _) = just in a) = 0)
          && ([%#stheory12] (let (a, _, _) = just in a) <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
           -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'1 (let (a, _, _) = just in a) i
          /\ level_of'0 (Cdsat_Theory_Normal_Type.normal_0 self) i
          = set_level'0 (Cdsat_Theory_Normal_Type.normal_0 self) (let (a, _, _) = just in a)))
          && ([%#stheory11] forall i : (Term'0.t_term, Value'0.t_value) . contains'1 (let (a, _, _) = just in a) i
           -> level_of'0 (Cdsat_Theory_Normal_Type.normal_0 self) i
          <= set_level'0 (Cdsat_Theory_Normal_Type.normal_0 self) (let (a, _, _) = just in a))
           -> (let result = Cdsat_Theory_Normal_Type.normal_0 tgt
          = Trail'0.C_Assign (Assign'0.C_Justified (let (a, _, _) = just in a) (let (_, a, _) = just in a) (let (_, _, a) = just in a)) (set_level'0 (Cdsat_Theory_Normal_Type.normal_0 self) (let (a, _, _) = just in a)) (Cdsat_Theory_Normal_Type.normal_0 self) in ([%#stheory4] result
           -> impls'0 (Cdsat_Theory_Normal_Type.normal_0 self) (Cdsat_Theory_Normal_Type.normal_0 tgt))
          && ([%#stheory3] result  -> sound'0 tgt)
          && ([%#stheory2] result  -> invariant'0 (Cdsat_Theory_Normal_Type.normal_0 tgt))))
        else
          let result = false in ([%#stheory4] result
           -> impls'0 (Cdsat_Theory_Normal_Type.normal_0 self) (Cdsat_Theory_Normal_Type.normal_0 tgt))
          && ([%#stheory3] result  -> sound'0 tgt)
          && ([%#stheory2] result  -> invariant'0 (Cdsat_Theory_Normal_Type.normal_0 tgt))
        
      else
        let result = false in ([%#stheory4] result
         -> impls'0 (Cdsat_Theory_Normal_Type.normal_0 self) (Cdsat_Theory_Normal_Type.normal_0 tgt))
        && ([%#stheory3] result  -> sound'0 tgt)
        && ([%#stheory2] result  -> invariant'0 (Cdsat_Theory_Normal_Type.normal_0 tgt))
      
    else
      let result = false in ([%#stheory4] result
       -> impls'0 (Cdsat_Theory_Normal_Type.normal_0 self) (Cdsat_Theory_Normal_Type.normal_0 tgt))
      && ([%#stheory3] result  -> sound'0 tgt)
      && ([%#stheory2] result  -> invariant'0 (Cdsat_Theory_Normal_Type.normal_0 tgt))
    
  else
    let result = false in ([%#stheory4] result
     -> impls'0 (Cdsat_Theory_Normal_Type.normal_0 self) (Cdsat_Theory_Normal_Type.normal_0 tgt))
    && ([%#stheory3] result  -> sound'0 tgt)
    && ([%#stheory2] result  -> invariant'0 (Cdsat_Theory_Normal_Type.normal_0 tgt))
  ))
end
module Cdsat_Theory_Impl6_Fail_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 911 15 911 35
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 912 15 912 27
  
  let%span stheory2 = "/Users/xavier/Code/cdsat/src/theory.rs" 913 4 913 33
  
  let%span stheory3 = "/Users/xavier/Code/cdsat/src/theory.rs" 914 4 914 92
  
  let%span stheory4 = "/Users/xavier/Code/cdsat/src/theory.rs" 915 4 915 41
  
  let%span stheory5 = "/Users/xavier/Code/cdsat/src/theory.rs" 96 15 96 29
  
  let%span stheory6 = "/Users/xavier/Code/cdsat/src/theory.rs" 97 14 97 30
  
  let%span stheory7 = "/Users/xavier/Code/cdsat/src/theory.rs" 417 4 417 87
  
  let%span stheory8 = "/Users/xavier/Code/cdsat/src/theory.rs" 917 8 924 11
  
  let%span stheory9 = "/Users/xavier/Code/cdsat/src/theory.rs" 406 15 406 38
  
  let%span stheory10 = "/Users/xavier/Code/cdsat/src/theory.rs" 407 14 407 51
  
  let%span stheory11 = "/Users/xavier/Code/cdsat/src/theory.rs" 281 15 281 38
  
  let%span stheory12 = "/Users/xavier/Code/cdsat/src/theory.rs" 282 4 282 74
  
  let%span stheory13 = "/Users/xavier/Code/cdsat/src/theory.rs" 283 4 283 94
  
  let%span stheory14 = "/Users/xavier/Code/cdsat/src/theory.rs" 284 4 284 48
  
  let%span stheory15 = "/Users/xavier/Code/cdsat/src/theory.rs" 285 14 285 25
  
  let%span stheory16 = "/Users/xavier/Code/cdsat/src/theory.rs" 286 14 286 36
  
  let%span stheory17 = "/Users/xavier/Code/cdsat/src/theory.rs" 280 14 280 21
  
  let%span span18 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span19 = "/Users/xavier/Code/cdsat/src/theory.rs" 157 8 159 9
  
  let%span span20 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 53 8 53 26
  
  let%span span21 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span22 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  let%span span23 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span span24 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span25 = "/Users/xavier/Code/cdsat/src/theory.rs" 601 8 605 9
  
  let%span span26 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span27 = "/Users/xavier/Code/cdsat/src/theory.rs" 122 8 126 9
  
  let%span span28 = "/Users/xavier/Code/cdsat/src/theory.rs" 346 8 349 9
  
  let%span span29 = "/Users/xavier/Code/cdsat/src/theory.rs" 337 8 340 9
  
  let%span span30 = "/Users/xavier/Code/cdsat/src/theory.rs" 132 8 136 9
  
  let%span span31 = "/Users/xavier/Code/cdsat/src/theory.rs" 465 14 468 5
  
  let%span span32 = "/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 111
  
  let%span span33 = "/Users/xavier/Code/cdsat/src/theory.rs" 470 4 470 104
  
  let%span span34 = "/Users/xavier/Code/cdsat/src/theory.rs" 472 8 481 9
  
  let%span span35 = "/Users/xavier/Code/cdsat/src/theory.rs" 409 8 412 9
  
  let%span span36 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 16 8 16 26
  
  let%span span37 = "/Users/xavier/Code/cdsat/src/theory.rs" 278 4 278 12
  
  let%span span38 = "/Users/xavier/Code/cdsat/src/theory.rs" 167 18 167 22
  
  let%span span39 = "/Users/xavier/Code/cdsat/src/theory.rs" 166 4 166 62
  
  let%span span40 = "/Users/xavier/Code/cdsat/src/theory.rs" 168 8 188 9
  
  let%span span41 = "/Users/xavier/Code/cdsat/src/theory.rs" 194 8 194 31
  
  let%span span42 = "/Users/xavier/Code/cdsat/src/theory.rs" 200 8 200 71
  
  let%span span43 = "/Users/xavier/Code/cdsat/src/theory.rs" 206 8 206 84
  
  let%span span44 = "/Users/xavier/Code/cdsat/src/theory.rs" 419 8 422 9
  
  let%span span45 = "/Users/xavier/Code/cdsat/src/theory.rs" 82 8 82 36
  
  let%span span46 = "/Users/xavier/Code/cdsat/src/theory.rs" 99 8 102 9
  
  let%span span47 = "/Users/xavier/Code/cdsat/src/theory.rs" 678 8 678 71
  
  let%span span48 = "/Users/xavier/Code/cdsat/src/theory.rs" 374 8 382 9
  
  let%span span49 = "/Users/xavier/Code/cdsat/src/theory.rs" 355 8 368 9
  
  let%span span50 = "/Users/xavier/Code/cdsat/src/theory.rs" 321 8 331 9
  
  let%span span51 = "/Users/xavier/Code/cdsat/src/theory.rs" 388 8 392 38
  
  let%span span52 = "/Users/xavier/Code/cdsat/src/theory.rs" 741 15 741 31
  
  let%span span53 = "/Users/xavier/Code/cdsat/src/theory.rs" 742 4 742 83
  
  let%span span54 = "/Users/xavier/Code/cdsat/src/theory.rs" 744 8 749 9
  
  let%span span55 = "/Users/xavier/Code/cdsat/src/theory.rs" 562 8 573 9
  
  let%span span56 = "/Users/xavier/Code/cdsat/src/theory.rs" 685 8 685 82
  
  let%span span57 = "/Users/xavier/Code/cdsat/src/theory.rs" 142 8 147 9
  
  let%span span58 = "/Users/xavier/Code/cdsat/src/theory.rs" 262 8 265 9
  
  let%span span59 = "/Users/xavier/Code/cdsat/src/theory.rs" 826 4 826 16
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  use Cdsat_Theory_Value_Type as Value'0
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span18] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  use map.Map
  
  use Cdsat_Theory_Model_Type as Cdsat_Theory_Model_Type
  
  use Cdsat_Theory_Var_Type as Var'0
  
  use Cdsat_Theory_Model_Type as Model'0
  
  predicate invariant'2 [#"/Users/xavier/Code/cdsat/src/theory.rs" 156 4 156 30] (self : Model'0.t_model) =
    [%#span19] forall v : Value'0.t_value . forall k : Var'0.t_var . Map.get (Cdsat_Theory_Model_Type.model_0 self) k
    = v  -> Cdsat_Theory_Var_Type.var_1 k = sort'1 v
  
  predicate inv'0 (_x : Model'0.t_model)
  
  axiom inv'0 : forall x : Model'0.t_model . inv'0 x
  = (invariant'2 x
  /\ match x with
    | Model'0.C_Model a_0 -> true
    end)
  
  use set.Fset
  
  use set.Fset
  
  use set.Fset
  
  use Cdsat_Theory_Term_Type as Term'0
  
  use set.Fset
  
  function remove'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (a : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span20] Fset.remove a self
  
  use set.Fset
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  use prelude.prelude.Int
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span22] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span21] len'0 self >= 0
  
  function level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int =
    [%#span25] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> 1 + level'0 tl
      | Trail'0.C_Assign _ _ tl -> level'0 tl
      end
  
  axiom level'0_spec : forall self : Trail'0.t_trail . ([%#span24] level'0 self <= len'0 self)
  && ([%#span23] level'0 self >= 0)
  
  use prelude.prelude.Int
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span26] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'1 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  predicate invariant'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 121 4 121 34] (self : Assign'0.t_assign) =
    [%#span27] match self with
      | Assign'0.C_Decision t v -> sort'0 t = sort'1 v
      | Assign'0.C_Justified _ t v -> sort'0 t = sort'1 v /\ sort'0 t = Sort'0.C_Boolean
      | Assign'0.C_Input t v -> sort'0 t = sort'1 v
      end
  
  predicate invariant_assign'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 345 4 345 41] (self : Trail'0.t_trail) =
    [%#span28] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_assign'0 tl /\ invariant'1 a
      end
  
  predicate invariant_nonneg'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 336 4 336 41] (self : Trail'0.t_trail) =
    [%#span29] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_nonneg'0 tl /\ l >= 0 /\ l <= level'0 self
      end
  
  function to_pair'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 131 4 131 41] (self : Assign'0.t_assign) : (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span30] match self with
      | Assign'0.C_Decision t val' -> (t, val')
      | Assign'0.C_Input t val' -> (t, val')
      | Assign'0.C_Justified _ t val' -> (t, val')
      end
  
  use Core_Option_Option_Type as Option'0
  
  function find'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 471 4 471 64] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Option'0.t_option (Assign'0.t_assign, int)
    
   =
    [%#span34] match self with
      | Trail'0.C_Empty -> Option'0.C_None
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then Option'0.C_Some (a, l) else find'0 tl d
      end
  
  axiom find'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span33] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)))
  && ([%#span32] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
  && ([%#span31] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
  
  function level_of'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 408 4 408 50] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : int
    
   =
    [%#span35] match find'0 self d with
      | Option'0.C_Some (_, l) -> l
      | Option'0.C_None -> 0
      end
  
  axiom level_of'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#stheory9] invariant_nonneg'0 self)
   -> ([%#stheory10] level_of'0 self d >= 0 /\ level_of'0 self d <= level'0 self)
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (e : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span36] Fset.mem e self
  
  function set_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 287 4 287 57] (self : Trail'0.t_trail) (s : Fset.fset (Term'0.t_term, Value'0.t_value)) : int
    
  
  axiom set_level'0_def : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . set_level'0 self s
  = ([%#span37] if Fset.cardinal s = 0 then
    0
  else
    if Fset.cardinal s = 1 then
      level_of'0 self (Fset.pick s)
    else
      let a = Fset.pick s in let rec' = set_level'0 self (remove'0 s a) in if level_of'0 self a >= rec' then
        level_of'0 self a
      else
        rec'
      
    
  )
  
  axiom set_level'0_spec : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . ([%#stheory11] invariant_nonneg'0 self)
   -> ([%#stheory16] set_level'0 self s <= level'0 self)
  && ([%#stheory15] set_level'0 self s >= 0)
  && ([%#stheory14] s = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))  -> set_level'0 self s = 0)
  && ([%#stheory13] s <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
   -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'0 s i /\ level_of'0 self i = set_level'0 self s))
  && ([%#stheory12] forall i : (Term'0.t_term, Value'0.t_value) . contains'0 s i
   -> level_of'0 self i <= set_level'0 self s)
  
  use prelude.prelude.Real
  
  function from_int'0 (_1 : int) : Real.real
  
  function interp'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 167 4 167 41] (self : Model'0.t_model) (t : Term'0.t_term) : Value'0.t_value
    
   =
    [%#span40] match t with
      | Term'0.C_Variable v -> Map.get (Cdsat_Theory_Model_Type.model_0 self) v
      | Term'0.C_Value v -> v
      | Term'0.C_Plus l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Rat r1, Value'0.C_Rat r2) -> Value'0.C_Rat r1
        | _ -> Value'0.C_Rat (from_int'0 (- 1))
        end
      | Term'0.C_Conj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 /\ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Disj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 \/ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Eq l r -> Value'0.C_Bool (interp'0 self l = interp'0 self r)
      | Term'0.C_Neg t -> match interp'0 self t with
        | Value'0.C_Bool b -> Value'0.C_Bool (not b)
        | _ -> Value'0.C_Bool false
        end
      end
  
  axiom interp'0_spec : forall self : Model'0.t_model, t : Term'0.t_term . ([%#span38] inv'0 self)
   -> ([%#span39] invariant'2 self  -> sort'1 (interp'0 self t) = sort'0 t)
  
  predicate satisfies'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 193 4 193 52] (self : Model'0.t_model) (v : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span41] interp'0 self (let (a, _) = v in a) = (let (_, a) = v in a)
  
  predicate satisfy_set'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 199 4 199 60] (self : Model'0.t_model) (v : Fset.fset (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span42] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 v a  -> satisfies'0 self a
  
  predicate entails'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 205 4 205 74] (self : Model'0.t_model) (j : Fset.fset (Term'0.t_term, Value'0.t_value)) (c : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span43] invariant'2 self  -> satisfy_set'0 self j  -> satisfies'0 self c
  
  predicate contains'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 418 4 418 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span44] match find'0 self d with
      | Option'0.C_Some ix -> true
      | Option'0.C_None -> false
      end
  
  axiom contains'1_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . [%#stheory7] invariant_assign'0 self
   -> contains'1 self d = true  -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)
  
  predicate is_bool'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 81 4 81 32] (self : Value'0.t_value) =
    [%#span45] sort'1 self = Sort'0.C_Boolean
  
  function negate'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 98 4 98 31] (self : Value'0.t_value) : Value'0.t_value =
    [%#span46] match self with
      | Value'0.C_Bool b -> Value'0.C_Bool (not b)
      | _ -> self
      end
  
  axiom negate'0_spec : forall self : Value'0.t_value . ([%#stheory5] is_bool'0 self)
   -> ([%#stheory6] is_bool'0 (negate'0 self))
  
  use Cdsat_Theory_Normal_Type as Normal'0
  
  predicate satisfied_by'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 677 4 677 47] (self : Trail'0.t_trail) (m : Model'0.t_model)
    
   =
    [%#span47] forall a : (Term'0.t_term, Value'0.t_value) . contains'1 self a  -> satisfies'0 m a
  
  predicate trail_unique'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 373 4 373 37] (self : Trail'0.t_trail) =
    [%#span48] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> let ap = to_pair'0 a in not contains'1 tl ap
      /\ trail_unique'0 tl
      /\ (if is_bool'0 (let (_, a) = ap in a) then
        not contains'1 tl ((let (a, _) = ap in a), negate'0 (let (_, a) = ap in a))
      else
        true
      )
      end
  
  predicate invariant_contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 354 4 354 43] (self : Trail'0.t_trail) =
    [%#span49] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_contains'0 tl
      /\ match a with
        | Assign'0.C_Justified j _ _ -> forall a : (Term'0.t_term, Value'0.t_value) . contains'0 j a  -> contains'1 tl a
        | _ -> true
        end
      end
  
  predicate invariant_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 320 4 320 40] (self : Trail'0.t_trail) =
    [%#span50] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_level'0 tl
      /\ match a with
        | Assign'0.C_Input _ _ -> l = 0
        | Assign'0.C_Decision _ _ -> level'0 tl + 1 = l
        | Assign'0.C_Justified j _ _ -> set_level'0 tl j = l
        end
      end
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 387 4 387 34] (self : Trail'0.t_trail) =
    [%#span51] invariant_level'0 self
    /\ invariant_contains'0 self /\ trail_unique'0 self /\ invariant_nonneg'0 self /\ invariant_assign'0 self
  
  function count_bounds'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 743 4 743 35] (self : Trail'0.t_trail) : () =
    [%#span54] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign (Assign'0.C_Input _ _) _ tl -> count_bounds'0 tl
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> count_bounds'0 tl
      | Trail'0.C_Assign (Assign'0.C_Justified _ _ _) _ tl -> count_bounds'0 tl
      end
  
  axiom count_bounds'0_spec : forall self : Trail'0.t_trail . ([%#span52] invariant'0 self)
   -> ([%#span53] forall a : (Term'0.t_term, Value'0.t_value) . contains'1 self a  -> level_of'0 self a <= level'0 self)
  
  function restrict'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 561 4 561 45] (self : Trail'0.t_trail) (level : int) : Trail'0.t_trail
    
   =
    [%#span55] match self with
      | Trail'0.C_Empty -> Trail'0.C_Empty
      | Trail'0.C_Assign a l tl -> let tl = restrict'0 tl level in let _ = count_bounds'0 tl in if l <= level then
        Trail'0.C_Assign a l tl
      else
        tl
      
      end
  
  predicate unsat'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 684 4 684 30] (self : Trail'0.t_trail) =
    [%#span56] forall m : Model'0.t_model . inv'0 m  -> satisfied_by'0 (restrict'0 self 0) m  -> false
  
  predicate justified_sound'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 141 4 141 40] (self : Assign'0.t_assign) =
    [%#span57] match self with
      | Assign'0.C_Justified just t val' -> forall m : Model'0.t_model . inv'0 m
       -> satisfy_set'0 m just  -> satisfies'0 m (t, val')
      | _ -> true
      end
  
  predicate sound'1 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 261 4 261 30] (self : Trail'0.t_trail)
   =
    [%#span58] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a _ tl -> sound'1 tl /\ justified_sound'0 a
      end
  
  use Cdsat_Theory_Normal_Type as Cdsat_Theory_Normal_Type
  
  predicate sound'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 829 4 829 30] (self : Normal'0.t_normal)
    
   =
    [%#span59] sound'1 (Cdsat_Theory_Normal_Type.normal_0 self)
  
  constant self  : Normal'0.t_normal
  
  constant just  : (Fset.fset (Term'0.t_term, Value'0.t_value), Term'0.t_term, Value'0.t_value)
  
  predicate fail [#"/Users/xavier/Code/cdsat/src/theory.rs" 916 4 916 71] (self : Normal'0.t_normal) (just : (Fset.fset (Term'0.t_term, Value'0.t_value), Term'0.t_term, Value'0.t_value))
    
  
  goal vc_fail : ([%#stheory3] forall m : Model'0.t_model . inv'0 m
   -> satisfy_set'0 m (let (a, _, _) = just in a)
   -> satisfies'0 m ((let (_, a, _) = just in a), (let (_, _, a) = just in a)))
   -> ([%#stheory2] is_bool'0 (let (_, _, a) = just in a))
   -> ([%#stheory1] sound'0 self)
   -> ([%#stheory0] invariant'0 (Cdsat_Theory_Normal_Type.normal_0 self))
   -> ([%#stheory5] is_bool'0 (let (_, _, a) = just in a))
  /\ (([%#stheory6] is_bool'0 (negate'0 (let (_, _, a) = just in a)))
   -> (let not_l = ((let (_, a, _) = just in a), negate'0 (let (_, _, a) = just in a)) in if [%#stheory8] forall j : (Term'0.t_term, Value'0.t_value) . contains'0 (let (a, _, _) = just in a) j
   -> contains'1 (Cdsat_Theory_Normal_Type.normal_0 self) j then
    ([%#stheory7] invariant_assign'0 (Cdsat_Theory_Normal_Type.normal_0 self)
     -> contains'1 (Cdsat_Theory_Normal_Type.normal_0 self) ((let (_, a, _) = just in a), (let (_, _, a) = just in a))
    = true
     -> sort'0 (let (a, _) = ((let (_, a, _) = just in a), (let (_, _, a) = just in a)) in a)
    = sort'1 (let (_, a) = ((let (_, a, _) = just in a), (let (_, _, a) = just in a)) in a))
     -> (if not contains'1 (Cdsat_Theory_Normal_Type.normal_0 self) ((let (_, a, _) = just in a), (let (_, _, a) = just in a)) then
      if [%#stheory8] forall m : Model'0.t_model . inv'0 m
       -> entails'0 m (let (a, _, _) = just in a) ((let (_, a, _) = just in a), (let (_, _, a) = just in a)) then
        ([%#stheory7] invariant_assign'0 (Cdsat_Theory_Normal_Type.normal_0 self)
         -> contains'1 (Cdsat_Theory_Normal_Type.normal_0 self) not_l = true
         -> sort'0 (let (a, _) = not_l in a) = sort'1 (let (_, a) = not_l in a))
         -> (if contains'1 (Cdsat_Theory_Normal_Type.normal_0 self) not_l then
          ([%#stheory9] invariant_nonneg'0 (Cdsat_Theory_Normal_Type.normal_0 self))
          /\ (([%#stheory10] level_of'0 (Cdsat_Theory_Normal_Type.normal_0 self) not_l >= 0
          /\ level_of'0 (Cdsat_Theory_Normal_Type.normal_0 self) not_l
          <= level'0 (Cdsat_Theory_Normal_Type.normal_0 self))
           -> (if level_of'0 (Cdsat_Theory_Normal_Type.normal_0 self) not_l = 0 then
            ([%#stheory11] invariant_nonneg'0 (Cdsat_Theory_Normal_Type.normal_0 self))
            /\ (([%#stheory16] set_level'0 (Cdsat_Theory_Normal_Type.normal_0 self) (let (a, _, _) = just in a)
            <= level'0 (Cdsat_Theory_Normal_Type.normal_0 self))
            && ([%#stheory15] set_level'0 (Cdsat_Theory_Normal_Type.normal_0 self) (let (a, _, _) = just in a) >= 0)
            && ([%#stheory14] (let (a, _, _) = just in a) = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
             -> set_level'0 (Cdsat_Theory_Normal_Type.normal_0 self) (let (a, _, _) = just in a) = 0)
            && ([%#stheory13] (let (a, _, _) = just in a) <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
             -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'0 (let (a, _, _) = just in a) i
            /\ level_of'0 (Cdsat_Theory_Normal_Type.normal_0 self) i
            = set_level'0 (Cdsat_Theory_Normal_Type.normal_0 self) (let (a, _, _) = just in a)))
            && ([%#stheory12] forall i : (Term'0.t_term, Value'0.t_value) . contains'0 (let (a, _, _) = just in a) i
             -> level_of'0 (Cdsat_Theory_Normal_Type.normal_0 self) i
            <= set_level'0 (Cdsat_Theory_Normal_Type.normal_0 self) (let (a, _, _) = just in a))
             -> ([%#stheory4] set_level'0 (Cdsat_Theory_Normal_Type.normal_0 self) (let (a, _, _) = just in a) = 0
             -> unsat'0 (Cdsat_Theory_Normal_Type.normal_0 self)))
          else
            [%#stheory4] false  -> unsat'0 (Cdsat_Theory_Normal_Type.normal_0 self)
          ))
        else
          [%#stheory4] false  -> unsat'0 (Cdsat_Theory_Normal_Type.normal_0 self)
        )
      else
        [%#stheory4] false  -> unsat'0 (Cdsat_Theory_Normal_Type.normal_0 self)
      
    else
      [%#stheory4] false  -> unsat'0 (Cdsat_Theory_Normal_Type.normal_0 self)
    )
  else
    [%#stheory4] false  -> unsat'0 (Cdsat_Theory_Normal_Type.normal_0 self)
  ))
end
module Cdsat_Theory_Impl6_Fail2_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 930 15 930 35
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 931 15 931 27
  
  let%span stheory2 = "/Users/xavier/Code/cdsat/src/theory.rs" 932 4 932 41
  
  let%span stheory3 = "/Users/xavier/Code/cdsat/src/theory.rs" 417 4 417 87
  
  let%span stheory4 = "/Users/xavier/Code/cdsat/src/theory.rs" 936 8 940 11
  
  let%span stheory5 = "/Users/xavier/Code/cdsat/src/theory.rs" 281 15 281 38
  
  let%span stheory6 = "/Users/xavier/Code/cdsat/src/theory.rs" 282 4 282 74
  
  let%span stheory7 = "/Users/xavier/Code/cdsat/src/theory.rs" 283 4 283 94
  
  let%span stheory8 = "/Users/xavier/Code/cdsat/src/theory.rs" 284 4 284 48
  
  let%span stheory9 = "/Users/xavier/Code/cdsat/src/theory.rs" 285 14 285 25
  
  let%span stheory10 = "/Users/xavier/Code/cdsat/src/theory.rs" 286 14 286 36
  
  let%span stheory11 = "/Users/xavier/Code/cdsat/src/theory.rs" 280 14 280 21
  
  let%span span12 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span13 = "/Users/xavier/Code/cdsat/src/theory.rs" 157 8 159 9
  
  let%span span14 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span15 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  let%span span16 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span span17 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span18 = "/Users/xavier/Code/cdsat/src/theory.rs" 601 8 605 9
  
  let%span span19 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span20 = "/Users/xavier/Code/cdsat/src/theory.rs" 122 8 126 9
  
  let%span span21 = "/Users/xavier/Code/cdsat/src/theory.rs" 346 8 349 9
  
  let%span span22 = "/Users/xavier/Code/cdsat/src/theory.rs" 337 8 340 9
  
  let%span span23 = "/Users/xavier/Code/cdsat/src/theory.rs" 132 8 136 9
  
  let%span span24 = "/Users/xavier/Code/cdsat/src/theory.rs" 465 14 468 5
  
  let%span span25 = "/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 111
  
  let%span span26 = "/Users/xavier/Code/cdsat/src/theory.rs" 470 4 470 104
  
  let%span span27 = "/Users/xavier/Code/cdsat/src/theory.rs" 472 8 481 9
  
  let%span span28 = "/Users/xavier/Code/cdsat/src/theory.rs" 406 15 406 38
  
  let%span span29 = "/Users/xavier/Code/cdsat/src/theory.rs" 407 14 407 51
  
  let%span span30 = "/Users/xavier/Code/cdsat/src/theory.rs" 409 8 412 9
  
  let%span span31 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 53 8 53 26
  
  let%span span32 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 16 8 16 26
  
  let%span span33 = "/Users/xavier/Code/cdsat/src/theory.rs" 278 4 278 12
  
  let%span span34 = "/Users/xavier/Code/cdsat/src/theory.rs" 167 18 167 22
  
  let%span span35 = "/Users/xavier/Code/cdsat/src/theory.rs" 166 4 166 62
  
  let%span span36 = "/Users/xavier/Code/cdsat/src/theory.rs" 168 8 188 9
  
  let%span span37 = "/Users/xavier/Code/cdsat/src/theory.rs" 194 8 194 31
  
  let%span span38 = "/Users/xavier/Code/cdsat/src/theory.rs" 200 8 200 71
  
  let%span span39 = "/Users/xavier/Code/cdsat/src/theory.rs" 419 8 422 9
  
  let%span span40 = "/Users/xavier/Code/cdsat/src/theory.rs" 678 8 678 71
  
  let%span span41 = "/Users/xavier/Code/cdsat/src/theory.rs" 82 8 82 36
  
  let%span span42 = "/Users/xavier/Code/cdsat/src/theory.rs" 96 15 96 29
  
  let%span span43 = "/Users/xavier/Code/cdsat/src/theory.rs" 97 14 97 30
  
  let%span span44 = "/Users/xavier/Code/cdsat/src/theory.rs" 99 8 102 9
  
  let%span span45 = "/Users/xavier/Code/cdsat/src/theory.rs" 374 8 382 9
  
  let%span span46 = "/Users/xavier/Code/cdsat/src/theory.rs" 355 8 368 9
  
  let%span span47 = "/Users/xavier/Code/cdsat/src/theory.rs" 321 8 331 9
  
  let%span span48 = "/Users/xavier/Code/cdsat/src/theory.rs" 388 8 392 38
  
  let%span span49 = "/Users/xavier/Code/cdsat/src/theory.rs" 741 15 741 31
  
  let%span span50 = "/Users/xavier/Code/cdsat/src/theory.rs" 742 4 742 83
  
  let%span span51 = "/Users/xavier/Code/cdsat/src/theory.rs" 744 8 749 9
  
  let%span span52 = "/Users/xavier/Code/cdsat/src/theory.rs" 562 8 573 9
  
  let%span span53 = "/Users/xavier/Code/cdsat/src/theory.rs" 685 8 685 82
  
  let%span span54 = "/Users/xavier/Code/cdsat/src/theory.rs" 142 8 147 9
  
  let%span span55 = "/Users/xavier/Code/cdsat/src/theory.rs" 262 8 265 9
  
  let%span span56 = "/Users/xavier/Code/cdsat/src/theory.rs" 826 4 826 16
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  use Cdsat_Theory_Value_Type as Value'0
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span12] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  use map.Map
  
  use Cdsat_Theory_Model_Type as Cdsat_Theory_Model_Type
  
  use Cdsat_Theory_Var_Type as Var'0
  
  use Cdsat_Theory_Model_Type as Model'0
  
  predicate invariant'2 [#"/Users/xavier/Code/cdsat/src/theory.rs" 156 4 156 30] (self : Model'0.t_model) =
    [%#span13] forall v : Value'0.t_value . forall k : Var'0.t_var . Map.get (Cdsat_Theory_Model_Type.model_0 self) k
    = v  -> Cdsat_Theory_Var_Type.var_1 k = sort'1 v
  
  predicate inv'0 (_x : Model'0.t_model)
  
  axiom inv'0 : forall x : Model'0.t_model . inv'0 x
  = (invariant'2 x
  /\ match x with
    | Model'0.C_Model a_0 -> true
    end)
  
  use set.Fset
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  use prelude.prelude.Int
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span15] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span14] len'0 self >= 0
  
  function level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int =
    [%#span18] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> 1 + level'0 tl
      | Trail'0.C_Assign _ _ tl -> level'0 tl
      end
  
  axiom level'0_spec : forall self : Trail'0.t_trail . ([%#span17] level'0 self <= len'0 self)
  && ([%#span16] level'0 self >= 0)
  
  use set.Fset
  
  use prelude.prelude.Int
  
  use Cdsat_Theory_Term_Type as Term'0
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span19] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'1 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  predicate invariant'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 121 4 121 34] (self : Assign'0.t_assign) =
    [%#span20] match self with
      | Assign'0.C_Decision t v -> sort'0 t = sort'1 v
      | Assign'0.C_Justified _ t v -> sort'0 t = sort'1 v /\ sort'0 t = Sort'0.C_Boolean
      | Assign'0.C_Input t v -> sort'0 t = sort'1 v
      end
  
  predicate invariant_assign'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 345 4 345 41] (self : Trail'0.t_trail) =
    [%#span21] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_assign'0 tl /\ invariant'1 a
      end
  
  predicate invariant_nonneg'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 336 4 336 41] (self : Trail'0.t_trail) =
    [%#span22] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_nonneg'0 tl /\ l >= 0 /\ l <= level'0 self
      end
  
  function to_pair'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 131 4 131 41] (self : Assign'0.t_assign) : (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span23] match self with
      | Assign'0.C_Decision t val' -> (t, val')
      | Assign'0.C_Input t val' -> (t, val')
      | Assign'0.C_Justified _ t val' -> (t, val')
      end
  
  use Core_Option_Option_Type as Option'0
  
  function find'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 471 4 471 64] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Option'0.t_option (Assign'0.t_assign, int)
    
   =
    [%#span27] match self with
      | Trail'0.C_Empty -> Option'0.C_None
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then Option'0.C_Some (a, l) else find'0 tl d
      end
  
  axiom find'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span26] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)))
  && ([%#span25] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
  && ([%#span24] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
  
  function level_of'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 408 4 408 50] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : int
    
   =
    [%#span30] match find'0 self d with
      | Option'0.C_Some (_, l) -> l
      | Option'0.C_None -> 0
      end
  
  axiom level_of'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span28] invariant_nonneg'0 self)
   -> ([%#span29] level_of'0 self d >= 0 /\ level_of'0 self d <= level'0 self)
  
  use set.Fset
  
  use set.Fset
  
  function remove'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (a : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span31] Fset.remove a self
  
  use set.Fset
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (e : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span32] Fset.mem e self
  
  function set_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 287 4 287 57] (self : Trail'0.t_trail) (s : Fset.fset (Term'0.t_term, Value'0.t_value)) : int
    
  
  axiom set_level'0_def : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . set_level'0 self s
  = ([%#span33] if Fset.cardinal s = 0 then
    0
  else
    if Fset.cardinal s = 1 then
      level_of'0 self (Fset.pick s)
    else
      let a = Fset.pick s in let rec' = set_level'0 self (remove'0 s a) in if level_of'0 self a >= rec' then
        level_of'0 self a
      else
        rec'
      
    
  )
  
  axiom set_level'0_spec : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . ([%#stheory5] invariant_nonneg'0 self)
   -> ([%#stheory10] set_level'0 self s <= level'0 self)
  && ([%#stheory9] set_level'0 self s >= 0)
  && ([%#stheory8] s = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))  -> set_level'0 self s = 0)
  && ([%#stheory7] s <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
   -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'0 s i /\ level_of'0 self i = set_level'0 self s))
  && ([%#stheory6] forall i : (Term'0.t_term, Value'0.t_value) . contains'0 s i
   -> level_of'0 self i <= set_level'0 self s)
  
  use prelude.prelude.Real
  
  function from_int'0 (_1 : int) : Real.real
  
  function interp'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 167 4 167 41] (self : Model'0.t_model) (t : Term'0.t_term) : Value'0.t_value
    
   =
    [%#span36] match t with
      | Term'0.C_Variable v -> Map.get (Cdsat_Theory_Model_Type.model_0 self) v
      | Term'0.C_Value v -> v
      | Term'0.C_Plus l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Rat r1, Value'0.C_Rat r2) -> Value'0.C_Rat r1
        | _ -> Value'0.C_Rat (from_int'0 (- 1))
        end
      | Term'0.C_Conj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 /\ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Disj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 \/ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Eq l r -> Value'0.C_Bool (interp'0 self l = interp'0 self r)
      | Term'0.C_Neg t -> match interp'0 self t with
        | Value'0.C_Bool b -> Value'0.C_Bool (not b)
        | _ -> Value'0.C_Bool false
        end
      end
  
  axiom interp'0_spec : forall self : Model'0.t_model, t : Term'0.t_term . ([%#span34] inv'0 self)
   -> ([%#span35] invariant'2 self  -> sort'1 (interp'0 self t) = sort'0 t)
  
  predicate satisfies'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 193 4 193 52] (self : Model'0.t_model) (v : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span37] interp'0 self (let (a, _) = v in a) = (let (_, a) = v in a)
  
  predicate satisfy_set'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 199 4 199 60] (self : Model'0.t_model) (v : Fset.fset (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span38] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 v a  -> satisfies'0 self a
  
  predicate contains'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 418 4 418 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span39] match find'0 self d with
      | Option'0.C_Some ix -> true
      | Option'0.C_None -> false
      end
  
  axiom contains'1_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . [%#stheory3] invariant_assign'0 self
   -> contains'1 self d = true  -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)
  
  use Cdsat_Theory_Normal_Type as Normal'0
  
  predicate satisfied_by'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 677 4 677 47] (self : Trail'0.t_trail) (m : Model'0.t_model)
    
   =
    [%#span40] forall a : (Term'0.t_term, Value'0.t_value) . contains'1 self a  -> satisfies'0 m a
  
  predicate is_bool'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 81 4 81 32] (self : Value'0.t_value) =
    [%#span41] sort'1 self = Sort'0.C_Boolean
  
  function negate'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 98 4 98 31] (self : Value'0.t_value) : Value'0.t_value =
    [%#span44] match self with
      | Value'0.C_Bool b -> Value'0.C_Bool (not b)
      | _ -> self
      end
  
  axiom negate'0_spec : forall self : Value'0.t_value . ([%#span42] is_bool'0 self)
   -> ([%#span43] is_bool'0 (negate'0 self))
  
  predicate trail_unique'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 373 4 373 37] (self : Trail'0.t_trail) =
    [%#span45] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> let ap = to_pair'0 a in not contains'1 tl ap
      /\ trail_unique'0 tl
      /\ (if is_bool'0 (let (_, a) = ap in a) then
        not contains'1 tl ((let (a, _) = ap in a), negate'0 (let (_, a) = ap in a))
      else
        true
      )
      end
  
  predicate invariant_contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 354 4 354 43] (self : Trail'0.t_trail) =
    [%#span46] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_contains'0 tl
      /\ match a with
        | Assign'0.C_Justified j _ _ -> forall a : (Term'0.t_term, Value'0.t_value) . contains'0 j a  -> contains'1 tl a
        | _ -> true
        end
      end
  
  predicate invariant_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 320 4 320 40] (self : Trail'0.t_trail) =
    [%#span47] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_level'0 tl
      /\ match a with
        | Assign'0.C_Input _ _ -> l = 0
        | Assign'0.C_Decision _ _ -> level'0 tl + 1 = l
        | Assign'0.C_Justified j _ _ -> set_level'0 tl j = l
        end
      end
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 387 4 387 34] (self : Trail'0.t_trail) =
    [%#span48] invariant_level'0 self
    /\ invariant_contains'0 self /\ trail_unique'0 self /\ invariant_nonneg'0 self /\ invariant_assign'0 self
  
  function count_bounds'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 743 4 743 35] (self : Trail'0.t_trail) : () =
    [%#span51] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign (Assign'0.C_Input _ _) _ tl -> count_bounds'0 tl
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> count_bounds'0 tl
      | Trail'0.C_Assign (Assign'0.C_Justified _ _ _) _ tl -> count_bounds'0 tl
      end
  
  axiom count_bounds'0_spec : forall self : Trail'0.t_trail . ([%#span49] invariant'0 self)
   -> ([%#span50] forall a : (Term'0.t_term, Value'0.t_value) . contains'1 self a  -> level_of'0 self a <= level'0 self)
  
  function restrict'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 561 4 561 45] (self : Trail'0.t_trail) (level : int) : Trail'0.t_trail
    
   =
    [%#span52] match self with
      | Trail'0.C_Empty -> Trail'0.C_Empty
      | Trail'0.C_Assign a l tl -> let tl = restrict'0 tl level in let _ = count_bounds'0 tl in if l <= level then
        Trail'0.C_Assign a l tl
      else
        tl
      
      end
  
  predicate unsat'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 684 4 684 30] (self : Trail'0.t_trail) =
    [%#span53] forall m : Model'0.t_model . inv'0 m  -> satisfied_by'0 (restrict'0 self 0) m  -> false
  
  predicate justified_sound'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 141 4 141 40] (self : Assign'0.t_assign) =
    [%#span54] match self with
      | Assign'0.C_Justified just t val' -> forall m : Model'0.t_model . inv'0 m
       -> satisfy_set'0 m just  -> satisfies'0 m (t, val')
      | _ -> true
      end
  
  predicate sound'1 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 261 4 261 30] (self : Trail'0.t_trail)
   =
    [%#span55] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a _ tl -> sound'1 tl /\ justified_sound'0 a
      end
  
  use Cdsat_Theory_Normal_Type as Cdsat_Theory_Normal_Type
  
  predicate sound'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 829 4 829 30] (self : Normal'0.t_normal)
    
   =
    [%#span56] sound'1 (Cdsat_Theory_Normal_Type.normal_0 self)
  
  constant self  : Normal'0.t_normal
  
  constant just  : Fset.fset (Term'0.t_term, Value'0.t_value)
  
  predicate fail2 [#"/Users/xavier/Code/cdsat/src/theory.rs" 933 4 933 57] (self : Normal'0.t_normal) (just : Fset.fset (Term'0.t_term, Value'0.t_value))
    
  
  goal vc_fail2 : ([%#stheory1] sound'0 self)
   -> ([%#stheory0] invariant'0 (Cdsat_Theory_Normal_Type.normal_0 self))
   -> (if [%#stheory4] forall j : (Term'0.t_term, Value'0.t_value) . contains'0 just j
   -> contains'1 (Cdsat_Theory_Normal_Type.normal_0 self) j then
    if [%#stheory4] forall m : Model'0.t_model . inv'0 m  -> satisfy_set'0 m just  -> false then
      ([%#stheory5] invariant_nonneg'0 (Cdsat_Theory_Normal_Type.normal_0 self))
      /\ (([%#stheory10] set_level'0 (Cdsat_Theory_Normal_Type.normal_0 self) just
      <= level'0 (Cdsat_Theory_Normal_Type.normal_0 self))
      && ([%#stheory9] set_level'0 (Cdsat_Theory_Normal_Type.normal_0 self) just >= 0)
      && ([%#stheory8] just = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
       -> set_level'0 (Cdsat_Theory_Normal_Type.normal_0 self) just = 0)
      && ([%#stheory7] just <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
       -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'0 just i
      /\ level_of'0 (Cdsat_Theory_Normal_Type.normal_0 self) i
      = set_level'0 (Cdsat_Theory_Normal_Type.normal_0 self) just))
      && ([%#stheory6] forall i : (Term'0.t_term, Value'0.t_value) . contains'0 just i
       -> level_of'0 (Cdsat_Theory_Normal_Type.normal_0 self) i
      <= set_level'0 (Cdsat_Theory_Normal_Type.normal_0 self) just)
       -> ([%#stheory2] set_level'0 (Cdsat_Theory_Normal_Type.normal_0 self) just = 0
       -> unsat'0 (Cdsat_Theory_Normal_Type.normal_0 self)))
    else
      [%#stheory2] false  -> unsat'0 (Cdsat_Theory_Normal_Type.normal_0 self)
    
  else
    [%#stheory2] false  -> unsat'0 (Cdsat_Theory_Normal_Type.normal_0 self)
  )
end
module Cdsat_Theory_Impl6_ConflictSolve_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 947 15 947 35
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 948 15 948 27
  
  let%span stheory2 = "/Users/xavier/Code/cdsat/src/theory.rs" 949 4 949 33
  
  let%span stheory3 = "/Users/xavier/Code/cdsat/src/theory.rs" 950 4 950 46
  
  let%span stheory4 = "/Users/xavier/Code/cdsat/src/theory.rs" 951 4 951 38
  
  let%span stheory5 = "/Users/xavier/Code/cdsat/src/theory.rs" 952 4 952 46
  
  let%span stheory6 = "/Users/xavier/Code/cdsat/src/theory.rs" 96 15 96 29
  
  let%span stheory7 = "/Users/xavier/Code/cdsat/src/theory.rs" 97 14 97 30
  
  let%span stheory8 = "/Users/xavier/Code/cdsat/src/theory.rs" 417 4 417 87
  
  let%span stheory9 = "/Users/xavier/Code/cdsat/src/theory.rs" 954 8 964 11
  
  let%span stheory10 = "/Users/xavier/Code/cdsat/src/theory.rs" 281 15 281 38
  
  let%span stheory11 = "/Users/xavier/Code/cdsat/src/theory.rs" 282 4 282 74
  
  let%span stheory12 = "/Users/xavier/Code/cdsat/src/theory.rs" 283 4 283 94
  
  let%span stheory13 = "/Users/xavier/Code/cdsat/src/theory.rs" 284 4 284 48
  
  let%span stheory14 = "/Users/xavier/Code/cdsat/src/theory.rs" 285 14 285 25
  
  let%span stheory15 = "/Users/xavier/Code/cdsat/src/theory.rs" 286 14 286 36
  
  let%span stheory16 = "/Users/xavier/Code/cdsat/src/theory.rs" 280 14 280 21
  
  let%span span17 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span18 = "/Users/xavier/Code/cdsat/src/theory.rs" 157 8 159 9
  
  let%span span19 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span20 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  let%span span21 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span span22 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span23 = "/Users/xavier/Code/cdsat/src/theory.rs" 601 8 605 9
  
  let%span span24 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span25 = "/Users/xavier/Code/cdsat/src/theory.rs" 122 8 126 9
  
  let%span span26 = "/Users/xavier/Code/cdsat/src/theory.rs" 346 8 349 9
  
  let%span span27 = "/Users/xavier/Code/cdsat/src/theory.rs" 337 8 340 9
  
  let%span span28 = "/Users/xavier/Code/cdsat/src/theory.rs" 132 8 136 9
  
  let%span span29 = "/Users/xavier/Code/cdsat/src/theory.rs" 465 14 468 5
  
  let%span span30 = "/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 111
  
  let%span span31 = "/Users/xavier/Code/cdsat/src/theory.rs" 470 4 470 104
  
  let%span span32 = "/Users/xavier/Code/cdsat/src/theory.rs" 472 8 481 9
  
  let%span span33 = "/Users/xavier/Code/cdsat/src/theory.rs" 406 15 406 38
  
  let%span span34 = "/Users/xavier/Code/cdsat/src/theory.rs" 407 14 407 51
  
  let%span span35 = "/Users/xavier/Code/cdsat/src/theory.rs" 409 8 412 9
  
  let%span span36 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 53 8 53 26
  
  let%span span37 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 16 8 16 26
  
  let%span span38 = "/Users/xavier/Code/cdsat/src/theory.rs" 278 4 278 12
  
  let%span span39 = "/Users/xavier/Code/cdsat/src/theory.rs" 167 18 167 22
  
  let%span span40 = "/Users/xavier/Code/cdsat/src/theory.rs" 166 4 166 62
  
  let%span span41 = "/Users/xavier/Code/cdsat/src/theory.rs" 168 8 188 9
  
  let%span span42 = "/Users/xavier/Code/cdsat/src/theory.rs" 194 8 194 31
  
  let%span span43 = "/Users/xavier/Code/cdsat/src/theory.rs" 200 8 200 71
  
  let%span span44 = "/Users/xavier/Code/cdsat/src/theory.rs" 206 8 206 84
  
  let%span span45 = "/Users/xavier/Code/cdsat/src/theory.rs" 419 8 422 9
  
  let%span span46 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 31 8 31 26
  
  let%span span47 = "/Users/xavier/Code/cdsat/src/theory.rs" 82 8 82 36
  
  let%span span48 = "/Users/xavier/Code/cdsat/src/theory.rs" 99 8 102 9
  
  let%span span49 = "/Users/xavier/Code/cdsat/src/theory.rs" 678 8 678 71
  
  let%span span50 = "/Users/xavier/Code/cdsat/src/theory.rs" 374 8 382 9
  
  let%span span51 = "/Users/xavier/Code/cdsat/src/theory.rs" 355 8 368 9
  
  let%span span52 = "/Users/xavier/Code/cdsat/src/theory.rs" 321 8 331 9
  
  let%span span53 = "/Users/xavier/Code/cdsat/src/theory.rs" 388 8 392 38
  
  let%span span54 = "/Users/xavier/Code/cdsat/src/theory.rs" 741 15 741 31
  
  let%span span55 = "/Users/xavier/Code/cdsat/src/theory.rs" 742 4 742 83
  
  let%span span56 = "/Users/xavier/Code/cdsat/src/theory.rs" 744 8 749 9
  
  let%span span57 = "/Users/xavier/Code/cdsat/src/theory.rs" 562 8 573 9
  
  let%span span58 = "/Users/xavier/Code/cdsat/src/theory.rs" 685 8 685 82
  
  let%span span59 = "/Users/xavier/Code/cdsat/src/theory.rs" 696 4 696 55
  
  let%span span60 = "/Users/xavier/Code/cdsat/src/theory.rs" 698 8 698 108
  
  let%span span61 = "/Users/xavier/Code/cdsat/src/theory.rs" 142 8 147 9
  
  let%span span62 = "/Users/xavier/Code/cdsat/src/theory.rs" 262 8 265 9
  
  let%span span63 = "/Users/xavier/Code/cdsat/src/theory.rs" 999 8 999 91
  
  let%span span64 = "/Users/xavier/Code/cdsat/src/theory.rs" 826 4 826 16
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  use Cdsat_Theory_Value_Type as Value'0
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span17] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  use map.Map
  
  use Cdsat_Theory_Model_Type as Cdsat_Theory_Model_Type
  
  use Cdsat_Theory_Var_Type as Var'0
  
  use Cdsat_Theory_Model_Type as Model'0
  
  predicate invariant'2 [#"/Users/xavier/Code/cdsat/src/theory.rs" 156 4 156 30] (self : Model'0.t_model) =
    [%#span18] forall v : Value'0.t_value . forall k : Var'0.t_var . Map.get (Cdsat_Theory_Model_Type.model_0 self) k
    = v  -> Cdsat_Theory_Var_Type.var_1 k = sort'1 v
  
  predicate inv'0 (_x : Model'0.t_model)
  
  axiom inv'0 : forall x : Model'0.t_model . inv'0 x
  = (invariant'2 x
  /\ match x with
    | Model'0.C_Model a_0 -> true
    end)
  
  use set.Fset
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  use prelude.prelude.Int
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span20] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span19] len'0 self >= 0
  
  function level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int =
    [%#span23] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> 1 + level'0 tl
      | Trail'0.C_Assign _ _ tl -> level'0 tl
      end
  
  axiom level'0_spec : forall self : Trail'0.t_trail . ([%#span22] level'0 self <= len'0 self)
  && ([%#span21] level'0 self >= 0)
  
  use set.Fset
  
  use prelude.prelude.Int
  
  use Cdsat_Theory_Term_Type as Term'0
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span24] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'1 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  predicate invariant'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 121 4 121 34] (self : Assign'0.t_assign) =
    [%#span25] match self with
      | Assign'0.C_Decision t v -> sort'0 t = sort'1 v
      | Assign'0.C_Justified _ t v -> sort'0 t = sort'1 v /\ sort'0 t = Sort'0.C_Boolean
      | Assign'0.C_Input t v -> sort'0 t = sort'1 v
      end
  
  predicate invariant_assign'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 345 4 345 41] (self : Trail'0.t_trail) =
    [%#span26] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_assign'0 tl /\ invariant'1 a
      end
  
  predicate invariant_nonneg'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 336 4 336 41] (self : Trail'0.t_trail) =
    [%#span27] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_nonneg'0 tl /\ l >= 0 /\ l <= level'0 self
      end
  
  function to_pair'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 131 4 131 41] (self : Assign'0.t_assign) : (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span28] match self with
      | Assign'0.C_Decision t val' -> (t, val')
      | Assign'0.C_Input t val' -> (t, val')
      | Assign'0.C_Justified _ t val' -> (t, val')
      end
  
  use Core_Option_Option_Type as Option'0
  
  function find'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 471 4 471 64] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Option'0.t_option (Assign'0.t_assign, int)
    
   =
    [%#span32] match self with
      | Trail'0.C_Empty -> Option'0.C_None
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then Option'0.C_Some (a, l) else find'0 tl d
      end
  
  axiom find'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span31] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)))
  && ([%#span30] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
  && ([%#span29] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
  
  function level_of'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 408 4 408 50] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : int
    
   =
    [%#span35] match find'0 self d with
      | Option'0.C_Some (_, l) -> l
      | Option'0.C_None -> 0
      end
  
  axiom level_of'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span33] invariant_nonneg'0 self)
   -> ([%#span34] level_of'0 self d >= 0 /\ level_of'0 self d <= level'0 self)
  
  use set.Fset
  
  use set.Fset
  
  function remove'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (a : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span36] Fset.remove a self
  
  use set.Fset
  
  use set.Fset
  
  predicate contains'1 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (e : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span37] Fset.mem e self
  
  function set_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 287 4 287 57] (self : Trail'0.t_trail) (s : Fset.fset (Term'0.t_term, Value'0.t_value)) : int
    
  
  axiom set_level'0_def : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . set_level'0 self s
  = ([%#span38] if Fset.cardinal s = 0 then
    0
  else
    if Fset.cardinal s = 1 then
      level_of'0 self (Fset.pick s)
    else
      let a = Fset.pick s in let rec' = set_level'0 self (remove'0 s a) in if level_of'0 self a >= rec' then
        level_of'0 self a
      else
        rec'
      
    
  )
  
  axiom set_level'0_spec : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . ([%#stheory10] invariant_nonneg'0 self)
   -> ([%#stheory15] set_level'0 self s <= level'0 self)
  && ([%#stheory14] set_level'0 self s >= 0)
  && ([%#stheory13] s = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))  -> set_level'0 self s = 0)
  && ([%#stheory12] s <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
   -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'1 s i /\ level_of'0 self i = set_level'0 self s))
  && ([%#stheory11] forall i : (Term'0.t_term, Value'0.t_value) . contains'1 s i
   -> level_of'0 self i <= set_level'0 self s)
  
  use prelude.prelude.Real
  
  function from_int'0 (_1 : int) : Real.real
  
  function interp'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 167 4 167 41] (self : Model'0.t_model) (t : Term'0.t_term) : Value'0.t_value
    
   =
    [%#span41] match t with
      | Term'0.C_Variable v -> Map.get (Cdsat_Theory_Model_Type.model_0 self) v
      | Term'0.C_Value v -> v
      | Term'0.C_Plus l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Rat r1, Value'0.C_Rat r2) -> Value'0.C_Rat r1
        | _ -> Value'0.C_Rat (from_int'0 (- 1))
        end
      | Term'0.C_Conj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 /\ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Disj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 \/ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Eq l r -> Value'0.C_Bool (interp'0 self l = interp'0 self r)
      | Term'0.C_Neg t -> match interp'0 self t with
        | Value'0.C_Bool b -> Value'0.C_Bool (not b)
        | _ -> Value'0.C_Bool false
        end
      end
  
  axiom interp'0_spec : forall self : Model'0.t_model, t : Term'0.t_term . ([%#span39] inv'0 self)
   -> ([%#span40] invariant'2 self  -> sort'1 (interp'0 self t) = sort'0 t)
  
  predicate satisfies'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 193 4 193 52] (self : Model'0.t_model) (v : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span42] interp'0 self (let (a, _) = v in a) = (let (_, a) = v in a)
  
  predicate satisfy_set'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 199 4 199 60] (self : Model'0.t_model) (v : Fset.fset (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span43] forall a : (Term'0.t_term, Value'0.t_value) . contains'1 v a  -> satisfies'0 self a
  
  predicate entails'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 205 4 205 74] (self : Model'0.t_model) (j : Fset.fset (Term'0.t_term, Value'0.t_value)) (c : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span44] invariant'2 self  -> satisfy_set'0 self j  -> satisfies'0 self c
  
  predicate contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 418 4 418 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span45] match find'0 self d with
      | Option'0.C_Some ix -> true
      | Option'0.C_None -> false
      end
  
  axiom contains'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . [%#stheory8] invariant_assign'0 self
   -> contains'0 self d = true  -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)
  
  use set.Fset
  
  function insert'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (e : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span46] Fset.add e self
  
  predicate is_bool'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 81 4 81 32] (self : Value'0.t_value) =
    [%#span47] sort'1 self = Sort'0.C_Boolean
  
  function negate'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 98 4 98 31] (self : Value'0.t_value) : Value'0.t_value =
    [%#span48] match self with
      | Value'0.C_Bool b -> Value'0.C_Bool (not b)
      | _ -> self
      end
  
  axiom negate'0_spec : forall self : Value'0.t_value . ([%#stheory6] is_bool'0 self)
   -> ([%#stheory7] is_bool'0 (negate'0 self))
  
  use Cdsat_Theory_Conflict_Type as Conflict'0
  
  use Cdsat_Theory_Normal_Type as Normal'0
  
  predicate satisfied_by'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 677 4 677 47] (self : Trail'0.t_trail) (m : Model'0.t_model)
    
   =
    [%#span49] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 self a  -> satisfies'0 m a
  
  predicate trail_unique'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 373 4 373 37] (self : Trail'0.t_trail) =
    [%#span50] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> let ap = to_pair'0 a in not contains'0 tl ap
      /\ trail_unique'0 tl
      /\ (if is_bool'0 (let (_, a) = ap in a) then
        not contains'0 tl ((let (a, _) = ap in a), negate'0 (let (_, a) = ap in a))
      else
        true
      )
      end
  
  predicate invariant_contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 354 4 354 43] (self : Trail'0.t_trail) =
    [%#span51] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_contains'0 tl
      /\ match a with
        | Assign'0.C_Justified j _ _ -> forall a : (Term'0.t_term, Value'0.t_value) . contains'1 j a  -> contains'0 tl a
        | _ -> true
        end
      end
  
  predicate invariant_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 320 4 320 40] (self : Trail'0.t_trail) =
    [%#span52] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_level'0 tl
      /\ match a with
        | Assign'0.C_Input _ _ -> l = 0
        | Assign'0.C_Decision _ _ -> level'0 tl + 1 = l
        | Assign'0.C_Justified j _ _ -> set_level'0 tl j = l
        end
      end
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 387 4 387 34] (self : Trail'0.t_trail) =
    [%#span53] invariant_level'0 self
    /\ invariant_contains'0 self /\ trail_unique'0 self /\ invariant_nonneg'0 self /\ invariant_assign'0 self
  
  function count_bounds'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 743 4 743 35] (self : Trail'0.t_trail) : () =
    [%#span56] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign (Assign'0.C_Input _ _) _ tl -> count_bounds'0 tl
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> count_bounds'0 tl
      | Trail'0.C_Assign (Assign'0.C_Justified _ _ _) _ tl -> count_bounds'0 tl
      end
  
  axiom count_bounds'0_spec : forall self : Trail'0.t_trail . ([%#span54] invariant'0 self)
   -> ([%#span55] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 self a  -> level_of'0 self a <= level'0 self)
  
  function restrict'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 561 4 561 45] (self : Trail'0.t_trail) (level : int) : Trail'0.t_trail
    
   =
    [%#span57] match self with
      | Trail'0.C_Empty -> Trail'0.C_Empty
      | Trail'0.C_Assign a l tl -> let tl = restrict'0 tl level in let _ = count_bounds'0 tl in if l <= level then
        Trail'0.C_Assign a l tl
      else
        tl
      
      end
  
  predicate unsat'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 684 4 684 30] (self : Trail'0.t_trail) =
    [%#span58] forall m : Model'0.t_model . inv'0 m  -> satisfied_by'0 (restrict'0 self 0) m  -> false
  
  predicate impls'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 697 4 697 41] (self : Trail'0.t_trail) (rhs : Trail'0.t_trail)
    
   =
    [%#span60] forall m : Model'0.t_model . inv'0 m
     -> satisfied_by'0 (restrict'0 self 0) m  -> satisfied_by'0 (restrict'0 rhs 0) m
  
  axiom impls'0_spec : forall self : Trail'0.t_trail, rhs : Trail'0.t_trail . [%#span59] impls'0 self rhs
   -> unsat'0 rhs  -> unsat'0 self
  
  use Cdsat_Theory_Conflict_Type as Cdsat_Theory_Conflict_Type
  
  predicate justified_sound'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 141 4 141 40] (self : Assign'0.t_assign) =
    [%#span61] match self with
      | Assign'0.C_Justified just t val' -> forall m : Model'0.t_model . inv'0 m
       -> satisfy_set'0 m just  -> satisfies'0 m (t, val')
      | _ -> true
      end
  
  predicate sound'2 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 261 4 261 30] (self : Trail'0.t_trail)
   =
    [%#span62] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a _ tl -> sound'2 tl /\ justified_sound'0 a
      end
  
  predicate sound'1 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 998 4 998 30] (self : Conflict'0.t_conflict)
    
   =
    [%#span63] sound'2 (Cdsat_Theory_Conflict_Type.conflict_0 self)
    /\ (forall m : Model'0.t_model . inv'0 m  -> satisfy_set'0 m (Cdsat_Theory_Conflict_Type.conflict_1 self)  -> false)
  
  use Cdsat_Theory_Normal_Type as Cdsat_Theory_Normal_Type
  
  predicate sound'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 829 4 829 30] (self : Normal'0.t_normal)
    
   =
    [%#span64] sound'2 (Cdsat_Theory_Normal_Type.normal_0 self)
  
  constant self  : Normal'0.t_normal
  
  constant just  : (Fset.fset (Term'0.t_term, Value'0.t_value), Term'0.t_term, Value'0.t_value)
  
  constant tgt  : Conflict'0.t_conflict
  
  predicate conflict_solve [#"/Users/xavier/Code/cdsat/src/theory.rs" 953 4 953 96] (self : Normal'0.t_normal) (just : (Fset.fset (Term'0.t_term, Value'0.t_value), Term'0.t_term, Value'0.t_value)) (tgt : Conflict'0.t_conflict)
    
  
  goal vc_conflict_solve : ([%#stheory2] is_bool'0 (let (_, _, a) = just in a))
   -> ([%#stheory1] sound'0 self)
   -> ([%#stheory0] invariant'0 (Cdsat_Theory_Normal_Type.normal_0 self))
   -> ([%#stheory6] is_bool'0 (let (_, _, a) = just in a))
  /\ (([%#stheory7] is_bool'0 (negate'0 (let (_, _, a) = just in a)))
   -> (let not_l = ((let (_, a, _) = just in a), negate'0 (let (_, _, a) = just in a)) in let conflict = insert'0 (let (a, _, _) = just in a) not_l in ([%#stheory8] invariant_assign'0 (Cdsat_Theory_Normal_Type.normal_0 self)
   -> contains'0 (Cdsat_Theory_Normal_Type.normal_0 self) not_l = true
   -> sort'0 (let (a, _) = not_l in a) = sort'1 (let (_, a) = not_l in a))
   -> (if contains'0 (Cdsat_Theory_Normal_Type.normal_0 self) not_l then
    if [%#stheory9] forall j : (Term'0.t_term, Value'0.t_value) . contains'1 (let (a, _, _) = just in a) j
     -> contains'0 (Cdsat_Theory_Normal_Type.normal_0 self) j then
      ([%#stheory8] invariant_assign'0 (Cdsat_Theory_Normal_Type.normal_0 self)
       -> contains'0 (Cdsat_Theory_Normal_Type.normal_0 self) ((let (_, a, _) = just in a), (let (_, _, a) = just in a))
      = true
       -> sort'0 (let (a, _) = ((let (_, a, _) = just in a), (let (_, _, a) = just in a)) in a)
      = sort'1 (let (_, a) = ((let (_, a, _) = just in a), (let (_, _, a) = just in a)) in a))
       -> (if not contains'0 (Cdsat_Theory_Normal_Type.normal_0 self) ((let (_, a, _) = just in a), (let (_, _, a) = just in a)) then
        if [%#stheory9] forall m : Model'0.t_model . inv'0 m
         -> entails'0 m (let (a, _, _) = just in a) ((let (_, a, _) = just in a), (let (_, _, a) = just in a)) then
          ([%#stheory10] invariant_nonneg'0 (Cdsat_Theory_Normal_Type.normal_0 self))
          /\ (([%#stheory15] set_level'0 (Cdsat_Theory_Normal_Type.normal_0 self) conflict
          <= level'0 (Cdsat_Theory_Normal_Type.normal_0 self))
          && ([%#stheory14] set_level'0 (Cdsat_Theory_Normal_Type.normal_0 self) conflict >= 0)
          && ([%#stheory13] conflict = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
           -> set_level'0 (Cdsat_Theory_Normal_Type.normal_0 self) conflict = 0)
          && ([%#stheory12] conflict <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
           -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'1 conflict i
          /\ level_of'0 (Cdsat_Theory_Normal_Type.normal_0 self) i
          = set_level'0 (Cdsat_Theory_Normal_Type.normal_0 self) conflict))
          && ([%#stheory11] forall i : (Term'0.t_term, Value'0.t_value) . contains'1 conflict i
           -> level_of'0 (Cdsat_Theory_Normal_Type.normal_0 self) i
          <= set_level'0 (Cdsat_Theory_Normal_Type.normal_0 self) conflict)
           -> (if set_level'0 (Cdsat_Theory_Normal_Type.normal_0 self) conflict > 0 then
            let result = tgt
            = Conflict'0.C_Conflict (Cdsat_Theory_Normal_Type.normal_0 self) conflict in ([%#stheory5] result
             -> impls'0 (Cdsat_Theory_Normal_Type.normal_0 self) (Cdsat_Theory_Conflict_Type.conflict_0 tgt))
            && ([%#stheory4] result  -> sound'1 tgt)
            && ([%#stheory3] result  -> invariant'0 (Cdsat_Theory_Conflict_Type.conflict_0 tgt))
          else
            let result = false in ([%#stheory5] result
             -> impls'0 (Cdsat_Theory_Normal_Type.normal_0 self) (Cdsat_Theory_Conflict_Type.conflict_0 tgt))
            && ([%#stheory4] result  -> sound'1 tgt)
            && ([%#stheory3] result  -> invariant'0 (Cdsat_Theory_Conflict_Type.conflict_0 tgt))
          ))
        else
          let result = false in ([%#stheory5] result
           -> impls'0 (Cdsat_Theory_Normal_Type.normal_0 self) (Cdsat_Theory_Conflict_Type.conflict_0 tgt))
          && ([%#stheory4] result  -> sound'1 tgt)
          && ([%#stheory3] result  -> invariant'0 (Cdsat_Theory_Conflict_Type.conflict_0 tgt))
        
      else
        let result = false in ([%#stheory5] result
         -> impls'0 (Cdsat_Theory_Normal_Type.normal_0 self) (Cdsat_Theory_Conflict_Type.conflict_0 tgt))
        && ([%#stheory4] result  -> sound'1 tgt)
        && ([%#stheory3] result  -> invariant'0 (Cdsat_Theory_Conflict_Type.conflict_0 tgt))
      )
    else
      let result = false in ([%#stheory5] result
       -> impls'0 (Cdsat_Theory_Normal_Type.normal_0 self) (Cdsat_Theory_Conflict_Type.conflict_0 tgt))
      && ([%#stheory4] result  -> sound'1 tgt)
      && ([%#stheory3] result  -> invariant'0 (Cdsat_Theory_Conflict_Type.conflict_0 tgt))
    
  else
    let result = false in ([%#stheory5] result
     -> impls'0 (Cdsat_Theory_Normal_Type.normal_0 self) (Cdsat_Theory_Conflict_Type.conflict_0 tgt))
    && ([%#stheory4] result  -> sound'1 tgt)
    && ([%#stheory3] result  -> invariant'0 (Cdsat_Theory_Conflict_Type.conflict_0 tgt))
  )))
end
module Cdsat_Theory_Impl6_ConflictSolve2_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 971 15 971 35
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 972 15 972 27
  
  let%span stheory2 = "/Users/xavier/Code/cdsat/src/theory.rs" 973 4 973 46
  
  let%span stheory3 = "/Users/xavier/Code/cdsat/src/theory.rs" 974 4 974 38
  
  let%span stheory4 = "/Users/xavier/Code/cdsat/src/theory.rs" 975 4 975 46
  
  let%span stheory5 = "/Users/xavier/Code/cdsat/src/theory.rs" 417 4 417 87
  
  let%span stheory6 = "/Users/xavier/Code/cdsat/src/theory.rs" 977 8 982 11
  
  let%span stheory7 = "/Users/xavier/Code/cdsat/src/theory.rs" 281 15 281 38
  
  let%span stheory8 = "/Users/xavier/Code/cdsat/src/theory.rs" 282 4 282 74
  
  let%span stheory9 = "/Users/xavier/Code/cdsat/src/theory.rs" 283 4 283 94
  
  let%span stheory10 = "/Users/xavier/Code/cdsat/src/theory.rs" 284 4 284 48
  
  let%span stheory11 = "/Users/xavier/Code/cdsat/src/theory.rs" 285 14 285 25
  
  let%span stheory12 = "/Users/xavier/Code/cdsat/src/theory.rs" 286 14 286 36
  
  let%span stheory13 = "/Users/xavier/Code/cdsat/src/theory.rs" 280 14 280 21
  
  let%span span14 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span15 = "/Users/xavier/Code/cdsat/src/theory.rs" 157 8 159 9
  
  let%span span16 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span17 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  let%span span18 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span span19 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span20 = "/Users/xavier/Code/cdsat/src/theory.rs" 601 8 605 9
  
  let%span span21 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span22 = "/Users/xavier/Code/cdsat/src/theory.rs" 122 8 126 9
  
  let%span span23 = "/Users/xavier/Code/cdsat/src/theory.rs" 346 8 349 9
  
  let%span span24 = "/Users/xavier/Code/cdsat/src/theory.rs" 337 8 340 9
  
  let%span span25 = "/Users/xavier/Code/cdsat/src/theory.rs" 132 8 136 9
  
  let%span span26 = "/Users/xavier/Code/cdsat/src/theory.rs" 465 14 468 5
  
  let%span span27 = "/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 111
  
  let%span span28 = "/Users/xavier/Code/cdsat/src/theory.rs" 470 4 470 104
  
  let%span span29 = "/Users/xavier/Code/cdsat/src/theory.rs" 472 8 481 9
  
  let%span span30 = "/Users/xavier/Code/cdsat/src/theory.rs" 406 15 406 38
  
  let%span span31 = "/Users/xavier/Code/cdsat/src/theory.rs" 407 14 407 51
  
  let%span span32 = "/Users/xavier/Code/cdsat/src/theory.rs" 409 8 412 9
  
  let%span span33 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 53 8 53 26
  
  let%span span34 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 16 8 16 26
  
  let%span span35 = "/Users/xavier/Code/cdsat/src/theory.rs" 278 4 278 12
  
  let%span span36 = "/Users/xavier/Code/cdsat/src/theory.rs" 167 18 167 22
  
  let%span span37 = "/Users/xavier/Code/cdsat/src/theory.rs" 166 4 166 62
  
  let%span span38 = "/Users/xavier/Code/cdsat/src/theory.rs" 168 8 188 9
  
  let%span span39 = "/Users/xavier/Code/cdsat/src/theory.rs" 194 8 194 31
  
  let%span span40 = "/Users/xavier/Code/cdsat/src/theory.rs" 200 8 200 71
  
  let%span span41 = "/Users/xavier/Code/cdsat/src/theory.rs" 419 8 422 9
  
  let%span span42 = "/Users/xavier/Code/cdsat/src/theory.rs" 678 8 678 71
  
  let%span span43 = "/Users/xavier/Code/cdsat/src/theory.rs" 82 8 82 36
  
  let%span span44 = "/Users/xavier/Code/cdsat/src/theory.rs" 96 15 96 29
  
  let%span span45 = "/Users/xavier/Code/cdsat/src/theory.rs" 97 14 97 30
  
  let%span span46 = "/Users/xavier/Code/cdsat/src/theory.rs" 99 8 102 9
  
  let%span span47 = "/Users/xavier/Code/cdsat/src/theory.rs" 374 8 382 9
  
  let%span span48 = "/Users/xavier/Code/cdsat/src/theory.rs" 355 8 368 9
  
  let%span span49 = "/Users/xavier/Code/cdsat/src/theory.rs" 321 8 331 9
  
  let%span span50 = "/Users/xavier/Code/cdsat/src/theory.rs" 388 8 392 38
  
  let%span span51 = "/Users/xavier/Code/cdsat/src/theory.rs" 741 15 741 31
  
  let%span span52 = "/Users/xavier/Code/cdsat/src/theory.rs" 742 4 742 83
  
  let%span span53 = "/Users/xavier/Code/cdsat/src/theory.rs" 744 8 749 9
  
  let%span span54 = "/Users/xavier/Code/cdsat/src/theory.rs" 562 8 573 9
  
  let%span span55 = "/Users/xavier/Code/cdsat/src/theory.rs" 685 8 685 82
  
  let%span span56 = "/Users/xavier/Code/cdsat/src/theory.rs" 696 4 696 55
  
  let%span span57 = "/Users/xavier/Code/cdsat/src/theory.rs" 698 8 698 108
  
  let%span span58 = "/Users/xavier/Code/cdsat/src/theory.rs" 142 8 147 9
  
  let%span span59 = "/Users/xavier/Code/cdsat/src/theory.rs" 262 8 265 9
  
  let%span span60 = "/Users/xavier/Code/cdsat/src/theory.rs" 999 8 999 91
  
  let%span span61 = "/Users/xavier/Code/cdsat/src/theory.rs" 826 4 826 16
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  use Cdsat_Theory_Value_Type as Value'0
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span14] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  use map.Map
  
  use Cdsat_Theory_Model_Type as Cdsat_Theory_Model_Type
  
  use Cdsat_Theory_Var_Type as Var'0
  
  use Cdsat_Theory_Model_Type as Model'0
  
  predicate invariant'2 [#"/Users/xavier/Code/cdsat/src/theory.rs" 156 4 156 30] (self : Model'0.t_model) =
    [%#span15] forall v : Value'0.t_value . forall k : Var'0.t_var . Map.get (Cdsat_Theory_Model_Type.model_0 self) k
    = v  -> Cdsat_Theory_Var_Type.var_1 k = sort'1 v
  
  predicate inv'0 (_x : Model'0.t_model)
  
  axiom inv'0 : forall x : Model'0.t_model . inv'0 x
  = (invariant'2 x
  /\ match x with
    | Model'0.C_Model a_0 -> true
    end)
  
  use set.Fset
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  use prelude.prelude.Int
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span17] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span16] len'0 self >= 0
  
  function level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int =
    [%#span20] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> 1 + level'0 tl
      | Trail'0.C_Assign _ _ tl -> level'0 tl
      end
  
  axiom level'0_spec : forall self : Trail'0.t_trail . ([%#span19] level'0 self <= len'0 self)
  && ([%#span18] level'0 self >= 0)
  
  use set.Fset
  
  use prelude.prelude.Int
  
  use Cdsat_Theory_Term_Type as Term'0
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span21] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'1 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  predicate invariant'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 121 4 121 34] (self : Assign'0.t_assign) =
    [%#span22] match self with
      | Assign'0.C_Decision t v -> sort'0 t = sort'1 v
      | Assign'0.C_Justified _ t v -> sort'0 t = sort'1 v /\ sort'0 t = Sort'0.C_Boolean
      | Assign'0.C_Input t v -> sort'0 t = sort'1 v
      end
  
  predicate invariant_assign'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 345 4 345 41] (self : Trail'0.t_trail) =
    [%#span23] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_assign'0 tl /\ invariant'1 a
      end
  
  predicate invariant_nonneg'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 336 4 336 41] (self : Trail'0.t_trail) =
    [%#span24] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_nonneg'0 tl /\ l >= 0 /\ l <= level'0 self
      end
  
  function to_pair'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 131 4 131 41] (self : Assign'0.t_assign) : (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span25] match self with
      | Assign'0.C_Decision t val' -> (t, val')
      | Assign'0.C_Input t val' -> (t, val')
      | Assign'0.C_Justified _ t val' -> (t, val')
      end
  
  use Core_Option_Option_Type as Option'0
  
  function find'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 471 4 471 64] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Option'0.t_option (Assign'0.t_assign, int)
    
   =
    [%#span29] match self with
      | Trail'0.C_Empty -> Option'0.C_None
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then Option'0.C_Some (a, l) else find'0 tl d
      end
  
  axiom find'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span28] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)))
  && ([%#span27] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
  && ([%#span26] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
  
  function level_of'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 408 4 408 50] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : int
    
   =
    [%#span32] match find'0 self d with
      | Option'0.C_Some (_, l) -> l
      | Option'0.C_None -> 0
      end
  
  axiom level_of'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span30] invariant_nonneg'0 self)
   -> ([%#span31] level_of'0 self d >= 0 /\ level_of'0 self d <= level'0 self)
  
  use set.Fset
  
  use set.Fset
  
  function remove'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (a : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span33] Fset.remove a self
  
  use set.Fset
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (e : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span34] Fset.mem e self
  
  function set_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 287 4 287 57] (self : Trail'0.t_trail) (s : Fset.fset (Term'0.t_term, Value'0.t_value)) : int
    
  
  axiom set_level'0_def : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . set_level'0 self s
  = ([%#span35] if Fset.cardinal s = 0 then
    0
  else
    if Fset.cardinal s = 1 then
      level_of'0 self (Fset.pick s)
    else
      let a = Fset.pick s in let rec' = set_level'0 self (remove'0 s a) in if level_of'0 self a >= rec' then
        level_of'0 self a
      else
        rec'
      
    
  )
  
  axiom set_level'0_spec : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . ([%#stheory7] invariant_nonneg'0 self)
   -> ([%#stheory12] set_level'0 self s <= level'0 self)
  && ([%#stheory11] set_level'0 self s >= 0)
  && ([%#stheory10] s = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))  -> set_level'0 self s = 0)
  && ([%#stheory9] s <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
   -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'0 s i /\ level_of'0 self i = set_level'0 self s))
  && ([%#stheory8] forall i : (Term'0.t_term, Value'0.t_value) . contains'0 s i
   -> level_of'0 self i <= set_level'0 self s)
  
  use prelude.prelude.Real
  
  function from_int'0 (_1 : int) : Real.real
  
  function interp'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 167 4 167 41] (self : Model'0.t_model) (t : Term'0.t_term) : Value'0.t_value
    
   =
    [%#span38] match t with
      | Term'0.C_Variable v -> Map.get (Cdsat_Theory_Model_Type.model_0 self) v
      | Term'0.C_Value v -> v
      | Term'0.C_Plus l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Rat r1, Value'0.C_Rat r2) -> Value'0.C_Rat r1
        | _ -> Value'0.C_Rat (from_int'0 (- 1))
        end
      | Term'0.C_Conj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 /\ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Disj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 \/ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Eq l r -> Value'0.C_Bool (interp'0 self l = interp'0 self r)
      | Term'0.C_Neg t -> match interp'0 self t with
        | Value'0.C_Bool b -> Value'0.C_Bool (not b)
        | _ -> Value'0.C_Bool false
        end
      end
  
  axiom interp'0_spec : forall self : Model'0.t_model, t : Term'0.t_term . ([%#span36] inv'0 self)
   -> ([%#span37] invariant'2 self  -> sort'1 (interp'0 self t) = sort'0 t)
  
  predicate satisfies'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 193 4 193 52] (self : Model'0.t_model) (v : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span39] interp'0 self (let (a, _) = v in a) = (let (_, a) = v in a)
  
  predicate satisfy_set'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 199 4 199 60] (self : Model'0.t_model) (v : Fset.fset (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span40] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 v a  -> satisfies'0 self a
  
  predicate contains'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 418 4 418 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span41] match find'0 self d with
      | Option'0.C_Some ix -> true
      | Option'0.C_None -> false
      end
  
  axiom contains'1_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . [%#stheory5] invariant_assign'0 self
   -> contains'1 self d = true  -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)
  
  use Cdsat_Theory_Conflict_Type as Conflict'0
  
  use Cdsat_Theory_Normal_Type as Normal'0
  
  predicate satisfied_by'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 677 4 677 47] (self : Trail'0.t_trail) (m : Model'0.t_model)
    
   =
    [%#span42] forall a : (Term'0.t_term, Value'0.t_value) . contains'1 self a  -> satisfies'0 m a
  
  predicate is_bool'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 81 4 81 32] (self : Value'0.t_value) =
    [%#span43] sort'1 self = Sort'0.C_Boolean
  
  function negate'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 98 4 98 31] (self : Value'0.t_value) : Value'0.t_value =
    [%#span46] match self with
      | Value'0.C_Bool b -> Value'0.C_Bool (not b)
      | _ -> self
      end
  
  axiom negate'0_spec : forall self : Value'0.t_value . ([%#span44] is_bool'0 self)
   -> ([%#span45] is_bool'0 (negate'0 self))
  
  predicate trail_unique'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 373 4 373 37] (self : Trail'0.t_trail) =
    [%#span47] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> let ap = to_pair'0 a in not contains'1 tl ap
      /\ trail_unique'0 tl
      /\ (if is_bool'0 (let (_, a) = ap in a) then
        not contains'1 tl ((let (a, _) = ap in a), negate'0 (let (_, a) = ap in a))
      else
        true
      )
      end
  
  predicate invariant_contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 354 4 354 43] (self : Trail'0.t_trail) =
    [%#span48] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_contains'0 tl
      /\ match a with
        | Assign'0.C_Justified j _ _ -> forall a : (Term'0.t_term, Value'0.t_value) . contains'0 j a  -> contains'1 tl a
        | _ -> true
        end
      end
  
  predicate invariant_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 320 4 320 40] (self : Trail'0.t_trail) =
    [%#span49] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_level'0 tl
      /\ match a with
        | Assign'0.C_Input _ _ -> l = 0
        | Assign'0.C_Decision _ _ -> level'0 tl + 1 = l
        | Assign'0.C_Justified j _ _ -> set_level'0 tl j = l
        end
      end
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 387 4 387 34] (self : Trail'0.t_trail) =
    [%#span50] invariant_level'0 self
    /\ invariant_contains'0 self /\ trail_unique'0 self /\ invariant_nonneg'0 self /\ invariant_assign'0 self
  
  function count_bounds'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 743 4 743 35] (self : Trail'0.t_trail) : () =
    [%#span53] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign (Assign'0.C_Input _ _) _ tl -> count_bounds'0 tl
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> count_bounds'0 tl
      | Trail'0.C_Assign (Assign'0.C_Justified _ _ _) _ tl -> count_bounds'0 tl
      end
  
  axiom count_bounds'0_spec : forall self : Trail'0.t_trail . ([%#span51] invariant'0 self)
   -> ([%#span52] forall a : (Term'0.t_term, Value'0.t_value) . contains'1 self a  -> level_of'0 self a <= level'0 self)
  
  function restrict'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 561 4 561 45] (self : Trail'0.t_trail) (level : int) : Trail'0.t_trail
    
   =
    [%#span54] match self with
      | Trail'0.C_Empty -> Trail'0.C_Empty
      | Trail'0.C_Assign a l tl -> let tl = restrict'0 tl level in let _ = count_bounds'0 tl in if l <= level then
        Trail'0.C_Assign a l tl
      else
        tl
      
      end
  
  predicate unsat'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 684 4 684 30] (self : Trail'0.t_trail) =
    [%#span55] forall m : Model'0.t_model . inv'0 m  -> satisfied_by'0 (restrict'0 self 0) m  -> false
  
  predicate impls'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 697 4 697 41] (self : Trail'0.t_trail) (rhs : Trail'0.t_trail)
    
   =
    [%#span57] forall m : Model'0.t_model . inv'0 m
     -> satisfied_by'0 (restrict'0 self 0) m  -> satisfied_by'0 (restrict'0 rhs 0) m
  
  axiom impls'0_spec : forall self : Trail'0.t_trail, rhs : Trail'0.t_trail . [%#span56] impls'0 self rhs
   -> unsat'0 rhs  -> unsat'0 self
  
  use Cdsat_Theory_Conflict_Type as Cdsat_Theory_Conflict_Type
  
  predicate justified_sound'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 141 4 141 40] (self : Assign'0.t_assign) =
    [%#span58] match self with
      | Assign'0.C_Justified just t val' -> forall m : Model'0.t_model . inv'0 m
       -> satisfy_set'0 m just  -> satisfies'0 m (t, val')
      | _ -> true
      end
  
  predicate sound'2 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 261 4 261 30] (self : Trail'0.t_trail)
   =
    [%#span59] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a _ tl -> sound'2 tl /\ justified_sound'0 a
      end
  
  predicate sound'1 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 998 4 998 30] (self : Conflict'0.t_conflict)
    
   =
    [%#span60] sound'2 (Cdsat_Theory_Conflict_Type.conflict_0 self)
    /\ (forall m : Model'0.t_model . inv'0 m  -> satisfy_set'0 m (Cdsat_Theory_Conflict_Type.conflict_1 self)  -> false)
  
  use Cdsat_Theory_Normal_Type as Cdsat_Theory_Normal_Type
  
  predicate sound'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 829 4 829 30] (self : Normal'0.t_normal)
    
   =
    [%#span61] sound'2 (Cdsat_Theory_Normal_Type.normal_0 self)
  
  constant self  : Normal'0.t_normal
  
  constant conflict  : Fset.fset (Term'0.t_term, Value'0.t_value)
  
  constant tgt  : Conflict'0.t_conflict
  
  predicate conflict_solve2 [#"/Users/xavier/Code/cdsat/src/theory.rs" 976 4 976 86] (self : Normal'0.t_normal) (conflict : Fset.fset (Term'0.t_term, Value'0.t_value)) (tgt : Conflict'0.t_conflict)
    
  
  goal vc_conflict_solve2 : ([%#stheory1] sound'0 self)
   -> ([%#stheory0] invariant'0 (Cdsat_Theory_Normal_Type.normal_0 self))
   -> (if [%#stheory6] forall j : (Term'0.t_term, Value'0.t_value) . contains'0 conflict j
   -> contains'1 (Cdsat_Theory_Normal_Type.normal_0 self) j then
    if [%#stheory6] forall m : Model'0.t_model . inv'0 m  -> satisfy_set'0 m conflict  -> false then
      ([%#stheory7] invariant_nonneg'0 (Cdsat_Theory_Normal_Type.normal_0 self))
      /\ (([%#stheory12] set_level'0 (Cdsat_Theory_Normal_Type.normal_0 self) conflict
      <= level'0 (Cdsat_Theory_Normal_Type.normal_0 self))
      && ([%#stheory11] set_level'0 (Cdsat_Theory_Normal_Type.normal_0 self) conflict >= 0)
      && ([%#stheory10] conflict = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
       -> set_level'0 (Cdsat_Theory_Normal_Type.normal_0 self) conflict = 0)
      && ([%#stheory9] conflict <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
       -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'0 conflict i
      /\ level_of'0 (Cdsat_Theory_Normal_Type.normal_0 self) i
      = set_level'0 (Cdsat_Theory_Normal_Type.normal_0 self) conflict))
      && ([%#stheory8] forall i : (Term'0.t_term, Value'0.t_value) . contains'0 conflict i
       -> level_of'0 (Cdsat_Theory_Normal_Type.normal_0 self) i
      <= set_level'0 (Cdsat_Theory_Normal_Type.normal_0 self) conflict)
       -> (if set_level'0 (Cdsat_Theory_Normal_Type.normal_0 self) conflict > 0 then
        let result = tgt
        = Conflict'0.C_Conflict (Cdsat_Theory_Normal_Type.normal_0 self) conflict in ([%#stheory4] result
         -> impls'0 (Cdsat_Theory_Normal_Type.normal_0 self) (Cdsat_Theory_Conflict_Type.conflict_0 tgt))
        && ([%#stheory3] result  -> sound'1 tgt)
        && ([%#stheory2] result  -> invariant'0 (Cdsat_Theory_Conflict_Type.conflict_0 tgt))
      else
        let result = false in ([%#stheory4] result
         -> impls'0 (Cdsat_Theory_Normal_Type.normal_0 self) (Cdsat_Theory_Conflict_Type.conflict_0 tgt))
        && ([%#stheory3] result  -> sound'1 tgt)
        && ([%#stheory2] result  -> invariant'0 (Cdsat_Theory_Conflict_Type.conflict_0 tgt))
      ))
    else
      let result = false in ([%#stheory4] result
       -> impls'0 (Cdsat_Theory_Normal_Type.normal_0 self) (Cdsat_Theory_Conflict_Type.conflict_0 tgt))
      && ([%#stheory3] result  -> sound'1 tgt)
      && ([%#stheory2] result  -> invariant'0 (Cdsat_Theory_Conflict_Type.conflict_0 tgt))
    
  else
    let result = false in ([%#stheory4] result
     -> impls'0 (Cdsat_Theory_Normal_Type.normal_0 self) (Cdsat_Theory_Conflict_Type.conflict_0 tgt))
    && ([%#stheory3] result  -> sound'1 tgt)
    && ([%#stheory2] result  -> invariant'0 (Cdsat_Theory_Conflict_Type.conflict_0 tgt))
  )
end
module Cdsat_Theory_Impl7_Resolve_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 1046 15 1046 31
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 1047 15 1047 27
  
  let%span stheory2 = "/Users/xavier/Code/cdsat/src/theory.rs" 1048 4 1048 39
  
  let%span stheory3 = "/Users/xavier/Code/cdsat/src/theory.rs" 1049 4 1049 42
  
  let%span stheory4 = "/Users/xavier/Code/cdsat/src/theory.rs" 1050 4 1050 38
  
  let%span stheory5 = "/Users/xavier/Code/cdsat/src/theory.rs" 1051 4 1051 54
  
  let%span stheory6 = "/Users/xavier/Code/cdsat/src/theory.rs" 486 15 486 31
  
  let%span stheory7 = "/Users/xavier/Code/cdsat/src/theory.rs" 487 15 487 35
  
  let%span stheory8 = "/Users/xavier/Code/cdsat/src/theory.rs" 488 15 488 27
  
  let%span stheory9 = "/Users/xavier/Code/cdsat/src/theory.rs" 489 4 489 54
  
  let%span stheory10 = "/Users/xavier/Code/cdsat/src/theory.rs" 490 4 490 58
  
  let%span stheory11 = "/Users/xavier/Code/cdsat/src/theory.rs" 491 4 491 61
  
  let%span stheory12 = "/Users/xavier/Code/cdsat/src/theory.rs" 658 15 658 31
  
  let%span stheory13 = "/Users/xavier/Code/cdsat/src/theory.rs" 659 15 659 36
  
  let%span stheory14 = "/Users/xavier/Code/cdsat/src/theory.rs" 660 4 660 126
  
  let%span stheory15 = "/Users/xavier/Code/cdsat/src/theory.rs" 661 14 661 73
  
  let%span stheory16 = "/Users/xavier/Code/cdsat/src/theory.rs" 406 15 406 38
  
  let%span stheory17 = "/Users/xavier/Code/cdsat/src/theory.rs" 407 14 407 51
  
  let%span stheory18 = "/Users/xavier/Code/cdsat/src/theory.rs" 281 15 281 38
  
  let%span stheory19 = "/Users/xavier/Code/cdsat/src/theory.rs" 282 4 282 74
  
  let%span stheory20 = "/Users/xavier/Code/cdsat/src/theory.rs" 283 4 283 94
  
  let%span stheory21 = "/Users/xavier/Code/cdsat/src/theory.rs" 284 4 284 48
  
  let%span stheory22 = "/Users/xavier/Code/cdsat/src/theory.rs" 285 14 285 25
  
  let%span stheory23 = "/Users/xavier/Code/cdsat/src/theory.rs" 286 14 286 36
  
  let%span stheory24 = "/Users/xavier/Code/cdsat/src/theory.rs" 280 14 280 21
  
  let%span stheory25 = "/Users/xavier/Code/cdsat/src/theory.rs" 1058 15 1058 154
  
  let%span span26 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span27 = "/Users/xavier/Code/cdsat/src/theory.rs" 157 8 159 9
  
  let%span span28 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 53 8 53 26
  
  let%span span29 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span30 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  let%span span31 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span span32 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span33 = "/Users/xavier/Code/cdsat/src/theory.rs" 601 8 605 9
  
  let%span span34 = "/Users/xavier/Code/cdsat/src/theory.rs" 337 8 340 9
  
  let%span span35 = "/Users/xavier/Code/cdsat/src/theory.rs" 82 8 82 36
  
  let%span span36 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 16 8 16 26
  
  let%span span37 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span38 = "/Users/xavier/Code/cdsat/src/theory.rs" 167 18 167 22
  
  let%span span39 = "/Users/xavier/Code/cdsat/src/theory.rs" 166 4 166 62
  
  let%span span40 = "/Users/xavier/Code/cdsat/src/theory.rs" 168 8 188 9
  
  let%span span41 = "/Users/xavier/Code/cdsat/src/theory.rs" 194 8 194 31
  
  let%span span42 = "/Users/xavier/Code/cdsat/src/theory.rs" 200 8 200 71
  
  let%span span43 = "/Users/xavier/Code/cdsat/src/theory.rs" 211 4 211 61
  
  let%span span44 = "/Users/xavier/Code/cdsat/src/theory.rs" 212 15 212 39
  
  let%span span45 = "/Users/xavier/Code/cdsat/src/theory.rs" 213 15 213 32
  
  let%span span46 = "/Users/xavier/Code/cdsat/src/theory.rs" 216 8 216 12
  
  let%span span47 = "/Users/xavier/Code/cdsat/src/theory.rs" 214 14 214 60
  
  let%span span48 = "/Users/xavier/Code/cdsat/src/theory.rs" 209 4 209 12
  
  let%span span49 = "/Users/xavier/Code/cdsat/src/theory.rs" 122 8 126 9
  
  let%span span50 = "/Users/xavier/Code/cdsat/src/theory.rs" 346 8 349 9
  
  let%span span51 = "/Users/xavier/Code/cdsat/src/theory.rs" 132 8 136 9
  
  let%span span52 = "/Users/xavier/Code/cdsat/src/theory.rs" 465 14 468 5
  
  let%span span53 = "/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 111
  
  let%span span54 = "/Users/xavier/Code/cdsat/src/theory.rs" 470 4 470 104
  
  let%span span55 = "/Users/xavier/Code/cdsat/src/theory.rs" 472 8 481 9
  
  let%span span56 = "/Users/xavier/Code/cdsat/src/theory.rs" 409 8 412 9
  
  let%span span57 = "/Users/xavier/Code/cdsat/src/theory.rs" 278 4 278 12
  
  let%span span58 = "/Users/xavier/Code/cdsat/src/theory.rs" 417 4 417 87
  
  let%span span59 = "/Users/xavier/Code/cdsat/src/theory.rs" 419 8 422 9
  
  let%span span60 = "/Users/xavier/Code/cdsat/src/theory.rs" 142 8 147 9
  
  let%span span61 = "/Users/xavier/Code/cdsat/src/theory.rs" 262 8 265 9
  
  let%span span62 = "/Users/xavier/Code/cdsat/src/theory.rs" 619 15 619 27
  
  let%span span63 = "/Users/xavier/Code/cdsat/src/theory.rs" 620 15 620 32
  
  let%span span64 = "/Users/xavier/Code/cdsat/src/theory.rs" 621 4 621 90
  
  let%span span65 = "/Users/xavier/Code/cdsat/src/theory.rs" 623 8 632 9
  
  let%span span66 = "/Users/xavier/Code/cdsat/src/theory.rs" 514 8 517 9
  
  let%span span67 = "/Users/xavier/Code/cdsat/src/theory.rs" 524 8 527 9
  
  let%span span68 = "/Users/xavier/Code/cdsat/src/theory.rs" 206 8 206 84
  
  let%span span69 = "/Users/xavier/Code/cdsat/src/theory.rs" 504 8 507 9
  
  let%span span70 = "/Users/xavier/Code/cdsat/src/theory.rs" 96 15 96 29
  
  let%span span71 = "/Users/xavier/Code/cdsat/src/theory.rs" 97 14 97 30
  
  let%span span72 = "/Users/xavier/Code/cdsat/src/theory.rs" 99 8 102 9
  
  let%span span73 = "/Users/xavier/Code/cdsat/src/theory.rs" 374 8 382 9
  
  let%span span74 = "/Users/xavier/Code/cdsat/src/theory.rs" 355 8 368 9
  
  let%span span75 = "/Users/xavier/Code/cdsat/src/theory.rs" 321 8 331 9
  
  let%span span76 = "/Users/xavier/Code/cdsat/src/theory.rs" 388 8 392 38
  
  let%span span77 = "/Users/xavier/Code/cdsat/src/theory.rs" 493 8 493 30
  
  let%span span78 = "/Users/xavier/Code/cdsat/src/theory.rs" 663 8 672 9
  
  let%span span79 = "/Users/xavier/Code/cdsat/src/theory.rs" 1002 4 1002 12
  
  let%span span80 = "/Users/xavier/Code/cdsat/src/theory.rs" 999 8 999 91
  
  let%span span81 = "/Users/xavier/Code/cdsat/src/theory.rs" 992 8 992 131
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  use Cdsat_Theory_Value_Type as Value'0
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span26] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  use map.Map
  
  use Cdsat_Theory_Model_Type as Cdsat_Theory_Model_Type
  
  use Cdsat_Theory_Var_Type as Var'0
  
  use Cdsat_Theory_Model_Type as Model'0
  
  predicate invariant'2 [#"/Users/xavier/Code/cdsat/src/theory.rs" 156 4 156 30] (self : Model'0.t_model) =
    [%#span27] forall v : Value'0.t_value . forall k : Var'0.t_var . Map.get (Cdsat_Theory_Model_Type.model_0 self) k
    = v  -> Cdsat_Theory_Var_Type.var_1 k = sort'1 v
  
  predicate inv'0 (_x : Model'0.t_model)
  
  axiom inv'0 : forall x : Model'0.t_model . inv'0 x
  = (invariant'2 x
  /\ match x with
    | Model'0.C_Model a_0 -> true
    end)
  
  use set.Fset
  
  use set.Fset
  
  use Cdsat_Theory_Term_Type as Term'0
  
  use set.Fset
  
  function remove'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (a : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span28] Fset.remove a self
  
  use set.Fset
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  use prelude.prelude.Int
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span30] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span29] len'0 self >= 0
  
  function level'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int =
    [%#span33] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> 1 + level'1 tl
      | Trail'0.C_Assign _ _ tl -> level'1 tl
      end
  
  axiom level'1_spec : forall self : Trail'0.t_trail . ([%#span32] level'1 self <= len'0 self)
  && ([%#span31] level'1 self >= 0)
  
  predicate invariant_nonneg'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 336 4 336 41] (self : Trail'0.t_trail) =
    [%#span34] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_nonneg'0 tl /\ l >= 0 /\ l <= level'1 self
      end
  
  predicate is_bool'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 81 4 81 32] (self : Value'0.t_value) =
    [%#span35] sort'1 self = Sort'0.C_Boolean
  
  use Cdsat_Theory_Conflict_Type as Cdsat_Theory_Conflict_Type
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (e : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span36] Fset.mem e self
  
  use prelude.prelude.Real
  
  function from_int'0 (_1 : int) : Real.real
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span37] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'1 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  function interp'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 167 4 167 41] (self : Model'0.t_model) (t : Term'0.t_term) : Value'0.t_value
    
   =
    [%#span40] match t with
      | Term'0.C_Variable v -> Map.get (Cdsat_Theory_Model_Type.model_0 self) v
      | Term'0.C_Value v -> v
      | Term'0.C_Plus l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Rat r1, Value'0.C_Rat r2) -> Value'0.C_Rat r1
        | _ -> Value'0.C_Rat (from_int'0 (- 1))
        end
      | Term'0.C_Conj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 /\ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Disj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 \/ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Eq l r -> Value'0.C_Bool (interp'0 self l = interp'0 self r)
      | Term'0.C_Neg t -> match interp'0 self t with
        | Value'0.C_Bool b -> Value'0.C_Bool (not b)
        | _ -> Value'0.C_Bool false
        end
      end
  
  axiom interp'0_spec : forall self : Model'0.t_model, t : Term'0.t_term . ([%#span38] inv'0 self)
   -> ([%#span39] invariant'2 self  -> sort'1 (interp'0 self t) = sort'0 t)
  
  predicate satisfies'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 193 4 193 52] (self : Model'0.t_model) (v : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span41] interp'0 self (let (a, _) = v in a) = (let (_, a) = v in a)
  
  predicate satisfy_set'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 199 4 199 60] (self : Model'0.t_model) (v : Fset.fset (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span42] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 v a  -> satisfies'0 self a
  
  function resolve_sound'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 215 4 220 5] (self : Model'0.t_model) (cflct : Fset.fset (Term'0.t_term, Value'0.t_value)) (just : Fset.fset (Term'0.t_term, Value'0.t_value)) (a : (Term'0.t_term, Value'0.t_value)) : ()
    
   =
    [%#span48] ()
  
  axiom resolve_sound'0_spec : forall self : Model'0.t_model, cflct : Fset.fset (Term'0.t_term, Value'0.t_value), just : Fset.fset (Term'0.t_term, Value'0.t_value), a : (Term'0.t_term, Value'0.t_value) . ([%#span43] satisfy_set'0 self just
   -> satisfies'0 self a)
   -> ([%#span44] not satisfy_set'0 self cflct)
   -> ([%#span45] contains'0 cflct a)
   -> ([%#span46] inv'0 self)  -> ([%#span47] not satisfy_set'0 self (Fset.union (remove'0 cflct a) just))
  
  use set.Fset
  
  use set.Fset
  
  use prelude.prelude.Int
  
  predicate invariant'3 [#"/Users/xavier/Code/cdsat/src/theory.rs" 121 4 121 34] (self : Assign'0.t_assign) =
    [%#span49] match self with
      | Assign'0.C_Decision t v -> sort'0 t = sort'1 v
      | Assign'0.C_Justified _ t v -> sort'0 t = sort'1 v /\ sort'0 t = Sort'0.C_Boolean
      | Assign'0.C_Input t v -> sort'0 t = sort'1 v
      end
  
  predicate invariant_assign'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 345 4 345 41] (self : Trail'0.t_trail) =
    [%#span50] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_assign'0 tl /\ invariant'3 a
      end
  
  function to_pair'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 131 4 131 41] (self : Assign'0.t_assign) : (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span51] match self with
      | Assign'0.C_Decision t val' -> (t, val')
      | Assign'0.C_Input t val' -> (t, val')
      | Assign'0.C_Justified _ t val' -> (t, val')
      end
  
  use Core_Option_Option_Type as Option'0
  
  function find'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 471 4 471 64] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Option'0.t_option (Assign'0.t_assign, int)
    
   =
    [%#span55] match self with
      | Trail'0.C_Empty -> Option'0.C_None
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then Option'0.C_Some (a, l) else find'0 tl d
      end
  
  axiom find'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span54] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)))
  && ([%#span53] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'1 self))
  && ([%#span52] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
  
  function level_of'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 408 4 408 50] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : int
    
   =
    [%#span56] match find'0 self d with
      | Option'0.C_Some (_, l) -> l
      | Option'0.C_None -> 0
      end
  
  axiom level_of'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#stheory16] invariant_nonneg'0 self)
   -> ([%#stheory17] level_of'0 self d >= 0 /\ level_of'0 self d <= level'1 self)
  
  function set_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 287 4 287 57] (self : Trail'0.t_trail) (s : Fset.fset (Term'0.t_term, Value'0.t_value)) : int
    
  
  axiom set_level'0_def : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . set_level'0 self s
  = ([%#span57] if Fset.cardinal s = 0 then
    0
  else
    if Fset.cardinal s = 1 then
      level_of'0 self (Fset.pick s)
    else
      let a = Fset.pick s in let rec' = set_level'0 self (remove'0 s a) in if level_of'0 self a >= rec' then
        level_of'0 self a
      else
        rec'
      
    
  )
  
  axiom set_level'0_spec : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . ([%#stheory18] invariant_nonneg'0 self)
   -> ([%#stheory23] set_level'0 self s <= level'1 self)
  && ([%#stheory22] set_level'0 self s >= 0)
  && ([%#stheory21] s = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))  -> set_level'0 self s = 0)
  && ([%#stheory20] s <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
   -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'0 s i /\ level_of'0 self i = set_level'0 self s))
  && ([%#stheory19] forall i : (Term'0.t_term, Value'0.t_value) . contains'0 s i
   -> level_of'0 self i <= set_level'0 self s)
  
  predicate contains'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 418 4 418 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span59] match find'0 self d with
      | Option'0.C_Some ix -> true
      | Option'0.C_None -> false
      end
  
  axiom contains'1_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . [%#span58] invariant_assign'0 self
   -> contains'1 self d = true  -> sort'0 (let (a, _) = d in a) = sort'1 (let (_, a) = d in a)
  
  predicate justified_sound'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 141 4 141 40] (self : Assign'0.t_assign) =
    [%#span60] match self with
      | Assign'0.C_Justified just t val' -> forall m : Model'0.t_model . inv'0 m
       -> satisfy_set'0 m just  -> satisfies'0 m (t, val')
      | _ -> true
      end
  
  predicate sound'1 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 261 4 261 30] (self : Trail'0.t_trail)
   =
    [%#span61] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a _ tl -> sound'1 tl /\ justified_sound'0 a
      end
  
  function find_justified'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 622 4 622 46] (self : Trail'0.t_trail) (kv : (Term'0.t_term, Value'0.t_value)) : ()
    
   =
    [%#span65] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = kv then () else find_justified'0 tl kv
      end
  
  axiom find_justified'0_spec : forall self : Trail'0.t_trail, kv : (Term'0.t_term, Value'0.t_value) . ([%#span62] sound'1 self)
   -> ([%#span63] contains'1 self kv)
   -> ([%#span64] forall l : int . forall a : Assign'0.t_assign . find'0 self kv = Option'0.C_Some (a, l)
   -> justified_sound'0 a)
  
  predicate is_decision'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 513 4 513 54] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span66] match find'0 self d with
      | Option'0.C_Some (Assign'0.C_Decision _ _, _) -> true
      | _ -> false
      end
  
  predicate is_input'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 523 4 523 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span67] match find'0 self d with
      | Option'0.C_Some (Assign'0.C_Input _ _, _) -> true
      | _ -> false
      end
  
  predicate entails'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 205 4 205 74] (self : Model'0.t_model) (j : Fset.fset (Term'0.t_term, Value'0.t_value)) (c : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span68] invariant'2 self  -> satisfy_set'0 self j  -> satisfies'0 self c
  
  predicate is_justified'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 503 4 503 55] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span69] match find'0 self d with
      | Option'0.C_Some (Assign'0.C_Justified _ _ _, _) -> true
      | _ -> false
      end
  
  function negate'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 98 4 98 31] (self : Value'0.t_value) : Value'0.t_value =
    [%#span72] match self with
      | Value'0.C_Bool b -> Value'0.C_Bool (not b)
      | _ -> self
      end
  
  axiom negate'0_spec : forall self : Value'0.t_value . ([%#span70] is_bool'0 self)
   -> ([%#span71] is_bool'0 (negate'0 self))
  
  predicate trail_unique'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 373 4 373 37] (self : Trail'0.t_trail) =
    [%#span73] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> let ap = to_pair'0 a in not contains'1 tl ap
      /\ trail_unique'0 tl
      /\ (if is_bool'0 (let (_, a) = ap in a) then
        not contains'1 tl ((let (a, _) = ap in a), negate'0 (let (_, a) = ap in a))
      else
        true
      )
      end
  
  predicate invariant_contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 354 4 354 43] (self : Trail'0.t_trail) =
    [%#span74] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_contains'0 tl
      /\ match a with
        | Assign'0.C_Justified j _ _ -> forall a : (Term'0.t_term, Value'0.t_value) . contains'0 j a  -> contains'1 tl a
        | _ -> true
        end
      end
  
  predicate invariant_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 320 4 320 40] (self : Trail'0.t_trail) =
    [%#span75] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_level'0 tl
      /\ match a with
        | Assign'0.C_Input _ _ -> l = 0
        | Assign'0.C_Decision _ _ -> level'1 tl + 1 = l
        | Assign'0.C_Justified j _ _ -> set_level'0 tl j = l
        end
      end
  
  predicate invariant'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 387 4 387 34] (self : Trail'0.t_trail) =
    [%#span76] invariant_level'0 self
    /\ invariant_contains'0 self /\ trail_unique'0 self /\ invariant_nonneg'0 self /\ invariant_assign'0 self
  
  function justification'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 492 4 492 71] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span77] let _ = find_justified'0 self d in match find'0 self d with
      | Option'0.C_Some (Assign'0.C_Justified j _ _, _) -> j
      | _ -> Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value)
      end
  
  axiom justification'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#stheory6] invariant'1 self)
   -> ([%#stheory7] is_justified'0 self d)
   -> ([%#stheory8] sound'1 self)
   -> ([%#stheory11] is_decision'0 self d
   -> justification'0 self d = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value)))
  && ([%#stheory10] is_input'0 self d
   -> justification'0 self d = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value)))
  && ([%#stheory9] forall m : Model'0.t_model . inv'0 m  -> entails'0 m (justification'0 self d) d)
  
  function justification_contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 662 4 662 58] (self : Trail'0.t_trail) (kv : (Term'0.t_term, Value'0.t_value)) : ()
    
   =
    [%#span78] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = kv then () else justification_contains'0 tl kv
      end
  
  axiom justification_contains'0_spec : forall self : Trail'0.t_trail, kv : (Term'0.t_term, Value'0.t_value) . ([%#stheory12] invariant'1 self)
   -> ([%#stheory13] is_justified'0 self kv)
   -> ([%#stheory15] set_level'0 self (justification'0 self kv) = level_of'0 self kv)
  && ([%#stheory14] forall e : (Term'0.t_term, Value'0.t_value) . contains'0 (justification'0 self kv) e
   -> contains'1 self e /\ level_of'0 self e <= level_of'0 self kv)
  
  use Cdsat_Theory_Conflict_Type as Conflict'0
  
  function level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 1004 4 1004 29] (self : Conflict'0.t_conflict) : int =
    [%#span79] set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (Cdsat_Theory_Conflict_Type.conflict_1 self)
  
  predicate sound'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 998 4 998 30] (self : Conflict'0.t_conflict)
    
   =
    [%#span80] sound'1 (Cdsat_Theory_Conflict_Type.conflict_0 self)
    /\ (forall m : Model'0.t_model . inv'0 m  -> satisfy_set'0 m (Cdsat_Theory_Conflict_Type.conflict_1 self)  -> false)
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 991 4 991 34] (self : Conflict'0.t_conflict) =
    [%#span81] set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (Cdsat_Theory_Conflict_Type.conflict_1 self) > 0
    /\ invariant'1 (Cdsat_Theory_Conflict_Type.conflict_0 self)
    /\ (forall a : (Term'0.t_term, Value'0.t_value) . contains'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) a
     -> contains'1 (Cdsat_Theory_Conflict_Type.conflict_0 self) a)
  
  constant self  : Conflict'0.t_conflict
  
  constant a  : (Term'0.t_term, Value'0.t_value)
  
  constant tgt  : Conflict'0.t_conflict
  
  predicate resolve [#"/Users/xavier/Code/cdsat/src/theory.rs" 1052 4 1052 61] (self : Conflict'0.t_conflict) (a : (Term'0.t_term, Value'0.t_value)) (tgt : Conflict'0.t_conflict)
    
  
  goal vc_resolve : ([%#stheory2] is_justified'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) a)
   -> ([%#stheory1] sound'0 self)
   -> ([%#stheory0] invariant'0 self)
   -> (([%#stheory8] sound'1 (Cdsat_Theory_Conflict_Type.conflict_0 self))
  && ([%#stheory7] is_justified'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) a)
  && ([%#stheory6] invariant'1 (Cdsat_Theory_Conflict_Type.conflict_0 self)))
  /\ (([%#stheory11] is_decision'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) a
   -> justification'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) a
  = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value)))
  && ([%#stheory10] is_input'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) a
   -> justification'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) a
  = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value)))
  && ([%#stheory9] forall m : Model'0.t_model . inv'0 m
   -> entails'0 m (justification'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) a) a)
   -> (let just = justification'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) a in (([%#stheory13] is_justified'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) a)
  && ([%#stheory12] invariant'1 (Cdsat_Theory_Conflict_Type.conflict_0 self)))
  /\ (([%#stheory15] set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (justification'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) a)
  = level_of'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) a)
  && ([%#stheory14] forall e : (Term'0.t_term, Value'0.t_value) . contains'0 (justification'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) a) e
   -> contains'1 (Cdsat_Theory_Conflict_Type.conflict_0 self) e
  /\ level_of'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) e
  <= level_of'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) a)
   -> (let _ = justification_contains'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) a in let _ = resolve_sound'0 in if contains'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) a then
    (forall a : (Term'0.t_term, Value'0.t_value) . if contains'0 just a then
      if not is_bool'0 (let (_, a) = a in a) then
        if is_decision'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) a then
          ([%#stheory16] invariant_nonneg'0 (Cdsat_Theory_Conflict_Type.conflict_0 self))
          /\ (([%#stheory17] level_of'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) a >= 0
          /\ level_of'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) a
          <= level'1 (Cdsat_Theory_Conflict_Type.conflict_0 self))
           -> ([%#stheory18] invariant_nonneg'0 (Cdsat_Theory_Conflict_Type.conflict_0 self)))
        else
          true
        
      else
        true
      
    else
      true
    )
    /\ (if [%#stheory25] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 just a
    /\ not is_bool'0 (let (_, a) = a in a) /\ is_decision'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) a
     -> level_of'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) a
    < set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (Cdsat_Theory_Conflict_Type.conflict_1 self) then
      let result = tgt
      = Conflict'0.C_Conflict (Cdsat_Theory_Conflict_Type.conflict_0 self) (Fset.union (remove'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) a) just) in ([%#stheory5] result
       -> level'0 tgt = level'0 self)
      && ([%#stheory4] result  -> sound'0 tgt) && ([%#stheory3] result  -> invariant'0 tgt)
    else
      let result = false in ([%#stheory5] result  -> level'0 tgt = level'0 self)
      && ([%#stheory4] result  -> sound'0 tgt) && ([%#stheory3] result  -> invariant'0 tgt)
    )
  else
    let result = false in ([%#stheory5] result  -> level'0 tgt = level'0 self)
    && ([%#stheory4] result  -> sound'0 tgt) && ([%#stheory3] result  -> invariant'0 tgt)
  ))))
end
module Cdsat_Theory_Impl7_Backjump_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 1065 15 1065 31
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 1066 15 1066 27
  
  let%span stheory2 = "/Users/xavier/Code/cdsat/src/theory.rs" 1067 4 1067 44
  
  let%span stheory3 = "/Users/xavier/Code/cdsat/src/theory.rs" 1068 4 1068 38
  
  let%span stheory4 = "/Users/xavier/Code/cdsat/src/theory.rs" 1069 4 1069 46
  
  let%span stheory5 = "/Users/xavier/Code/cdsat/src/theory.rs" 281 15 281 38
  
  let%span stheory6 = "/Users/xavier/Code/cdsat/src/theory.rs" 282 4 282 74
  
  let%span stheory7 = "/Users/xavier/Code/cdsat/src/theory.rs" 283 4 283 94
  
  let%span stheory8 = "/Users/xavier/Code/cdsat/src/theory.rs" 284 4 284 48
  
  let%span stheory9 = "/Users/xavier/Code/cdsat/src/theory.rs" 285 14 285 25
  
  let%span stheory10 = "/Users/xavier/Code/cdsat/src/theory.rs" 286 14 286 36
  
  let%span stheory11 = "/Users/xavier/Code/cdsat/src/theory.rs" 280 14 280 21
  
  let%span stheory12 = "/Users/xavier/Code/cdsat/src/theory.rs" 406 15 406 38
  
  let%span stheory13 = "/Users/xavier/Code/cdsat/src/theory.rs" 407 14 407 51
  
  let%span stheory14 = "/Users/xavier/Code/cdsat/src/theory.rs" 96 15 96 29
  
  let%span stheory15 = "/Users/xavier/Code/cdsat/src/theory.rs" 97 14 97 30
  
  let%span span16 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span17 = "/Users/xavier/Code/cdsat/src/theory.rs" 157 8 159 9
  
  let%span span18 = "/Users/xavier/Code/cdsat/src/theory.rs" 82 8 82 36
  
  let%span span19 = "/Users/xavier/Code/cdsat/src/theory.rs" 99 8 102 9
  
  let%span span20 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span21 = "/Users/xavier/Code/cdsat/src/theory.rs" 60 8 60 36
  
  let%span span22 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span23 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  let%span span24 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span span25 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span26 = "/Users/xavier/Code/cdsat/src/theory.rs" 601 8 605 9
  
  let%span span27 = "/Users/xavier/Code/cdsat/src/theory.rs" 122 8 126 9
  
  let%span span28 = "/Users/xavier/Code/cdsat/src/theory.rs" 346 8 349 9
  
  let%span span29 = "/Users/xavier/Code/cdsat/src/theory.rs" 337 8 340 9
  
  let%span span30 = "/Users/xavier/Code/cdsat/src/theory.rs" 132 8 136 9
  
  let%span span31 = "/Users/xavier/Code/cdsat/src/theory.rs" 465 14 468 5
  
  let%span span32 = "/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 111
  
  let%span span33 = "/Users/xavier/Code/cdsat/src/theory.rs" 470 4 470 104
  
  let%span span34 = "/Users/xavier/Code/cdsat/src/theory.rs" 472 8 481 9
  
  let%span span35 = "/Users/xavier/Code/cdsat/src/theory.rs" 409 8 412 9
  
  let%span span36 = "/Users/xavier/Code/cdsat/src/theory.rs" 417 4 417 87
  
  let%span span37 = "/Users/xavier/Code/cdsat/src/theory.rs" 419 8 422 9
  
  let%span span38 = "/Users/xavier/Code/cdsat/src/theory.rs" 374 8 382 9
  
  let%span span39 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 16 8 16 26
  
  let%span span40 = "/Users/xavier/Code/cdsat/src/theory.rs" 355 8 368 9
  
  let%span span41 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 53 8 53 26
  
  let%span span42 = "/Users/xavier/Code/cdsat/src/theory.rs" 278 4 278 12
  
  let%span span43 = "/Users/xavier/Code/cdsat/src/theory.rs" 321 8 331 9
  
  let%span span44 = "/Users/xavier/Code/cdsat/src/theory.rs" 388 8 392 38
  
  let%span span45 = "/Users/xavier/Code/cdsat/src/theory.rs" 741 15 741 31
  
  let%span span46 = "/Users/xavier/Code/cdsat/src/theory.rs" 742 4 742 83
  
  let%span span47 = "/Users/xavier/Code/cdsat/src/theory.rs" 744 8 749 9
  
  let%span span48 = "/Users/xavier/Code/cdsat/src/theory.rs" 562 8 573 9
  
  let%span span49 = "/Users/xavier/Code/cdsat/src/theory.rs" 167 18 167 22
  
  let%span span50 = "/Users/xavier/Code/cdsat/src/theory.rs" 166 4 166 62
  
  let%span span51 = "/Users/xavier/Code/cdsat/src/theory.rs" 168 8 188 9
  
  let%span span52 = "/Users/xavier/Code/cdsat/src/theory.rs" 194 8 194 31
  
  let%span span53 = "/Users/xavier/Code/cdsat/src/theory.rs" 225 15 225 40
  
  let%span span54 = "/Users/xavier/Code/cdsat/src/theory.rs" 226 15 226 40
  
  let%span span55 = "/Users/xavier/Code/cdsat/src/theory.rs" 227 15 227 31
  
  let%span span56 = "/Users/xavier/Code/cdsat/src/theory.rs" 229 17 229 21
  
  let%span span57 = "/Users/xavier/Code/cdsat/src/theory.rs" 228 14 228 71
  
  let%span span58 = "/Users/xavier/Code/cdsat/src/theory.rs" 230 8 233 9
  
  let%span span59 = "/Users/xavier/Code/cdsat/src/theory.rs" 200 8 200 71
  
  let%span span60 = "/Users/xavier/Code/cdsat/src/theory.rs" 142 8 147 9
  
  let%span span61 = "/Users/xavier/Code/cdsat/src/theory.rs" 262 8 265 9
  
  let%span span62 = "/Users/xavier/Code/cdsat/src/theory.rs" 999 8 999 91
  
  let%span span63 = "/Users/xavier/Code/cdsat/src/theory.rs" 992 8 992 131
  
  let%span span64 = "/Users/xavier/Code/cdsat/src/theory.rs" 1010 15 1010 31
  
  let%span span65 = "/Users/xavier/Code/cdsat/src/theory.rs" 1011 15 1011 27
  
  let%span span66 = "/Users/xavier/Code/cdsat/src/theory.rs" 1012 4 1012 37
  
  let%span span67 = "/Users/xavier/Code/cdsat/src/theory.rs" 1013 4 1013 51
  
  let%span span68 = "/Users/xavier/Code/cdsat/src/theory.rs" 1014 4 1014 108
  
  let%span span69 = "/Users/xavier/Code/cdsat/src/theory.rs" 1008 4 1008 12
  
  let%span span70 = "/Users/xavier/Code/cdsat/src/theory.rs" 107 15 107 29
  
  let%span span71 = "/Users/xavier/Code/cdsat/src/theory.rs" 108 14 108 44
  
  let%span span72 = "/Users/xavier/Code/cdsat/src/theory.rs" 105 4 105 12
  
  let%span span73 = "/Users/xavier/Code/cdsat/src/theory.rs" 774 15 774 31
  
  let%span span74 = "/Users/xavier/Code/cdsat/src/theory.rs" 775 15 775 33
  
  let%span span75 = "/Users/xavier/Code/cdsat/src/theory.rs" 776 15 776 23
  
  let%span span76 = "/Users/xavier/Code/cdsat/src/theory.rs" 777 14 777 65
  
  let%span span77 = "/Users/xavier/Code/cdsat/src/theory.rs" 779 8 782 9
  
  let%span span78 = "/Users/xavier/Code/cdsat/src/theory.rs" 787 15 787 31
  
  let%span span79 = "/Users/xavier/Code/cdsat/src/theory.rs" 788 15 788 31
  
  let%span span80 = "/Users/xavier/Code/cdsat/src/theory.rs" 789 4 789 30
  
  let%span span81 = "/Users/xavier/Code/cdsat/src/theory.rs" 790 14 790 49
  
  let%span span82 = "/Users/xavier/Code/cdsat/src/theory.rs" 792 8 801 9
  
  let%span span83 = "/Users/xavier/Code/cdsat/src/theory.rs" 705 15 705 27
  
  let%span span84 = "/Users/xavier/Code/cdsat/src/theory.rs" 706 14 706 42
  
  let%span span85 = "/Users/xavier/Code/cdsat/src/theory.rs" 708 8 713 9
  
  let%span span86 = "/Users/xavier/Code/cdsat/src/theory.rs" 678 8 678 71
  
  let%span span87 = "/Users/xavier/Code/cdsat/src/theory.rs" 685 8 685 82
  
  let%span span88 = "/Users/xavier/Code/cdsat/src/theory.rs" 696 4 696 55
  
  let%span span89 = "/Users/xavier/Code/cdsat/src/theory.rs" 698 8 698 108
  
  let%span span90 = "/Users/xavier/Code/cdsat/src/theory.rs" 826 4 826 16
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  use Cdsat_Theory_Value_Type as Value'0
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span16] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  use map.Map
  
  use Cdsat_Theory_Model_Type as Cdsat_Theory_Model_Type
  
  use Cdsat_Theory_Var_Type as Var'0
  
  use Cdsat_Theory_Model_Type as Model'0
  
  predicate invariant'3 [#"/Users/xavier/Code/cdsat/src/theory.rs" 156 4 156 30] (self : Model'0.t_model) =
    [%#span17] forall v : Value'0.t_value . forall k : Var'0.t_var . Map.get (Cdsat_Theory_Model_Type.model_0 self) k
    = v  -> Cdsat_Theory_Var_Type.var_1 k = sort'0 v
  
  predicate inv'0 (_x : Model'0.t_model)
  
  axiom inv'0 : forall x : Model'0.t_model . inv'0 x
  = (invariant'3 x
  /\ match x with
    | Model'0.C_Model a_0 -> true
    end)
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  predicate is_bool'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 81 4 81 32] (self : Value'0.t_value) =
    [%#span18] sort'0 self = Sort'0.C_Boolean
  
  function negate'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 98 4 98 31] (self : Value'0.t_value) : Value'0.t_value =
    [%#span19] match self with
      | Value'0.C_Bool b -> Value'0.C_Bool (not b)
      | _ -> self
      end
  
  axiom negate'0_spec : forall self : Value'0.t_value . ([%#stheory14] is_bool'0 self)
   -> ([%#stheory15] is_bool'0 (negate'0 self))
  
  use Cdsat_Theory_Term_Type as Term'0
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span20] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'0 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  predicate is_bool'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 59 4 59 32] (self : Term'0.t_term) =
    [%#span21] sort'1 self = Sort'0.C_Boolean
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  use prelude.prelude.Int
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span23] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span22] len'0 self >= 0
  
  function level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int =
    [%#span26] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> 1 + level'0 tl
      | Trail'0.C_Assign _ _ tl -> level'0 tl
      end
  
  axiom level'0_spec : forall self : Trail'0.t_trail . ([%#span25] level'0 self <= len'0 self)
  && ([%#span24] level'0 self >= 0)
  
  use prelude.prelude.Int
  
  predicate invariant'2 [#"/Users/xavier/Code/cdsat/src/theory.rs" 121 4 121 34] (self : Assign'0.t_assign) =
    [%#span27] match self with
      | Assign'0.C_Decision t v -> sort'1 t = sort'0 v
      | Assign'0.C_Justified _ t v -> sort'1 t = sort'0 v /\ sort'1 t = Sort'0.C_Boolean
      | Assign'0.C_Input t v -> sort'1 t = sort'0 v
      end
  
  predicate invariant_assign'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 345 4 345 41] (self : Trail'0.t_trail) =
    [%#span28] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_assign'0 tl /\ invariant'2 a
      end
  
  predicate invariant_nonneg'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 336 4 336 41] (self : Trail'0.t_trail) =
    [%#span29] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_nonneg'0 tl /\ l >= 0 /\ l <= level'0 self
      end
  
  function to_pair'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 131 4 131 41] (self : Assign'0.t_assign) : (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span30] match self with
      | Assign'0.C_Decision t val' -> (t, val')
      | Assign'0.C_Input t val' -> (t, val')
      | Assign'0.C_Justified _ t val' -> (t, val')
      end
  
  use Core_Option_Option_Type as Option'0
  
  function find'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 471 4 471 64] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Option'0.t_option (Assign'0.t_assign, int)
    
   =
    [%#span34] match self with
      | Trail'0.C_Empty -> Option'0.C_None
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then Option'0.C_Some (a, l) else find'0 tl d
      end
  
  axiom find'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span33] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'1 (let (a, _) = d in a) = sort'0 (let (_, a) = d in a)))
  && ([%#span32] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
  && ([%#span31] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
  
  function level_of'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 408 4 408 50] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : int
    
   =
    [%#span35] match find'0 self d with
      | Option'0.C_Some (_, l) -> l
      | Option'0.C_None -> 0
      end
  
  axiom level_of'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#stheory12] invariant_nonneg'0 self)
   -> ([%#stheory13] level_of'0 self d >= 0 /\ level_of'0 self d <= level'0 self)
  
  predicate contains'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 418 4 418 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span37] match find'0 self d with
      | Option'0.C_Some ix -> true
      | Option'0.C_None -> false
      end
  
  axiom contains'1_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . [%#span36] invariant_assign'0 self
   -> contains'1 self d = true  -> sort'1 (let (a, _) = d in a) = sort'0 (let (_, a) = d in a)
  
  predicate trail_unique'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 373 4 373 37] (self : Trail'0.t_trail) =
    [%#span38] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> let ap = to_pair'0 a in not contains'1 tl ap
      /\ trail_unique'0 tl
      /\ (if is_bool'0 (let (_, a) = ap in a) then
        not contains'1 tl ((let (a, _) = ap in a), negate'0 (let (_, a) = ap in a))
      else
        true
      )
      end
  
  use set.Fset
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (e : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span39] Fset.mem e self
  
  predicate invariant_contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 354 4 354 43] (self : Trail'0.t_trail) =
    [%#span40] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_contains'0 tl
      /\ match a with
        | Assign'0.C_Justified j _ _ -> forall a : (Term'0.t_term, Value'0.t_value) . contains'0 j a  -> contains'1 tl a
        | _ -> true
        end
      end
  
  use set.Fset
  
  function remove'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (a : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span41] Fset.remove a self
  
  use set.Fset
  
  use set.Fset
  
  use set.Fset
  
  function set_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 287 4 287 57] (self : Trail'0.t_trail) (s : Fset.fset (Term'0.t_term, Value'0.t_value)) : int
    
  
  axiom set_level'0_def : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . set_level'0 self s
  = ([%#span42] if Fset.cardinal s = 0 then
    0
  else
    if Fset.cardinal s = 1 then
      level_of'0 self (Fset.pick s)
    else
      let a = Fset.pick s in let rec' = set_level'0 self (remove'0 s a) in if level_of'0 self a >= rec' then
        level_of'0 self a
      else
        rec'
      
    
  )
  
  axiom set_level'0_spec : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . ([%#stheory5] invariant_nonneg'0 self)
   -> ([%#stheory10] set_level'0 self s <= level'0 self)
  && ([%#stheory9] set_level'0 self s >= 0)
  && ([%#stheory8] s = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))  -> set_level'0 self s = 0)
  && ([%#stheory7] s <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
   -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'0 s i /\ level_of'0 self i = set_level'0 self s))
  && ([%#stheory6] forall i : (Term'0.t_term, Value'0.t_value) . contains'0 s i
   -> level_of'0 self i <= set_level'0 self s)
  
  predicate invariant_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 320 4 320 40] (self : Trail'0.t_trail) =
    [%#span43] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_level'0 tl
      /\ match a with
        | Assign'0.C_Input _ _ -> l = 0
        | Assign'0.C_Decision _ _ -> level'0 tl + 1 = l
        | Assign'0.C_Justified j _ _ -> set_level'0 tl j = l
        end
      end
  
  predicate invariant'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 387 4 387 34] (self : Trail'0.t_trail) =
    [%#span44] invariant_level'0 self
    /\ invariant_contains'0 self /\ trail_unique'0 self /\ invariant_nonneg'0 self /\ invariant_assign'0 self
  
  function count_bounds'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 743 4 743 35] (self : Trail'0.t_trail) : () =
    [%#span47] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign (Assign'0.C_Input _ _) _ tl -> count_bounds'0 tl
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> count_bounds'0 tl
      | Trail'0.C_Assign (Assign'0.C_Justified _ _ _) _ tl -> count_bounds'0 tl
      end
  
  axiom count_bounds'0_spec : forall self : Trail'0.t_trail . ([%#span45] invariant'1 self)
   -> ([%#span46] forall a : (Term'0.t_term, Value'0.t_value) . contains'1 self a  -> level_of'0 self a <= level'0 self)
  
  function restrict'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 561 4 561 45] (self : Trail'0.t_trail) (level : int) : Trail'0.t_trail
    
   =
    [%#span48] match self with
      | Trail'0.C_Empty -> Trail'0.C_Empty
      | Trail'0.C_Assign a l tl -> let tl = restrict'0 tl level in let _ = count_bounds'0 tl in if l <= level then
        Trail'0.C_Assign a l tl
      else
        tl
      
      end
  
  use prelude.prelude.Real
  
  function from_int'0 (_1 : int) : Real.real
  
  function interp'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 167 4 167 41] (self : Model'0.t_model) (t : Term'0.t_term) : Value'0.t_value
    
   =
    [%#span51] match t with
      | Term'0.C_Variable v -> Map.get (Cdsat_Theory_Model_Type.model_0 self) v
      | Term'0.C_Value v -> v
      | Term'0.C_Plus l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Rat r1, Value'0.C_Rat r2) -> Value'0.C_Rat r1
        | _ -> Value'0.C_Rat (from_int'0 (- 1))
        end
      | Term'0.C_Conj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 /\ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Disj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 \/ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Eq l r -> Value'0.C_Bool (interp'0 self l = interp'0 self r)
      | Term'0.C_Neg t -> match interp'0 self t with
        | Value'0.C_Bool b -> Value'0.C_Bool (not b)
        | _ -> Value'0.C_Bool false
        end
      end
  
  axiom interp'0_spec : forall self : Model'0.t_model, t : Term'0.t_term . ([%#span49] inv'0 self)
   -> ([%#span50] invariant'3 self  -> sort'0 (interp'0 self t) = sort'1 t)
  
  predicate satisfies'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 193 4 193 52] (self : Model'0.t_model) (v : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span52] interp'0 self (let (a, _) = v in a) = (let (_, a) = v in a)
  
  function lemma'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 229 4 229 41] (self : Model'0.t_model) (t : Term'0.t_term) (v : Value'0.t_value) : ()
    
   =
    [%#span58] match interp'0 self t with
      | Value'0.C_Bool _ -> ()
      | _ -> ()
      end
  
  axiom lemma'0_spec : forall self : Model'0.t_model, t : Term'0.t_term, v : Value'0.t_value . ([%#span53] sort'0 v
  = Sort'0.C_Boolean)
   -> ([%#span54] sort'1 t = Sort'0.C_Boolean)
   -> ([%#span55] invariant'3 self)
   -> ([%#span56] inv'0 self)  -> ([%#span57] satisfies'0 self (t, v) \/ satisfies'0 self (t, negate'0 v))
  
  use Cdsat_Theory_Conflict_Type as Conflict'0
  
  predicate satisfy_set'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 199 4 199 60] (self : Model'0.t_model) (v : Fset.fset (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span59] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 v a  -> satisfies'0 self a
  
  use Cdsat_Theory_Conflict_Type as Cdsat_Theory_Conflict_Type
  
  predicate justified_sound'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 141 4 141 40] (self : Assign'0.t_assign) =
    [%#span60] match self with
      | Assign'0.C_Justified just t val' -> forall m : Model'0.t_model . inv'0 m
       -> satisfy_set'0 m just  -> satisfies'0 m (t, val')
      | _ -> true
      end
  
  predicate sound'2 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 261 4 261 30] (self : Trail'0.t_trail)
   =
    [%#span61] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a _ tl -> sound'2 tl /\ justified_sound'0 a
      end
  
  predicate sound'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 998 4 998 30] (self : Conflict'0.t_conflict)
    
   =
    [%#span62] sound'2 (Cdsat_Theory_Conflict_Type.conflict_0 self)
    /\ (forall m : Model'0.t_model . inv'0 m  -> satisfy_set'0 m (Cdsat_Theory_Conflict_Type.conflict_1 self)  -> false)
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 991 4 991 34] (self : Conflict'0.t_conflict) =
    [%#span63] set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (Cdsat_Theory_Conflict_Type.conflict_1 self) > 0
    /\ invariant'1 (Cdsat_Theory_Conflict_Type.conflict_0 self)
    /\ (forall a : (Term'0.t_term, Value'0.t_value) . contains'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) a
     -> contains'1 (Cdsat_Theory_Conflict_Type.conflict_0 self) a)
  
  function learn_justified'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 1015 4 1015 52] (self : Conflict'0.t_conflict) (ass : (Term'0.t_term, Value'0.t_value)) : ()
    
   =
    [%#span69] let _ = () in ()
  
  axiom learn_justified'0_spec : forall self : Conflict'0.t_conflict, ass : (Term'0.t_term, Value'0.t_value) . ([%#span64] invariant'0 self)
   -> ([%#span65] sound'0 self)
   -> ([%#span66] contains'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) ass)
   -> ([%#span67] is_bool'1 (let (a, _) = ass in a) /\ is_bool'0 (let (_, a) = ass in a))
   -> ([%#span68] forall m : Model'0.t_model . inv'0 m
   -> satisfy_set'0 m (remove'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) ass)
   -> satisfies'0 m ((let (a, _) = ass in a), negate'0 (let (_, a) = ass in a)))
  
  function negate_involutive'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 109 4 109 34] (self : Value'0.t_value) : () =
    [%#span72] ()
  
  axiom negate_involutive'0_spec : forall self : Value'0.t_value . ([%#span70] is_bool'0 self)
   -> ([%#span71] negate'0 (negate'0 self) = self)
  
  function restrict_idempotent'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 778 4 778 54] (self : Trail'0.t_trail) (l1 : int) (l2 : int) : ()
    
   =
    [%#span77] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign _ _ tl -> restrict_idempotent'0 tl l1 l2
      end
  
  axiom restrict_idempotent'0_spec : forall self : Trail'0.t_trail, l1 : int, l2 : int . ([%#span73] invariant'1 self)
   -> ([%#span74] l1 >= 0 /\ l2 >= 0)
   -> ([%#span75] l1 <= l2)  -> ([%#span76] restrict'0 self l1 = restrict'0 (restrict'0 self l2) l1)
  
  function trail_plausible'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 791 4 791 50] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : ()
    
   =
    [%#span82] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then () else let _ = trail_plausible'0 tl d in ()
      end
  
  axiom trail_plausible'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span78] invariant'1 self)
   -> ([%#span79] contains'1 self d)
   -> ([%#span80] is_bool'0 (let (_, a) = d in a))
   -> ([%#span81] not contains'1 self ((let (a, _) = d in a), negate'0 (let (_, a) = d in a)))
  
  function restrict_sound'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 707 4 707 43] (self : Trail'0.t_trail) (level : int) : ()
    
   =
    [%#span85] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign a l tl -> let _ = restrict_sound'0 tl level in ()
      end
  
  axiom restrict_sound'0_spec : forall self : Trail'0.t_trail, level : int . ([%#span83] sound'2 self)
   -> ([%#span84] sound'2 (restrict'0 self level))
  
  use Cdsat_Theory_Normal_Type as Normal'0
  
  predicate satisfied_by'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 677 4 677 47] (self : Trail'0.t_trail) (m : Model'0.t_model)
    
   =
    [%#span86] forall a : (Term'0.t_term, Value'0.t_value) . contains'1 self a  -> satisfies'0 m a
  
  predicate unsat'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 684 4 684 30] (self : Trail'0.t_trail) =
    [%#span87] forall m : Model'0.t_model . inv'0 m  -> satisfied_by'0 (restrict'0 self 0) m  -> false
  
  predicate impls'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 697 4 697 41] (self : Trail'0.t_trail) (rhs : Trail'0.t_trail)
    
   =
    [%#span89] forall m : Model'0.t_model . inv'0 m
     -> satisfied_by'0 (restrict'0 self 0) m  -> satisfied_by'0 (restrict'0 rhs 0) m
  
  axiom impls'0_spec : forall self : Trail'0.t_trail, rhs : Trail'0.t_trail . [%#span88] impls'0 self rhs
   -> unsat'0 rhs  -> unsat'0 self
  
  use Cdsat_Theory_Normal_Type as Cdsat_Theory_Normal_Type
  
  predicate sound'1 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 829 4 829 30] (self : Normal'0.t_normal)
    
   =
    [%#span90] sound'2 (Cdsat_Theory_Normal_Type.normal_0 self)
  
  constant self  : Conflict'0.t_conflict
  
  constant l  : (Term'0.t_term, Value'0.t_value)
  
  constant tgt  : Normal'0.t_normal
  
  predicate backjump [#"/Users/xavier/Code/cdsat/src/theory.rs" 1070 4 1070 64] (self : Conflict'0.t_conflict) (l : (Term'0.t_term, Value'0.t_value)) (tgt : Normal'0.t_normal)
    
  
  goal vc_backjump : ([%#stheory1] sound'0 self)
   -> ([%#stheory0] invariant'0 self)
   -> (let e = remove'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) l in let _ = restrict_sound'0 in let _ = trail_plausible'0 in let _ = restrict_idempotent'0 in let _ = negate_involutive'0 in let _ = learn_justified'0 in ([%#stheory5] invariant_nonneg'0 (Cdsat_Theory_Conflict_Type.conflict_0 self))
  /\ (([%#stheory10] set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) e
  <= level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self))
  && ([%#stheory9] set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) e >= 0)
  && ([%#stheory8] e = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
   -> set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) e = 0)
  && ([%#stheory7] e <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
   -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'0 e i
  /\ level_of'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) i
  = set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) e))
  && ([%#stheory6] forall i : (Term'0.t_term, Value'0.t_value) . contains'0 e i
   -> level_of'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) i
  <= set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) e)
   -> (let restricted = restrict'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) e) in if contains'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) l then
    if is_bool'0 (let (_, a) = l in a) then
      if is_bool'1 (let (a, _) = l in a) then
        ([%#stheory12] invariant_nonneg'0 (Cdsat_Theory_Conflict_Type.conflict_0 self))
        /\ (([%#stheory13] level_of'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) l >= 0
        /\ level_of'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) l
        <= level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self))
         -> ([%#stheory5] invariant_nonneg'0 (Cdsat_Theory_Conflict_Type.conflict_0 self))
        /\ (([%#stheory10] set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) e
        <= level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self))
        && ([%#stheory9] set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) e >= 0)
        && ([%#stheory8] e = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
         -> set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) e = 0)
        && ([%#stheory7] e <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
         -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'0 e i
        /\ level_of'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) i
        = set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) e))
        && ([%#stheory6] forall i : (Term'0.t_term, Value'0.t_value) . contains'0 e i
         -> level_of'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) i
        <= set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) e)
         -> (if level_of'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) l
        > set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) e then
          ([%#stheory14] is_bool'0 (let (_, a) = l in a))
          /\ (([%#stheory15] is_bool'0 (negate'0 (let (_, a) = l in a)))
           -> ([%#stheory5] invariant_nonneg'0 restricted)
          /\ (([%#stheory10] set_level'0 restricted e <= level'0 restricted)
          && ([%#stheory9] set_level'0 restricted e >= 0)
          && ([%#stheory8] e = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
           -> set_level'0 restricted e = 0)
          && ([%#stheory7] e <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
           -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'0 e i
          /\ level_of'0 restricted i = set_level'0 restricted e))
          && ([%#stheory6] forall i : (Term'0.t_term, Value'0.t_value) . contains'0 e i
           -> level_of'0 restricted i <= set_level'0 restricted e)
           -> (let result = Cdsat_Theory_Normal_Type.normal_0 tgt
          = Trail'0.C_Assign (Assign'0.C_Justified e (let (a, _) = l in a) (negate'0 (let (_, a) = l in a))) (set_level'0 restricted e) restricted in ([%#stheory4] result
           -> impls'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (Cdsat_Theory_Normal_Type.normal_0 tgt))
          && ([%#stheory3] result  -> sound'1 tgt)
          && ([%#stheory2] result  -> invariant'1 (Cdsat_Theory_Normal_Type.normal_0 tgt)))))
        else
          let result = false in ([%#stheory4] result
           -> impls'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (Cdsat_Theory_Normal_Type.normal_0 tgt))
          && ([%#stheory3] result  -> sound'1 tgt)
          && ([%#stheory2] result  -> invariant'1 (Cdsat_Theory_Normal_Type.normal_0 tgt))
        )))
      else
        let result = false in ([%#stheory4] result
         -> impls'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (Cdsat_Theory_Normal_Type.normal_0 tgt))
        && ([%#stheory3] result  -> sound'1 tgt)
        && ([%#stheory2] result  -> invariant'1 (Cdsat_Theory_Normal_Type.normal_0 tgt))
      
    else
      let result = false in ([%#stheory4] result
       -> impls'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (Cdsat_Theory_Normal_Type.normal_0 tgt))
      && ([%#stheory3] result  -> sound'1 tgt)
      && ([%#stheory2] result  -> invariant'1 (Cdsat_Theory_Normal_Type.normal_0 tgt))
    
  else
    let result = false in ([%#stheory4] result
     -> impls'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (Cdsat_Theory_Normal_Type.normal_0 tgt))
    && ([%#stheory3] result  -> sound'1 tgt)
    && ([%#stheory2] result  -> invariant'1 (Cdsat_Theory_Normal_Type.normal_0 tgt))
  )))
end
module Cdsat_Theory_Impl7_Backjump2Pre_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 1092 4 1092 91
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 406 15 406 38
  
  let%span stheory2 = "/Users/xavier/Code/cdsat/src/theory.rs" 407 14 407 51
  
  let%span stheory3 = "/Users/xavier/Code/cdsat/src/theory.rs" 281 15 281 38
  
  let%span stheory4 = "/Users/xavier/Code/cdsat/src/theory.rs" 282 4 282 74
  
  let%span stheory5 = "/Users/xavier/Code/cdsat/src/theory.rs" 283 4 283 94
  
  let%span stheory6 = "/Users/xavier/Code/cdsat/src/theory.rs" 284 4 284 48
  
  let%span stheory7 = "/Users/xavier/Code/cdsat/src/theory.rs" 285 14 285 25
  
  let%span stheory8 = "/Users/xavier/Code/cdsat/src/theory.rs" 286 14 286 36
  
  let%span stheory9 = "/Users/xavier/Code/cdsat/src/theory.rs" 280 14 280 21
  
  let%span span10 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span11 = "/Users/xavier/Code/cdsat/src/theory.rs" 157 8 159 9
  
  let%span span12 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span13 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  let%span span14 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span span15 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span16 = "/Users/xavier/Code/cdsat/src/theory.rs" 601 8 605 9
  
  let%span span17 = "/Users/xavier/Code/cdsat/src/theory.rs" 337 8 340 9
  
  let%span span18 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span19 = "/Users/xavier/Code/cdsat/src/theory.rs" 60 8 60 36
  
  let%span span20 = "/Users/xavier/Code/cdsat/src/theory.rs" 82 8 82 36
  
  let%span span21 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 16 8 16 26
  
  let%span span22 = "/Users/xavier/Code/cdsat/src/theory.rs" 167 18 167 22
  
  let%span span23 = "/Users/xavier/Code/cdsat/src/theory.rs" 166 4 166 62
  
  let%span span24 = "/Users/xavier/Code/cdsat/src/theory.rs" 168 8 188 9
  
  let%span span25 = "/Users/xavier/Code/cdsat/src/theory.rs" 194 8 194 31
  
  let%span span26 = "/Users/xavier/Code/cdsat/src/theory.rs" 200 8 200 71
  
  let%span span27 = "/Users/xavier/Code/cdsat/src/theory.rs" 142 8 147 9
  
  let%span span28 = "/Users/xavier/Code/cdsat/src/theory.rs" 262 8 265 9
  
  let%span span29 = "/Users/xavier/Code/cdsat/src/theory.rs" 999 8 999 91
  
  let%span span30 = "/Users/xavier/Code/cdsat/src/theory.rs" 122 8 126 9
  
  let%span span31 = "/Users/xavier/Code/cdsat/src/theory.rs" 346 8 349 9
  
  let%span span32 = "/Users/xavier/Code/cdsat/src/theory.rs" 132 8 136 9
  
  let%span span33 = "/Users/xavier/Code/cdsat/src/theory.rs" 465 14 468 5
  
  let%span span34 = "/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 111
  
  let%span span35 = "/Users/xavier/Code/cdsat/src/theory.rs" 470 4 470 104
  
  let%span span36 = "/Users/xavier/Code/cdsat/src/theory.rs" 472 8 481 9
  
  let%span span37 = "/Users/xavier/Code/cdsat/src/theory.rs" 417 4 417 87
  
  let%span span38 = "/Users/xavier/Code/cdsat/src/theory.rs" 419 8 422 9
  
  let%span span39 = "/Users/xavier/Code/cdsat/src/theory.rs" 96 15 96 29
  
  let%span span40 = "/Users/xavier/Code/cdsat/src/theory.rs" 97 14 97 30
  
  let%span span41 = "/Users/xavier/Code/cdsat/src/theory.rs" 99 8 102 9
  
  let%span span42 = "/Users/xavier/Code/cdsat/src/theory.rs" 374 8 382 9
  
  let%span span43 = "/Users/xavier/Code/cdsat/src/theory.rs" 355 8 368 9
  
  let%span span44 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 53 8 53 26
  
  let%span span45 = "/Users/xavier/Code/cdsat/src/theory.rs" 409 8 412 9
  
  let%span span46 = "/Users/xavier/Code/cdsat/src/theory.rs" 278 4 278 12
  
  let%span span47 = "/Users/xavier/Code/cdsat/src/theory.rs" 321 8 331 9
  
  let%span span48 = "/Users/xavier/Code/cdsat/src/theory.rs" 388 8 392 38
  
  let%span span49 = "/Users/xavier/Code/cdsat/src/theory.rs" 992 8 992 131
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  use Cdsat_Theory_Value_Type as Value'0
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span10] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  use map.Map
  
  use Cdsat_Theory_Model_Type as Cdsat_Theory_Model_Type
  
  use Cdsat_Theory_Var_Type as Var'0
  
  use Cdsat_Theory_Model_Type as Model'0
  
  predicate invariant'3 [#"/Users/xavier/Code/cdsat/src/theory.rs" 156 4 156 30] (self : Model'0.t_model) =
    [%#span11] forall v : Value'0.t_value . forall k : Var'0.t_var . Map.get (Cdsat_Theory_Model_Type.model_0 self) k
    = v  -> Cdsat_Theory_Var_Type.var_1 k = sort'0 v
  
  predicate inv'0 (_x : Model'0.t_model)
  
  axiom inv'0 : forall x : Model'0.t_model . inv'0 x
  = (invariant'3 x
  /\ match x with
    | Model'0.C_Model a_0 -> true
    end)
  
  use set.Fset
  
  use set.Fset
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  use prelude.prelude.Int
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span13] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span12] len'0 self >= 0
  
  function level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int =
    [%#span16] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> 1 + level'0 tl
      | Trail'0.C_Assign _ _ tl -> level'0 tl
      end
  
  axiom level'0_spec : forall self : Trail'0.t_trail . ([%#span15] level'0 self <= len'0 self)
  && ([%#span14] level'0 self >= 0)
  
  predicate invariant_nonneg'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 336 4 336 41] (self : Trail'0.t_trail) =
    [%#span17] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_nonneg'0 tl /\ l >= 0 /\ l <= level'0 self
      end
  
  use Cdsat_Theory_Term_Type as Term'0
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span18] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'0 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  predicate is_bool'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 59 4 59 32] (self : Term'0.t_term) =
    [%#span19] sort'1 self = Sort'0.C_Boolean
  
  predicate is_bool'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 81 4 81 32] (self : Value'0.t_value) =
    [%#span20] sort'0 self = Sort'0.C_Boolean
  
  use set.Fset
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (e : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span21] Fset.mem e self
  
  use prelude.prelude.Real
  
  function from_int'0 (_1 : int) : Real.real
  
  function interp'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 167 4 167 41] (self : Model'0.t_model) (t : Term'0.t_term) : Value'0.t_value
    
   =
    [%#span24] match t with
      | Term'0.C_Variable v -> Map.get (Cdsat_Theory_Model_Type.model_0 self) v
      | Term'0.C_Value v -> v
      | Term'0.C_Plus l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Rat r1, Value'0.C_Rat r2) -> Value'0.C_Rat r1
        | _ -> Value'0.C_Rat (from_int'0 (- 1))
        end
      | Term'0.C_Conj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 /\ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Disj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 \/ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Eq l r -> Value'0.C_Bool (interp'0 self l = interp'0 self r)
      | Term'0.C_Neg t -> match interp'0 self t with
        | Value'0.C_Bool b -> Value'0.C_Bool (not b)
        | _ -> Value'0.C_Bool false
        end
      end
  
  axiom interp'0_spec : forall self : Model'0.t_model, t : Term'0.t_term . ([%#span22] inv'0 self)
   -> ([%#span23] invariant'3 self  -> sort'0 (interp'0 self t) = sort'1 t)
  
  predicate satisfies'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 193 4 193 52] (self : Model'0.t_model) (v : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span25] interp'0 self (let (a, _) = v in a) = (let (_, a) = v in a)
  
  predicate satisfy_set'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 199 4 199 60] (self : Model'0.t_model) (v : Fset.fset (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span26] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 v a  -> satisfies'0 self a
  
  use Cdsat_Theory_Conflict_Type as Cdsat_Theory_Conflict_Type
  
  predicate justified_sound'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 141 4 141 40] (self : Assign'0.t_assign) =
    [%#span27] match self with
      | Assign'0.C_Justified just t val' -> forall m : Model'0.t_model . inv'0 m
       -> satisfy_set'0 m just  -> satisfies'0 m (t, val')
      | _ -> true
      end
  
  predicate sound'1 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 261 4 261 30] (self : Trail'0.t_trail)
   =
    [%#span28] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a _ tl -> sound'1 tl /\ justified_sound'0 a
      end
  
  use Cdsat_Theory_Conflict_Type as Conflict'0
  
  predicate sound'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 998 4 998 30] (self : Conflict'0.t_conflict)
    
   =
    [%#span29] sound'1 (Cdsat_Theory_Conflict_Type.conflict_0 self)
    /\ (forall m : Model'0.t_model . inv'0 m  -> satisfy_set'0 m (Cdsat_Theory_Conflict_Type.conflict_1 self)  -> false)
  
  use prelude.prelude.Int
  
  predicate invariant'2 [#"/Users/xavier/Code/cdsat/src/theory.rs" 121 4 121 34] (self : Assign'0.t_assign) =
    [%#span30] match self with
      | Assign'0.C_Decision t v -> sort'1 t = sort'0 v
      | Assign'0.C_Justified _ t v -> sort'1 t = sort'0 v /\ sort'1 t = Sort'0.C_Boolean
      | Assign'0.C_Input t v -> sort'1 t = sort'0 v
      end
  
  predicate invariant_assign'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 345 4 345 41] (self : Trail'0.t_trail) =
    [%#span31] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_assign'0 tl /\ invariant'2 a
      end
  
  function to_pair'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 131 4 131 41] (self : Assign'0.t_assign) : (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span32] match self with
      | Assign'0.C_Decision t val' -> (t, val')
      | Assign'0.C_Input t val' -> (t, val')
      | Assign'0.C_Justified _ t val' -> (t, val')
      end
  
  use Core_Option_Option_Type as Option'0
  
  function find'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 471 4 471 64] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Option'0.t_option (Assign'0.t_assign, int)
    
   =
    [%#span36] match self with
      | Trail'0.C_Empty -> Option'0.C_None
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then Option'0.C_Some (a, l) else find'0 tl d
      end
  
  axiom find'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span35] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'1 (let (a, _) = d in a) = sort'0 (let (_, a) = d in a)))
  && ([%#span34] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'0 self))
  && ([%#span33] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
  
  predicate contains'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 418 4 418 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span38] match find'0 self d with
      | Option'0.C_Some ix -> true
      | Option'0.C_None -> false
      end
  
  axiom contains'1_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . [%#span37] invariant_assign'0 self
   -> contains'1 self d = true  -> sort'1 (let (a, _) = d in a) = sort'0 (let (_, a) = d in a)
  
  function negate'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 98 4 98 31] (self : Value'0.t_value) : Value'0.t_value =
    [%#span41] match self with
      | Value'0.C_Bool b -> Value'0.C_Bool (not b)
      | _ -> self
      end
  
  axiom negate'0_spec : forall self : Value'0.t_value . ([%#span39] is_bool'0 self)
   -> ([%#span40] is_bool'0 (negate'0 self))
  
  predicate trail_unique'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 373 4 373 37] (self : Trail'0.t_trail) =
    [%#span42] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> let ap = to_pair'0 a in not contains'1 tl ap
      /\ trail_unique'0 tl
      /\ (if is_bool'0 (let (_, a) = ap in a) then
        not contains'1 tl ((let (a, _) = ap in a), negate'0 (let (_, a) = ap in a))
      else
        true
      )
      end
  
  predicate invariant_contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 354 4 354 43] (self : Trail'0.t_trail) =
    [%#span43] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_contains'0 tl
      /\ match a with
        | Assign'0.C_Justified j _ _ -> forall a : (Term'0.t_term, Value'0.t_value) . contains'0 j a  -> contains'1 tl a
        | _ -> true
        end
      end
  
  use set.Fset
  
  function remove'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (a : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span44] Fset.remove a self
  
  use set.Fset
  
  function level_of'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 408 4 408 50] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : int
    
   =
    [%#span45] match find'0 self d with
      | Option'0.C_Some (_, l) -> l
      | Option'0.C_None -> 0
      end
  
  axiom level_of'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#stheory1] invariant_nonneg'0 self)
   -> ([%#stheory2] level_of'0 self d >= 0 /\ level_of'0 self d <= level'0 self)
  
  function set_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 287 4 287 57] (self : Trail'0.t_trail) (s : Fset.fset (Term'0.t_term, Value'0.t_value)) : int
    
  
  axiom set_level'0_def : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . set_level'0 self s
  = ([%#span46] if Fset.cardinal s = 0 then
    0
  else
    if Fset.cardinal s = 1 then
      level_of'0 self (Fset.pick s)
    else
      let a = Fset.pick s in let rec' = set_level'0 self (remove'0 s a) in if level_of'0 self a >= rec' then
        level_of'0 self a
      else
        rec'
      
    
  )
  
  axiom set_level'0_spec : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . ([%#stheory3] invariant_nonneg'0 self)
   -> ([%#stheory8] set_level'0 self s <= level'0 self)
  && ([%#stheory7] set_level'0 self s >= 0)
  && ([%#stheory6] s = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))  -> set_level'0 self s = 0)
  && ([%#stheory5] s <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
   -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'0 s i /\ level_of'0 self i = set_level'0 self s))
  && ([%#stheory4] forall i : (Term'0.t_term, Value'0.t_value) . contains'0 s i
   -> level_of'0 self i <= set_level'0 self s)
  
  predicate invariant_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 320 4 320 40] (self : Trail'0.t_trail) =
    [%#span47] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_level'0 tl
      /\ match a with
        | Assign'0.C_Input _ _ -> l = 0
        | Assign'0.C_Decision _ _ -> level'0 tl + 1 = l
        | Assign'0.C_Justified j _ _ -> set_level'0 tl j = l
        end
      end
  
  predicate invariant'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 387 4 387 34] (self : Trail'0.t_trail) =
    [%#span48] invariant_level'0 self
    /\ invariant_contains'0 self /\ trail_unique'0 self /\ invariant_nonneg'0 self /\ invariant_assign'0 self
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 991 4 991 34] (self : Conflict'0.t_conflict) =
    [%#span49] set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (Cdsat_Theory_Conflict_Type.conflict_1 self) > 0
    /\ invariant'1 (Cdsat_Theory_Conflict_Type.conflict_0 self)
    /\ (forall a : (Term'0.t_term, Value'0.t_value) . contains'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) a
     -> contains'1 (Cdsat_Theory_Conflict_Type.conflict_0 self) a)
  
  constant self  : Conflict'0.t_conflict
  
  constant l  : (Term'0.t_term, Value'0.t_value)
  
  predicate backjump2_pre [#"/Users/xavier/Code/cdsat/src/theory.rs" 1093 4 1093 56] (self : Conflict'0.t_conflict) (l : (Term'0.t_term, Value'0.t_value))
    
  
  goal vc_backjump2_pre : if invariant'0 self then
    if sound'0 self then
      if contains'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) l then
        if is_bool'0 (let (_, a) = l in a) then
          if is_bool'1 (let (a, _) = l in a) then
            ([%#stheory1] invariant_nonneg'0 (Cdsat_Theory_Conflict_Type.conflict_0 self))
            /\ (([%#stheory2] level_of'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) l >= 0
            /\ level_of'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) l
            <= level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self))
             -> ([%#stheory3] invariant_nonneg'0 (Cdsat_Theory_Conflict_Type.conflict_0 self))
            /\ (([%#stheory8] set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (remove'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) l)
            <= level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self))
            && ([%#stheory7] set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (remove'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) l)
            >= 0)
            && ([%#stheory6] remove'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) l
            = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
             -> set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (remove'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) l)
            = 0)
            && ([%#stheory5] remove'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) l
            <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
             -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'0 (remove'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) l) i
            /\ level_of'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) i
            = set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (remove'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) l)))
            && ([%#stheory4] forall i : (Term'0.t_term, Value'0.t_value) . contains'0 (remove'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) l) i
             -> level_of'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) i
            <= set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (remove'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) l))
             -> ([%#stheory0] (level_of'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) l
            > set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (remove'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) l))
            = true
             -> set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (remove'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) l)
            <= level_of'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) l)))
          else
            [%#stheory0] false = true
             -> set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (remove'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) l)
            <= level_of'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) l
          
        else
          [%#stheory0] false = true
           -> set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (remove'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) l)
          <= level_of'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) l
        
      else
        [%#stheory0] false = true
         -> set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (remove'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) l)
        <= level_of'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) l
      
    else
      [%#stheory0] false = true
       -> set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (remove'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) l)
      <= level_of'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) l
    
  else
    [%#stheory0] false = true
     -> set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (remove'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) l)
    <= level_of'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) l
  
end
module Cdsat_Theory_Impl7_UndoClear_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 1154 15 1154 31
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 1155 15 1155 27
  
  let%span stheory2 = "/Users/xavier/Code/cdsat/src/theory.rs" 1156 4 1156 44
  
  let%span stheory3 = "/Users/xavier/Code/cdsat/src/theory.rs" 1157 4 1157 38
  
  let%span stheory4 = "/Users/xavier/Code/cdsat/src/theory.rs" 1158 4 1158 46
  
  let%span stheory5 = "/Users/xavier/Code/cdsat/src/theory.rs" 705 15 705 27
  
  let%span stheory6 = "/Users/xavier/Code/cdsat/src/theory.rs" 706 14 706 42
  
  let%span stheory7 = "/Users/xavier/Code/cdsat/src/theory.rs" 774 15 774 31
  
  let%span stheory8 = "/Users/xavier/Code/cdsat/src/theory.rs" 775 15 775 33
  
  let%span stheory9 = "/Users/xavier/Code/cdsat/src/theory.rs" 776 15 776 23
  
  let%span stheory10 = "/Users/xavier/Code/cdsat/src/theory.rs" 777 14 777 65
  
  let%span stheory11 = "/Users/xavier/Code/cdsat/src/theory.rs" 1160 8 1166 11
  
  let%span span12 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span13 = "/Users/xavier/Code/cdsat/src/theory.rs" 157 8 159 9
  
  let%span span14 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span15 = "/Users/xavier/Code/cdsat/src/theory.rs" 122 8 126 9
  
  let%span span16 = "/Users/xavier/Code/cdsat/src/theory.rs" 346 8 349 9
  
  let%span span17 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span18 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  let%span span19 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span span20 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span21 = "/Users/xavier/Code/cdsat/src/theory.rs" 601 8 605 9
  
  let%span span22 = "/Users/xavier/Code/cdsat/src/theory.rs" 337 8 340 9
  
  let%span span23 = "/Users/xavier/Code/cdsat/src/theory.rs" 132 8 136 9
  
  let%span span24 = "/Users/xavier/Code/cdsat/src/theory.rs" 465 14 468 5
  
  let%span span25 = "/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 111
  
  let%span span26 = "/Users/xavier/Code/cdsat/src/theory.rs" 470 4 470 104
  
  let%span span27 = "/Users/xavier/Code/cdsat/src/theory.rs" 472 8 481 9
  
  let%span span28 = "/Users/xavier/Code/cdsat/src/theory.rs" 406 15 406 38
  
  let%span span29 = "/Users/xavier/Code/cdsat/src/theory.rs" 407 14 407 51
  
  let%span span30 = "/Users/xavier/Code/cdsat/src/theory.rs" 409 8 412 9
  
  let%span span31 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 16 8 16 26
  
  let%span span32 = "/Users/xavier/Code/cdsat/src/theory.rs" 272 12 274 67
  
  let%span span33 = "/Users/xavier/Code/cdsat/src/theory.rs" 82 8 82 36
  
  let%span span34 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 53 8 53 26
  
  let%span span35 = "/Users/xavier/Code/cdsat/src/theory.rs" 417 4 417 87
  
  let%span span36 = "/Users/xavier/Code/cdsat/src/theory.rs" 419 8 422 9
  
  let%span span37 = "/Users/xavier/Code/cdsat/src/theory.rs" 96 15 96 29
  
  let%span span38 = "/Users/xavier/Code/cdsat/src/theory.rs" 97 14 97 30
  
  let%span span39 = "/Users/xavier/Code/cdsat/src/theory.rs" 99 8 102 9
  
  let%span span40 = "/Users/xavier/Code/cdsat/src/theory.rs" 374 8 382 9
  
  let%span span41 = "/Users/xavier/Code/cdsat/src/theory.rs" 355 8 368 9
  
  let%span span42 = "/Users/xavier/Code/cdsat/src/theory.rs" 281 15 281 38
  
  let%span span43 = "/Users/xavier/Code/cdsat/src/theory.rs" 282 4 282 74
  
  let%span span44 = "/Users/xavier/Code/cdsat/src/theory.rs" 283 4 283 94
  
  let%span span45 = "/Users/xavier/Code/cdsat/src/theory.rs" 284 4 284 48
  
  let%span span46 = "/Users/xavier/Code/cdsat/src/theory.rs" 285 14 285 25
  
  let%span span47 = "/Users/xavier/Code/cdsat/src/theory.rs" 286 14 286 36
  
  let%span span48 = "/Users/xavier/Code/cdsat/src/theory.rs" 280 14 280 21
  
  let%span span49 = "/Users/xavier/Code/cdsat/src/theory.rs" 278 4 278 12
  
  let%span span50 = "/Users/xavier/Code/cdsat/src/theory.rs" 321 8 331 9
  
  let%span span51 = "/Users/xavier/Code/cdsat/src/theory.rs" 388 8 392 38
  
  let%span span52 = "/Users/xavier/Code/cdsat/src/theory.rs" 741 15 741 31
  
  let%span span53 = "/Users/xavier/Code/cdsat/src/theory.rs" 742 4 742 83
  
  let%span span54 = "/Users/xavier/Code/cdsat/src/theory.rs" 744 8 749 9
  
  let%span span55 = "/Users/xavier/Code/cdsat/src/theory.rs" 562 8 573 9
  
  let%span span56 = "/Users/xavier/Code/cdsat/src/theory.rs" 779 8 782 9
  
  let%span span57 = "/Users/xavier/Code/cdsat/src/theory.rs" 167 18 167 22
  
  let%span span58 = "/Users/xavier/Code/cdsat/src/theory.rs" 166 4 166 62
  
  let%span span59 = "/Users/xavier/Code/cdsat/src/theory.rs" 168 8 188 9
  
  let%span span60 = "/Users/xavier/Code/cdsat/src/theory.rs" 194 8 194 31
  
  let%span span61 = "/Users/xavier/Code/cdsat/src/theory.rs" 200 8 200 71
  
  let%span span62 = "/Users/xavier/Code/cdsat/src/theory.rs" 142 8 147 9
  
  let%span span63 = "/Users/xavier/Code/cdsat/src/theory.rs" 262 8 265 9
  
  let%span span64 = "/Users/xavier/Code/cdsat/src/theory.rs" 708 8 713 9
  
  let%span span65 = "/Users/xavier/Code/cdsat/src/theory.rs" 1002 4 1002 12
  
  let%span span66 = "/Users/xavier/Code/cdsat/src/theory.rs" 678 8 678 71
  
  let%span span67 = "/Users/xavier/Code/cdsat/src/theory.rs" 685 8 685 82
  
  let%span span68 = "/Users/xavier/Code/cdsat/src/theory.rs" 696 4 696 55
  
  let%span span69 = "/Users/xavier/Code/cdsat/src/theory.rs" 698 8 698 108
  
  let%span span70 = "/Users/xavier/Code/cdsat/src/theory.rs" 826 4 826 16
  
  let%span span71 = "/Users/xavier/Code/cdsat/src/theory.rs" 999 8 999 91
  
  let%span span72 = "/Users/xavier/Code/cdsat/src/theory.rs" 992 8 992 131
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  use Cdsat_Theory_Value_Type as Value'0
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span12] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  use map.Map
  
  use Cdsat_Theory_Model_Type as Cdsat_Theory_Model_Type
  
  use Cdsat_Theory_Var_Type as Var'0
  
  use Cdsat_Theory_Model_Type as Model'0
  
  predicate invariant'3 [#"/Users/xavier/Code/cdsat/src/theory.rs" 156 4 156 30] (self : Model'0.t_model) =
    [%#span13] forall v : Value'0.t_value . forall k : Var'0.t_var . Map.get (Cdsat_Theory_Model_Type.model_0 self) k
    = v  -> Cdsat_Theory_Var_Type.var_1 k = sort'0 v
  
  predicate inv'0 (_x : Model'0.t_model)
  
  axiom inv'0 : forall x : Model'0.t_model . inv'0 x
  = (invariant'3 x
  /\ match x with
    | Model'0.C_Model a_0 -> true
    end)
  
  use prelude.prelude.Int
  
  use Cdsat_Theory_Term_Type as Term'0
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span14] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'0 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  predicate invariant'2 [#"/Users/xavier/Code/cdsat/src/theory.rs" 121 4 121 34] (self : Assign'0.t_assign) =
    [%#span15] match self with
      | Assign'0.C_Decision t v -> sort'1 t = sort'0 v
      | Assign'0.C_Justified _ t v -> sort'1 t = sort'0 v /\ sort'1 t = Sort'0.C_Boolean
      | Assign'0.C_Input t v -> sort'1 t = sort'0 v
      end
  
  predicate invariant_assign'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 345 4 345 41] (self : Trail'0.t_trail) =
    [%#span16] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_assign'0 tl /\ invariant'2 a
      end
  
  use prelude.prelude.Int
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span18] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span17] len'0 self >= 0
  
  function level'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int =
    [%#span21] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> 1 + level'1 tl
      | Trail'0.C_Assign _ _ tl -> level'1 tl
      end
  
  axiom level'1_spec : forall self : Trail'0.t_trail . ([%#span20] level'1 self <= len'0 self)
  && ([%#span19] level'1 self >= 0)
  
  predicate invariant_nonneg'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 336 4 336 41] (self : Trail'0.t_trail) =
    [%#span22] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_nonneg'0 tl /\ l >= 0 /\ l <= level'1 self
      end
  
  function to_pair'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 131 4 131 41] (self : Assign'0.t_assign) : (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span23] match self with
      | Assign'0.C_Decision t val' -> (t, val')
      | Assign'0.C_Input t val' -> (t, val')
      | Assign'0.C_Justified _ t val' -> (t, val')
      end
  
  use Core_Option_Option_Type as Option'0
  
  function find'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 471 4 471 64] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Option'0.t_option (Assign'0.t_assign, int)
    
   =
    [%#span27] match self with
      | Trail'0.C_Empty -> Option'0.C_None
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then Option'0.C_Some (a, l) else find'0 tl d
      end
  
  axiom find'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span26] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'1 (let (a, _) = d in a) = sort'0 (let (_, a) = d in a)))
  && ([%#span25] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'1 self))
  && ([%#span24] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
  
  function level_of'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 408 4 408 50] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : int
    
   =
    [%#span30] match find'0 self d with
      | Option'0.C_Some (_, l) -> l
      | Option'0.C_None -> 0
      end
  
  axiom level_of'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span28] invariant_nonneg'0 self)
   -> ([%#span29] level_of'0 self d >= 0 /\ level_of'0 self d <= level'1 self)
  
  use set.Fset
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (e : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span31] Fset.mem e self
  
  use set.Fset
  
  predicate is_set_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 270 4 270 69] (self : Trail'0.t_trail) (s : Fset.fset (Term'0.t_term, Value'0.t_value)) (m : int)
    
   =
    [%#span32] s = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value)) /\ m = 0
    \/ (exists i : (Term'0.t_term, Value'0.t_value) . contains'0 s i /\ level_of'0 self i = m)
    /\ (forall i : (Term'0.t_term, Value'0.t_value) . contains'0 s i  -> level_of'0 self i <= m)
  
  predicate is_bool'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 81 4 81 32] (self : Value'0.t_value) =
    [%#span33] sort'0 self = Sort'0.C_Boolean
  
  use set.Fset
  
  function remove'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (a : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span34] Fset.remove a self
  
  use Cdsat_Theory_Conflict_Type as Cdsat_Theory_Conflict_Type
  
  predicate contains'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 418 4 418 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span36] match find'0 self d with
      | Option'0.C_Some ix -> true
      | Option'0.C_None -> false
      end
  
  axiom contains'1_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . [%#span35] invariant_assign'0 self
   -> contains'1 self d = true  -> sort'1 (let (a, _) = d in a) = sort'0 (let (_, a) = d in a)
  
  function negate'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 98 4 98 31] (self : Value'0.t_value) : Value'0.t_value =
    [%#span39] match self with
      | Value'0.C_Bool b -> Value'0.C_Bool (not b)
      | _ -> self
      end
  
  axiom negate'0_spec : forall self : Value'0.t_value . ([%#span37] is_bool'0 self)
   -> ([%#span38] is_bool'0 (negate'0 self))
  
  predicate trail_unique'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 373 4 373 37] (self : Trail'0.t_trail) =
    [%#span40] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> let ap = to_pair'0 a in not contains'1 tl ap
      /\ trail_unique'0 tl
      /\ (if is_bool'0 (let (_, a) = ap in a) then
        not contains'1 tl ((let (a, _) = ap in a), negate'0 (let (_, a) = ap in a))
      else
        true
      )
      end
  
  predicate invariant_contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 354 4 354 43] (self : Trail'0.t_trail) =
    [%#span41] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_contains'0 tl
      /\ match a with
        | Assign'0.C_Justified j _ _ -> forall a : (Term'0.t_term, Value'0.t_value) . contains'0 j a  -> contains'1 tl a
        | _ -> true
        end
      end
  
  use set.Fset
  
  use set.Fset
  
  function set_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 287 4 287 57] (self : Trail'0.t_trail) (s : Fset.fset (Term'0.t_term, Value'0.t_value)) : int
    
  
  axiom set_level'0_def : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . set_level'0 self s
  = ([%#span49] if Fset.cardinal s = 0 then
    0
  else
    if Fset.cardinal s = 1 then
      level_of'0 self (Fset.pick s)
    else
      let a = Fset.pick s in let rec' = set_level'0 self (remove'0 s a) in if level_of'0 self a >= rec' then
        level_of'0 self a
      else
        rec'
      
    
  )
  
  axiom set_level'0_spec : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . ([%#span42] invariant_nonneg'0 self)
   -> ([%#span47] set_level'0 self s <= level'1 self)
  && ([%#span46] set_level'0 self s >= 0)
  && ([%#span45] s = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))  -> set_level'0 self s = 0)
  && ([%#span44] s <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
   -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'0 s i /\ level_of'0 self i = set_level'0 self s))
  && ([%#span43] forall i : (Term'0.t_term, Value'0.t_value) . contains'0 s i
   -> level_of'0 self i <= set_level'0 self s)
  
  predicate invariant_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 320 4 320 40] (self : Trail'0.t_trail) =
    [%#span50] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_level'0 tl
      /\ match a with
        | Assign'0.C_Input _ _ -> l = 0
        | Assign'0.C_Decision _ _ -> level'1 tl + 1 = l
        | Assign'0.C_Justified j _ _ -> set_level'0 tl j = l
        end
      end
  
  predicate invariant'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 387 4 387 34] (self : Trail'0.t_trail) =
    [%#span51] invariant_level'0 self
    /\ invariant_contains'0 self /\ trail_unique'0 self /\ invariant_nonneg'0 self /\ invariant_assign'0 self
  
  function count_bounds'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 743 4 743 35] (self : Trail'0.t_trail) : () =
    [%#span54] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign (Assign'0.C_Input _ _) _ tl -> count_bounds'0 tl
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> count_bounds'0 tl
      | Trail'0.C_Assign (Assign'0.C_Justified _ _ _) _ tl -> count_bounds'0 tl
      end
  
  axiom count_bounds'0_spec : forall self : Trail'0.t_trail . ([%#span52] invariant'1 self)
   -> ([%#span53] forall a : (Term'0.t_term, Value'0.t_value) . contains'1 self a  -> level_of'0 self a <= level'1 self)
  
  function restrict'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 561 4 561 45] (self : Trail'0.t_trail) (level : int) : Trail'0.t_trail
    
   =
    [%#span55] match self with
      | Trail'0.C_Empty -> Trail'0.C_Empty
      | Trail'0.C_Assign a l tl -> let tl = restrict'0 tl level in let _ = count_bounds'0 tl in if l <= level then
        Trail'0.C_Assign a l tl
      else
        tl
      
      end
  
  function restrict_idempotent'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 778 4 778 54] (self : Trail'0.t_trail) (l1 : int) (l2 : int) : ()
    
   =
    [%#span56] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign _ _ tl -> restrict_idempotent'0 tl l1 l2
      end
  
  axiom restrict_idempotent'0_spec : forall self : Trail'0.t_trail, l1 : int, l2 : int . ([%#stheory7] invariant'1 self)
   -> ([%#stheory8] l1 >= 0 /\ l2 >= 0)
   -> ([%#stheory9] l1 <= l2)  -> ([%#stheory10] restrict'0 self l1 = restrict'0 (restrict'0 self l2) l1)
  
  use prelude.prelude.Real
  
  function from_int'0 (_1 : int) : Real.real
  
  function interp'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 167 4 167 41] (self : Model'0.t_model) (t : Term'0.t_term) : Value'0.t_value
    
   =
    [%#span59] match t with
      | Term'0.C_Variable v -> Map.get (Cdsat_Theory_Model_Type.model_0 self) v
      | Term'0.C_Value v -> v
      | Term'0.C_Plus l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Rat r1, Value'0.C_Rat r2) -> Value'0.C_Rat r1
        | _ -> Value'0.C_Rat (from_int'0 (- 1))
        end
      | Term'0.C_Conj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 /\ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Disj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 \/ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Eq l r -> Value'0.C_Bool (interp'0 self l = interp'0 self r)
      | Term'0.C_Neg t -> match interp'0 self t with
        | Value'0.C_Bool b -> Value'0.C_Bool (not b)
        | _ -> Value'0.C_Bool false
        end
      end
  
  axiom interp'0_spec : forall self : Model'0.t_model, t : Term'0.t_term . ([%#span57] inv'0 self)
   -> ([%#span58] invariant'3 self  -> sort'0 (interp'0 self t) = sort'1 t)
  
  predicate satisfies'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 193 4 193 52] (self : Model'0.t_model) (v : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span60] interp'0 self (let (a, _) = v in a) = (let (_, a) = v in a)
  
  predicate satisfy_set'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 199 4 199 60] (self : Model'0.t_model) (v : Fset.fset (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span61] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 v a  -> satisfies'0 self a
  
  predicate justified_sound'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 141 4 141 40] (self : Assign'0.t_assign) =
    [%#span62] match self with
      | Assign'0.C_Justified just t val' -> forall m : Model'0.t_model . inv'0 m
       -> satisfy_set'0 m just  -> satisfies'0 m (t, val')
      | _ -> true
      end
  
  predicate sound'2 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 261 4 261 30] (self : Trail'0.t_trail)
   =
    [%#span63] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a _ tl -> sound'2 tl /\ justified_sound'0 a
      end
  
  function restrict_sound'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 707 4 707 43] (self : Trail'0.t_trail) (level : int) : ()
    
   =
    [%#span64] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign a l tl -> let _ = restrict_sound'0 tl level in ()
      end
  
  axiom restrict_sound'0_spec : forall self : Trail'0.t_trail, level : int . ([%#stheory5] sound'2 self)
   -> ([%#stheory6] sound'2 (restrict'0 self level))
  
  use Cdsat_Theory_Conflict_Type as Conflict'0
  
  function level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 1004 4 1004 29] (self : Conflict'0.t_conflict) : int =
    [%#span65] set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (Cdsat_Theory_Conflict_Type.conflict_1 self)
  
  use Cdsat_Theory_Normal_Type as Normal'0
  
  predicate satisfied_by'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 677 4 677 47] (self : Trail'0.t_trail) (m : Model'0.t_model)
    
   =
    [%#span66] forall a : (Term'0.t_term, Value'0.t_value) . contains'1 self a  -> satisfies'0 m a
  
  predicate unsat'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 684 4 684 30] (self : Trail'0.t_trail) =
    [%#span67] forall m : Model'0.t_model . inv'0 m  -> satisfied_by'0 (restrict'0 self 0) m  -> false
  
  predicate impls'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 697 4 697 41] (self : Trail'0.t_trail) (rhs : Trail'0.t_trail)
    
   =
    [%#span69] forall m : Model'0.t_model . inv'0 m
     -> satisfied_by'0 (restrict'0 self 0) m  -> satisfied_by'0 (restrict'0 rhs 0) m
  
  axiom impls'0_spec : forall self : Trail'0.t_trail, rhs : Trail'0.t_trail . [%#span68] impls'0 self rhs
   -> unsat'0 rhs  -> unsat'0 self
  
  use Cdsat_Theory_Normal_Type as Cdsat_Theory_Normal_Type
  
  predicate sound'1 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 829 4 829 30] (self : Normal'0.t_normal)
    
   =
    [%#span70] sound'2 (Cdsat_Theory_Normal_Type.normal_0 self)
  
  predicate sound'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 998 4 998 30] (self : Conflict'0.t_conflict)
    
   =
    [%#span71] sound'2 (Cdsat_Theory_Conflict_Type.conflict_0 self)
    /\ (forall m : Model'0.t_model . inv'0 m  -> satisfy_set'0 m (Cdsat_Theory_Conflict_Type.conflict_1 self)  -> false)
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 991 4 991 34] (self : Conflict'0.t_conflict) =
    [%#span72] set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (Cdsat_Theory_Conflict_Type.conflict_1 self) > 0
    /\ invariant'1 (Cdsat_Theory_Conflict_Type.conflict_0 self)
    /\ (forall a : (Term'0.t_term, Value'0.t_value) . contains'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) a
     -> contains'1 (Cdsat_Theory_Conflict_Type.conflict_0 self) a)
  
  constant self  : Conflict'0.t_conflict
  
  constant a  : (Term'0.t_term, Value'0.t_value)
  
  constant tgt  : Normal'0.t_normal
  
  predicate undo_clear [#"/Users/xavier/Code/cdsat/src/theory.rs" 1159 4 1159 66] (self : Conflict'0.t_conflict) (a : (Term'0.t_term, Value'0.t_value)) (tgt : Normal'0.t_normal)
    
  
  goal vc_undo_clear : ([%#stheory1] sound'0 self)
   -> ([%#stheory0] invariant'0 self)
   -> ([%#stheory5] sound'2 (Cdsat_Theory_Conflict_Type.conflict_0 self))
  /\ (([%#stheory6] sound'2 (restrict'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (level'0 self - 1)))
   -> (let _ = restrict_sound'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (level'0 self - 1) in (([%#stheory9] 0
  <= level'0 self - 1)
  && ([%#stheory8] 0 >= 0 /\ level'0 self - 1 >= 0)
  && ([%#stheory7] invariant'1 (Cdsat_Theory_Conflict_Type.conflict_0 self)))
  /\ (([%#stheory10] restrict'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) 0
  = restrict'0 (restrict'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (level'0 self - 1)) 0)
   -> (let _ = restrict_idempotent'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) 0 (level'0 self
  - 1) in let e = remove'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) a in if contains'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) a then
    if not is_bool'0 (let (_, a) = a in a) then
      if [%#stheory11] exists l : int . l >= 0
      /\ level'0 self > l /\ is_set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) e l then
        let result = Cdsat_Theory_Normal_Type.normal_0 tgt
        = restrict'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (level'0 self - 1) in ([%#stheory4] result
         -> impls'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (Cdsat_Theory_Normal_Type.normal_0 tgt))
        && ([%#stheory3] result  -> sound'1 tgt)
        && ([%#stheory2] result  -> invariant'1 (Cdsat_Theory_Normal_Type.normal_0 tgt))
      else
        let result = false in ([%#stheory4] result
         -> impls'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (Cdsat_Theory_Normal_Type.normal_0 tgt))
        && ([%#stheory3] result  -> sound'1 tgt)
        && ([%#stheory2] result  -> invariant'1 (Cdsat_Theory_Normal_Type.normal_0 tgt))
      
    else
      let result = false in ([%#stheory4] result
       -> impls'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (Cdsat_Theory_Normal_Type.normal_0 tgt))
      && ([%#stheory3] result  -> sound'1 tgt)
      && ([%#stheory2] result  -> invariant'1 (Cdsat_Theory_Normal_Type.normal_0 tgt))
    
  else
    let result = false in ([%#stheory4] result
     -> impls'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (Cdsat_Theory_Normal_Type.normal_0 tgt))
    && ([%#stheory3] result  -> sound'1 tgt)
    && ([%#stheory2] result  -> invariant'1 (Cdsat_Theory_Normal_Type.normal_0 tgt))
  ))))
end
module Cdsat_Theory_Impl7_UndoDecide_Impl
  let%span stheory0 = "/Users/xavier/Code/cdsat/src/theory.rs" 1172 15 1172 31
  
  let%span stheory1 = "/Users/xavier/Code/cdsat/src/theory.rs" 1173 15 1173 27
  
  let%span stheory2 = "/Users/xavier/Code/cdsat/src/theory.rs" 1174 4 1174 39
  
  let%span stheory3 = "/Users/xavier/Code/cdsat/src/theory.rs" 1175 4 1175 44
  
  let%span stheory4 = "/Users/xavier/Code/cdsat/src/theory.rs" 1176 4 1176 38
  
  let%span stheory5 = "/Users/xavier/Code/cdsat/src/theory.rs" 1177 4 1177 46
  
  let%span stheory6 = "/Users/xavier/Code/cdsat/src/theory.rs" 486 15 486 31
  
  let%span stheory7 = "/Users/xavier/Code/cdsat/src/theory.rs" 487 15 487 35
  
  let%span stheory8 = "/Users/xavier/Code/cdsat/src/theory.rs" 488 15 488 27
  
  let%span stheory9 = "/Users/xavier/Code/cdsat/src/theory.rs" 489 4 489 54
  
  let%span stheory10 = "/Users/xavier/Code/cdsat/src/theory.rs" 490 4 490 58
  
  let%span stheory11 = "/Users/xavier/Code/cdsat/src/theory.rs" 491 4 491 61
  
  let%span stheory12 = "/Users/xavier/Code/cdsat/src/theory.rs" 406 15 406 38
  
  let%span stheory13 = "/Users/xavier/Code/cdsat/src/theory.rs" 407 14 407 51
  
  let%span stheory14 = "/Users/xavier/Code/cdsat/src/theory.rs" 1183 8 1190 11
  
  let%span stheory15 = "/Users/xavier/Code/cdsat/src/theory.rs" 96 15 96 29
  
  let%span stheory16 = "/Users/xavier/Code/cdsat/src/theory.rs" 97 14 97 30
  
  let%span stheory17 = "/Users/xavier/Code/cdsat/src/theory.rs" 597 14 597 25
  
  let%span stheory18 = "/Users/xavier/Code/cdsat/src/theory.rs" 598 14 598 34
  
  let%span span19 = "/Users/xavier/Code/cdsat/src/theory.rs" 88 8 91 9
  
  let%span span20 = "/Users/xavier/Code/cdsat/src/theory.rs" 157 8 159 9
  
  let%span span21 = "/Users/xavier/Code/cdsat/src/theory.rs" 610 14 610 25
  
  let%span span22 = "/Users/xavier/Code/cdsat/src/theory.rs" 612 8 615 9
  
  let%span span23 = "/Users/xavier/Code/cdsat/src/theory.rs" 82 8 82 36
  
  let%span span24 = "/Users/xavier/Code/cdsat/src/theory.rs" 99 8 102 9
  
  let%span span25 = "/Users/xavier/Code/cdsat/src/theory.rs" 601 8 605 9
  
  let%span span26 = "/Users/xavier/Code/cdsat/src/theory.rs" 337 8 340 9
  
  let%span span27 = "/Users/xavier/Code/cdsat/src/theory.rs" 17 8 25 9
  
  let%span span28 = "/Users/xavier/Code/cdsat/src/theory.rs" 122 8 126 9
  
  let%span span29 = "/Users/xavier/Code/cdsat/src/theory.rs" 346 8 349 9
  
  let%span span30 = "/Users/xavier/Code/cdsat/src/theory.rs" 132 8 136 9
  
  let%span span31 = "/Users/xavier/Code/cdsat/src/theory.rs" 465 14 468 5
  
  let%span span32 = "/Users/xavier/Code/cdsat/src/theory.rs" 469 4 469 111
  
  let%span span33 = "/Users/xavier/Code/cdsat/src/theory.rs" 470 4 470 104
  
  let%span span34 = "/Users/xavier/Code/cdsat/src/theory.rs" 472 8 481 9
  
  let%span span35 = "/Users/xavier/Code/cdsat/src/theory.rs" 409 8 412 9
  
  let%span span36 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 16 8 16 26
  
  let%span span37 = "/Users/xavier/Code/cdsat/src/theory.rs" 417 4 417 87
  
  let%span span38 = "/Users/xavier/Code/cdsat/src/theory.rs" 419 8 422 9
  
  let%span span39 = "/Users/xavier/Code/cdsat/src/theory.rs" 374 8 382 9
  
  let%span span40 = "/Users/xavier/Code/cdsat/src/theory.rs" 355 8 368 9
  
  let%span span41 = "/Users/xavier/Code/creusot/creusot-contracts/src/logic/fset.rs" 53 8 53 26
  
  let%span span42 = "/Users/xavier/Code/cdsat/src/theory.rs" 281 15 281 38
  
  let%span span43 = "/Users/xavier/Code/cdsat/src/theory.rs" 282 4 282 74
  
  let%span span44 = "/Users/xavier/Code/cdsat/src/theory.rs" 283 4 283 94
  
  let%span span45 = "/Users/xavier/Code/cdsat/src/theory.rs" 284 4 284 48
  
  let%span span46 = "/Users/xavier/Code/cdsat/src/theory.rs" 285 14 285 25
  
  let%span span47 = "/Users/xavier/Code/cdsat/src/theory.rs" 286 14 286 36
  
  let%span span48 = "/Users/xavier/Code/cdsat/src/theory.rs" 280 14 280 21
  
  let%span span49 = "/Users/xavier/Code/cdsat/src/theory.rs" 278 4 278 12
  
  let%span span50 = "/Users/xavier/Code/cdsat/src/theory.rs" 321 8 331 9
  
  let%span span51 = "/Users/xavier/Code/cdsat/src/theory.rs" 388 8 392 38
  
  let%span span52 = "/Users/xavier/Code/cdsat/src/theory.rs" 741 15 741 31
  
  let%span span53 = "/Users/xavier/Code/cdsat/src/theory.rs" 742 4 742 83
  
  let%span span54 = "/Users/xavier/Code/cdsat/src/theory.rs" 744 8 749 9
  
  let%span span55 = "/Users/xavier/Code/cdsat/src/theory.rs" 562 8 573 9
  
  let%span span56 = "/Users/xavier/Code/cdsat/src/theory.rs" 1002 4 1002 12
  
  let%span span57 = "/Users/xavier/Code/cdsat/src/theory.rs" 514 8 517 9
  
  let%span span58 = "/Users/xavier/Code/cdsat/src/theory.rs" 524 8 527 9
  
  let%span span59 = "/Users/xavier/Code/cdsat/src/theory.rs" 167 18 167 22
  
  let%span span60 = "/Users/xavier/Code/cdsat/src/theory.rs" 166 4 166 62
  
  let%span span61 = "/Users/xavier/Code/cdsat/src/theory.rs" 168 8 188 9
  
  let%span span62 = "/Users/xavier/Code/cdsat/src/theory.rs" 194 8 194 31
  
  let%span span63 = "/Users/xavier/Code/cdsat/src/theory.rs" 200 8 200 71
  
  let%span span64 = "/Users/xavier/Code/cdsat/src/theory.rs" 206 8 206 84
  
  let%span span65 = "/Users/xavier/Code/cdsat/src/theory.rs" 142 8 147 9
  
  let%span span66 = "/Users/xavier/Code/cdsat/src/theory.rs" 262 8 265 9
  
  let%span span67 = "/Users/xavier/Code/cdsat/src/theory.rs" 619 15 619 27
  
  let%span span68 = "/Users/xavier/Code/cdsat/src/theory.rs" 620 15 620 32
  
  let%span span69 = "/Users/xavier/Code/cdsat/src/theory.rs" 621 4 621 90
  
  let%span span70 = "/Users/xavier/Code/cdsat/src/theory.rs" 623 8 632 9
  
  let%span span71 = "/Users/xavier/Code/cdsat/src/theory.rs" 504 8 507 9
  
  let%span span72 = "/Users/xavier/Code/cdsat/src/theory.rs" 493 8 493 30
  
  let%span span73 = "/Users/xavier/Code/cdsat/src/theory.rs" 107 15 107 29
  
  let%span span74 = "/Users/xavier/Code/cdsat/src/theory.rs" 108 14 108 44
  
  let%span span75 = "/Users/xavier/Code/cdsat/src/theory.rs" 105 4 105 12
  
  let%span span76 = "/Users/xavier/Code/cdsat/src/theory.rs" 787 15 787 31
  
  let%span span77 = "/Users/xavier/Code/cdsat/src/theory.rs" 788 15 788 31
  
  let%span span78 = "/Users/xavier/Code/cdsat/src/theory.rs" 789 4 789 30
  
  let%span span79 = "/Users/xavier/Code/cdsat/src/theory.rs" 790 14 790 49
  
  let%span span80 = "/Users/xavier/Code/cdsat/src/theory.rs" 792 8 801 9
  
  let%span span81 = "/Users/xavier/Code/cdsat/src/theory.rs" 754 15 754 25
  
  let%span span82 = "/Users/xavier/Code/cdsat/src/theory.rs" 755 15 755 31
  
  let%span span83 = "/Users/xavier/Code/cdsat/src/theory.rs" 756 15 756 31
  
  let%span span84 = "/Users/xavier/Code/cdsat/src/theory.rs" 757 15 757 39
  
  let%span span85 = "/Users/xavier/Code/cdsat/src/theory.rs" 758 14 758 47
  
  let%span span86 = "/Users/xavier/Code/cdsat/src/theory.rs" 760 8 769 9
  
  let%span span87 = "/Users/xavier/Code/cdsat/src/theory.rs" 705 15 705 27
  
  let%span span88 = "/Users/xavier/Code/cdsat/src/theory.rs" 706 14 706 42
  
  let%span span89 = "/Users/xavier/Code/cdsat/src/theory.rs" 708 8 713 9
  
  let%span span90 = "/Users/xavier/Code/cdsat/src/theory.rs" 678 8 678 71
  
  let%span span91 = "/Users/xavier/Code/cdsat/src/theory.rs" 685 8 685 82
  
  let%span span92 = "/Users/xavier/Code/cdsat/src/theory.rs" 696 4 696 55
  
  let%span span93 = "/Users/xavier/Code/cdsat/src/theory.rs" 698 8 698 108
  
  let%span span94 = "/Users/xavier/Code/cdsat/src/theory.rs" 826 4 826 16
  
  let%span span95 = "/Users/xavier/Code/cdsat/src/theory.rs" 999 8 999 91
  
  let%span span96 = "/Users/xavier/Code/cdsat/src/theory.rs" 992 8 992 131
  
  use Cdsat_Theory_Sort_Type as Sort'0
  
  use Cdsat_Theory_Value_Type as Value'0
  
  function sort'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 87 4 87 29] (self : Value'0.t_value) : Sort'0.t_sort =
    [%#span19] match self with
      | Value'0.C_Bool _ -> Sort'0.C_Boolean
      | Value'0.C_Rat _ -> Sort'0.C_Rational
      end
  
  use Cdsat_Theory_Var_Type as Cdsat_Theory_Var_Type
  
  use map.Map
  
  use Cdsat_Theory_Model_Type as Cdsat_Theory_Model_Type
  
  use Cdsat_Theory_Var_Type as Var'0
  
  use Cdsat_Theory_Model_Type as Model'0
  
  predicate invariant'2 [#"/Users/xavier/Code/cdsat/src/theory.rs" 156 4 156 30] (self : Model'0.t_model) =
    [%#span20] forall v : Value'0.t_value . forall k : Var'0.t_var . Map.get (Cdsat_Theory_Model_Type.model_0 self) k
    = v  -> Cdsat_Theory_Var_Type.var_1 k = sort'0 v
  
  predicate inv'0 (_x : Model'0.t_model)
  
  axiom inv'0 : forall x : Model'0.t_model . inv'0 x
  = (invariant'2 x
  /\ match x with
    | Model'0.C_Model a_0 -> true
    end)
  
  use Cdsat_Theory_Trail_Type as Trail'0
  
  use prelude.prelude.Int
  
  function len'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 611 4 611 27] (self : Trail'0.t_trail) : int =
    [%#span22] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign _ _ tl -> len'0 tl + 1
      end
  
  axiom len'0_spec : forall self : Trail'0.t_trail . [%#span21] len'0 self >= 0
  
  use Cdsat_Theory_Assign_Type as Assign'0
  
  predicate is_bool'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 81 4 81 32] (self : Value'0.t_value) =
    [%#span23] sort'0 self = Sort'0.C_Boolean
  
  function negate'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 98 4 98 31] (self : Value'0.t_value) : Value'0.t_value =
    [%#span24] match self with
      | Value'0.C_Bool b -> Value'0.C_Bool (not b)
      | _ -> self
      end
  
  axiom negate'0_spec : forall self : Value'0.t_value . ([%#stheory15] is_bool'0 self)
   -> ([%#stheory16] is_bool'0 (negate'0 self))
  
  function level'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 600 4 600 29] (self : Trail'0.t_trail) : int =
    [%#span25] match self with
      | Trail'0.C_Empty -> 0
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> 1 + level'1 tl
      | Trail'0.C_Assign _ _ tl -> level'1 tl
      end
  
  axiom level'1_spec : forall self : Trail'0.t_trail . ([%#stheory18] level'1 self <= len'0 self)
  && ([%#stheory17] level'1 self >= 0)
  
  predicate invariant_nonneg'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 336 4 336 41] (self : Trail'0.t_trail) =
    [%#span26] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_nonneg'0 tl /\ l >= 0 /\ l <= level'1 self
      end
  
  use prelude.prelude.Int
  
  use Cdsat_Theory_Term_Type as Term'0
  
  function sort'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 16 4 16 29] (self : Term'0.t_term) : Sort'0.t_sort =
    [%#span27] match self with
      | Term'0.C_Variable v -> Cdsat_Theory_Var_Type.var_1 v
      | Term'0.C_Value v -> sort'0 v
      | Term'0.C_Plus _ _ -> Sort'0.C_Rational
      | Term'0.C_Eq _ _ -> Sort'0.C_Boolean
      | Term'0.C_Conj _ _ -> Sort'0.C_Boolean
      | Term'0.C_Neg _ -> Sort'0.C_Boolean
      | Term'0.C_Disj _ _ -> Sort'0.C_Boolean
      end
  
  predicate invariant'3 [#"/Users/xavier/Code/cdsat/src/theory.rs" 121 4 121 34] (self : Assign'0.t_assign) =
    [%#span28] match self with
      | Assign'0.C_Decision t v -> sort'1 t = sort'0 v
      | Assign'0.C_Justified _ t v -> sort'1 t = sort'0 v /\ sort'1 t = Sort'0.C_Boolean
      | Assign'0.C_Input t v -> sort'1 t = sort'0 v
      end
  
  predicate invariant_assign'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 345 4 345 41] (self : Trail'0.t_trail) =
    [%#span29] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_assign'0 tl /\ invariant'3 a
      end
  
  function to_pair'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 131 4 131 41] (self : Assign'0.t_assign) : (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span30] match self with
      | Assign'0.C_Decision t val' -> (t, val')
      | Assign'0.C_Input t val' -> (t, val')
      | Assign'0.C_Justified _ t val' -> (t, val')
      end
  
  use Core_Option_Option_Type as Option'0
  
  function find'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 471 4 471 64] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Option'0.t_option (Assign'0.t_assign, int)
    
   =
    [%#span34] match self with
      | Trail'0.C_Empty -> Option'0.C_None
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then Option'0.C_Some (a, l) else find'0 tl d
      end
  
  axiom find'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span33] invariant_assign'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> sort'1 (let (a, _) = d in a) = sort'0 (let (_, a) = d in a)))
  && ([%#span32] invariant_nonneg'0 self
   -> (forall p : (Assign'0.t_assign, int) . find'0 self d = Option'0.C_Some p
   -> (let (_, a) = p in a) >= 0 /\ (let (_, a) = p in a) <= level'1 self))
  && ([%#span31] match find'0 self d with
    | Option'0.C_Some (a, l) -> to_pair'0 a = d
    | _ -> true
    end)
  
  function level_of'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 408 4 408 50] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : int
    
   =
    [%#span35] match find'0 self d with
      | Option'0.C_Some (_, l) -> l
      | Option'0.C_None -> 0
      end
  
  axiom level_of'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#stheory12] invariant_nonneg'0 self)
   -> ([%#stheory13] level_of'0 self d >= 0 /\ level_of'0 self d <= level'1 self)
  
  use set.Fset
  
  use set.Fset
  
  predicate contains'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (e : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span36] Fset.mem e self
  
  predicate contains'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 418 4 418 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span38] match find'0 self d with
      | Option'0.C_Some ix -> true
      | Option'0.C_None -> false
      end
  
  axiom contains'1_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . [%#span37] invariant_assign'0 self
   -> contains'1 self d = true  -> sort'1 (let (a, _) = d in a) = sort'0 (let (_, a) = d in a)
  
  predicate trail_unique'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 373 4 373 37] (self : Trail'0.t_trail) =
    [%#span39] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> let ap = to_pair'0 a in not contains'1 tl ap
      /\ trail_unique'0 tl
      /\ (if is_bool'0 (let (_, a) = ap in a) then
        not contains'1 tl ((let (a, _) = ap in a), negate'0 (let (_, a) = ap in a))
      else
        true
      )
      end
  
  predicate invariant_contains'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 354 4 354 43] (self : Trail'0.t_trail) =
    [%#span40] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_contains'0 tl
      /\ match a with
        | Assign'0.C_Justified j _ _ -> forall a : (Term'0.t_term, Value'0.t_value) . contains'0 j a  -> contains'1 tl a
        | _ -> true
        end
      end
  
  use set.Fset
  
  function remove'0 [@inline:trivial] (self : Fset.fset (Term'0.t_term, Value'0.t_value)) (a : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span41] Fset.remove a self
  
  use set.Fset
  
  use set.Fset
  
  use set.Fset
  
  function set_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 287 4 287 57] (self : Trail'0.t_trail) (s : Fset.fset (Term'0.t_term, Value'0.t_value)) : int
    
  
  axiom set_level'0_def : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . set_level'0 self s
  = ([%#span49] if Fset.cardinal s = 0 then
    0
  else
    if Fset.cardinal s = 1 then
      level_of'0 self (Fset.pick s)
    else
      let a = Fset.pick s in let rec' = set_level'0 self (remove'0 s a) in if level_of'0 self a >= rec' then
        level_of'0 self a
      else
        rec'
      
    
  )
  
  axiom set_level'0_spec : forall self : Trail'0.t_trail, s : Fset.fset (Term'0.t_term, Value'0.t_value) . ([%#span42] invariant_nonneg'0 self)
   -> ([%#span47] set_level'0 self s <= level'1 self)
  && ([%#span46] set_level'0 self s >= 0)
  && ([%#span45] s = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))  -> set_level'0 self s = 0)
  && ([%#span44] s <> (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value))
   -> (exists i : (Term'0.t_term, Value'0.t_value) . contains'0 s i /\ level_of'0 self i = set_level'0 self s))
  && ([%#span43] forall i : (Term'0.t_term, Value'0.t_value) . contains'0 s i
   -> level_of'0 self i <= set_level'0 self s)
  
  predicate invariant_level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 320 4 320 40] (self : Trail'0.t_trail) =
    [%#span50] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a l tl -> invariant_level'0 tl
      /\ match a with
        | Assign'0.C_Input _ _ -> l = 0
        | Assign'0.C_Decision _ _ -> level'1 tl + 1 = l
        | Assign'0.C_Justified j _ _ -> set_level'0 tl j = l
        end
      end
  
  predicate invariant'1 [#"/Users/xavier/Code/cdsat/src/theory.rs" 387 4 387 34] (self : Trail'0.t_trail) =
    [%#span51] invariant_level'0 self
    /\ invariant_contains'0 self /\ trail_unique'0 self /\ invariant_nonneg'0 self /\ invariant_assign'0 self
  
  function count_bounds'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 743 4 743 35] (self : Trail'0.t_trail) : () =
    [%#span54] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign (Assign'0.C_Input _ _) _ tl -> count_bounds'0 tl
      | Trail'0.C_Assign (Assign'0.C_Decision _ _) _ tl -> count_bounds'0 tl
      | Trail'0.C_Assign (Assign'0.C_Justified _ _ _) _ tl -> count_bounds'0 tl
      end
  
  axiom count_bounds'0_spec : forall self : Trail'0.t_trail . ([%#span52] invariant'1 self)
   -> ([%#span53] forall a : (Term'0.t_term, Value'0.t_value) . contains'1 self a  -> level_of'0 self a <= level'1 self)
  
  function restrict'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 561 4 561 45] (self : Trail'0.t_trail) (level : int) : Trail'0.t_trail
    
   =
    [%#span55] match self with
      | Trail'0.C_Empty -> Trail'0.C_Empty
      | Trail'0.C_Assign a l tl -> let tl = restrict'0 tl level in let _ = count_bounds'0 tl in if l <= level then
        Trail'0.C_Assign a l tl
      else
        tl
      
      end
  
  use Cdsat_Theory_Conflict_Type as Cdsat_Theory_Conflict_Type
  
  use Cdsat_Theory_Conflict_Type as Conflict'0
  
  function level'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 1004 4 1004 29] (self : Conflict'0.t_conflict) : int =
    [%#span56] set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (Cdsat_Theory_Conflict_Type.conflict_1 self)
  
  predicate is_decision'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 513 4 513 54] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span57] match find'0 self d with
      | Option'0.C_Some (Assign'0.C_Decision _ _, _) -> true
      | _ -> false
      end
  
  predicate is_input'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 523 4 523 51] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span58] match find'0 self d with
      | Option'0.C_Some (Assign'0.C_Input _ _, _) -> true
      | _ -> false
      end
  
  use prelude.prelude.Real
  
  function from_int'0 (_1 : int) : Real.real
  
  function interp'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 167 4 167 41] (self : Model'0.t_model) (t : Term'0.t_term) : Value'0.t_value
    
   =
    [%#span61] match t with
      | Term'0.C_Variable v -> Map.get (Cdsat_Theory_Model_Type.model_0 self) v
      | Term'0.C_Value v -> v
      | Term'0.C_Plus l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Rat r1, Value'0.C_Rat r2) -> Value'0.C_Rat r1
        | _ -> Value'0.C_Rat (from_int'0 (- 1))
        end
      | Term'0.C_Conj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 /\ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Disj l r -> match (interp'0 self l, interp'0 self r) with
        | (Value'0.C_Bool b1, Value'0.C_Bool b2) -> Value'0.C_Bool (b1 \/ b2)
        | _ -> Value'0.C_Bool false
        end
      | Term'0.C_Eq l r -> Value'0.C_Bool (interp'0 self l = interp'0 self r)
      | Term'0.C_Neg t -> match interp'0 self t with
        | Value'0.C_Bool b -> Value'0.C_Bool (not b)
        | _ -> Value'0.C_Bool false
        end
      end
  
  axiom interp'0_spec : forall self : Model'0.t_model, t : Term'0.t_term . ([%#span59] inv'0 self)
   -> ([%#span60] invariant'2 self  -> sort'0 (interp'0 self t) = sort'1 t)
  
  predicate satisfies'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 193 4 193 52] (self : Model'0.t_model) (v : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span62] interp'0 self (let (a, _) = v in a) = (let (_, a) = v in a)
  
  predicate satisfy_set'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 199 4 199 60] (self : Model'0.t_model) (v : Fset.fset (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span63] forall a : (Term'0.t_term, Value'0.t_value) . contains'0 v a  -> satisfies'0 self a
  
  predicate entails'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 205 4 205 74] (self : Model'0.t_model) (j : Fset.fset (Term'0.t_term, Value'0.t_value)) (c : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span64] invariant'2 self  -> satisfy_set'0 self j  -> satisfies'0 self c
  
  predicate justified_sound'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 141 4 141 40] (self : Assign'0.t_assign) =
    [%#span65] match self with
      | Assign'0.C_Justified just t val' -> forall m : Model'0.t_model . inv'0 m
       -> satisfy_set'0 m just  -> satisfies'0 m (t, val')
      | _ -> true
      end
  
  predicate sound'2 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 261 4 261 30] (self : Trail'0.t_trail)
   =
    [%#span66] match self with
      | Trail'0.C_Empty -> true
      | Trail'0.C_Assign a _ tl -> sound'2 tl /\ justified_sound'0 a
      end
  
  function find_justified'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 622 4 622 46] (self : Trail'0.t_trail) (kv : (Term'0.t_term, Value'0.t_value)) : ()
    
   =
    [%#span70] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = kv then () else find_justified'0 tl kv
      end
  
  axiom find_justified'0_spec : forall self : Trail'0.t_trail, kv : (Term'0.t_term, Value'0.t_value) . ([%#span67] sound'2 self)
   -> ([%#span68] contains'1 self kv)
   -> ([%#span69] forall l : int . forall a : Assign'0.t_assign . find'0 self kv = Option'0.C_Some (a, l)
   -> justified_sound'0 a)
  
  predicate is_justified'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 503 4 503 55] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value))
    
   =
    [%#span71] match find'0 self d with
      | Option'0.C_Some (Assign'0.C_Justified _ _ _, _) -> true
      | _ -> false
      end
  
  function justification'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 492 4 492 71] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : Fset.fset (Term'0.t_term, Value'0.t_value)
    
   =
    [%#span72] let _ = find_justified'0 self d in match find'0 self d with
      | Option'0.C_Some (Assign'0.C_Justified j _ _, _) -> j
      | _ -> Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value)
      end
  
  axiom justification'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#stheory6] invariant'1 self)
   -> ([%#stheory7] is_justified'0 self d)
   -> ([%#stheory8] sound'2 self)
   -> ([%#stheory11] is_decision'0 self d
   -> justification'0 self d = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value)))
  && ([%#stheory10] is_input'0 self d
   -> justification'0 self d = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value)))
  && ([%#stheory9] forall m : Model'0.t_model . inv'0 m  -> entails'0 m (justification'0 self d) d)
  
  function negate_involutive'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 109 4 109 34] (self : Value'0.t_value) : () =
    [%#span75] ()
  
  axiom negate_involutive'0_spec : forall self : Value'0.t_value . ([%#span73] is_bool'0 self)
   -> ([%#span74] negate'0 (negate'0 self) = self)
  
  function trail_plausible'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 791 4 791 50] (self : Trail'0.t_trail) (d : (Term'0.t_term, Value'0.t_value)) : ()
    
   =
    [%#span80] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then () else let _ = trail_plausible'0 tl d in ()
      end
  
  axiom trail_plausible'0_spec : forall self : Trail'0.t_trail, d : (Term'0.t_term, Value'0.t_value) . ([%#span76] invariant'1 self)
   -> ([%#span77] contains'1 self d)
   -> ([%#span78] is_bool'0 (let (_, a) = d in a))
   -> ([%#span79] not contains'1 self ((let (a, _) = d in a), negate'0 (let (_, a) = d in a)))
  
  function restrict_too_big'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 759 4 759 63] (self : Trail'0.t_trail) (level : int) (d : (Term'0.t_term, Value'0.t_value)) : ()
    
   =
    [%#span86] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign a l tl -> if to_pair'0 a = d then () else let _ = restrict_too_big'0 tl level d in ()
      end
  
  axiom restrict_too_big'0_spec : forall self : Trail'0.t_trail, level : int, d : (Term'0.t_term, Value'0.t_value) . ([%#span81] level
  >= 0)
   -> ([%#span82] invariant'1 self)
   -> ([%#span83] contains'1 self d)
   -> ([%#span84] level < level_of'0 self d)  -> ([%#span85] not contains'1 (restrict'0 self level) d)
  
  function restrict_sound'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 707 4 707 43] (self : Trail'0.t_trail) (level : int) : ()
    
   =
    [%#span89] match self with
      | Trail'0.C_Empty -> ()
      | Trail'0.C_Assign a l tl -> let _ = restrict_sound'0 tl level in ()
      end
  
  axiom restrict_sound'0_spec : forall self : Trail'0.t_trail, level : int . ([%#span87] sound'2 self)
   -> ([%#span88] sound'2 (restrict'0 self level))
  
  use Cdsat_Theory_Normal_Type as Normal'0
  
  predicate satisfied_by'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 677 4 677 47] (self : Trail'0.t_trail) (m : Model'0.t_model)
    
   =
    [%#span90] forall a : (Term'0.t_term, Value'0.t_value) . contains'1 self a  -> satisfies'0 m a
  
  predicate unsat'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 684 4 684 30] (self : Trail'0.t_trail) =
    [%#span91] forall m : Model'0.t_model . inv'0 m  -> satisfied_by'0 (restrict'0 self 0) m  -> false
  
  predicate impls'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 697 4 697 41] (self : Trail'0.t_trail) (rhs : Trail'0.t_trail)
    
   =
    [%#span93] forall m : Model'0.t_model . inv'0 m
     -> satisfied_by'0 (restrict'0 self 0) m  -> satisfied_by'0 (restrict'0 rhs 0) m
  
  axiom impls'0_spec : forall self : Trail'0.t_trail, rhs : Trail'0.t_trail . [%#span92] impls'0 self rhs
   -> unsat'0 rhs  -> unsat'0 self
  
  use Cdsat_Theory_Normal_Type as Cdsat_Theory_Normal_Type
  
  predicate sound'1 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 829 4 829 30] (self : Normal'0.t_normal)
    
   =
    [%#span94] sound'2 (Cdsat_Theory_Normal_Type.normal_0 self)
  
  predicate sound'0 [@inline:trivial] [#"/Users/xavier/Code/cdsat/src/theory.rs" 998 4 998 30] (self : Conflict'0.t_conflict)
    
   =
    [%#span95] sound'2 (Cdsat_Theory_Conflict_Type.conflict_0 self)
    /\ (forall m : Model'0.t_model . inv'0 m  -> satisfy_set'0 m (Cdsat_Theory_Conflict_Type.conflict_1 self)  -> false)
  
  predicate invariant'0 [#"/Users/xavier/Code/cdsat/src/theory.rs" 991 4 991 34] (self : Conflict'0.t_conflict) =
    [%#span96] set_level'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (Cdsat_Theory_Conflict_Type.conflict_1 self) > 0
    /\ invariant'1 (Cdsat_Theory_Conflict_Type.conflict_0 self)
    /\ (forall a : (Term'0.t_term, Value'0.t_value) . contains'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) a
     -> contains'1 (Cdsat_Theory_Conflict_Type.conflict_0 self) a)
  
  constant self  : Conflict'0.t_conflict
  
  constant l  : (Term'0.t_term, Value'0.t_value)
  
  constant tgt  : Normal'0.t_normal
  
  predicate undo_decide [#"/Users/xavier/Code/cdsat/src/theory.rs" 1178 4 1178 67] (self : Conflict'0.t_conflict) (l : (Term'0.t_term, Value'0.t_value)) (tgt : Normal'0.t_normal)
    
  
  goal vc_undo_decide : ([%#stheory2] is_justified'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) l)
   -> ([%#stheory1] sound'0 self)
   -> ([%#stheory0] invariant'0 self)
   -> (let _ = restrict_sound'0 in let _ = restrict_too_big'0 in let _ = trail_plausible'0 in let _ = negate_involutive'0 in (([%#stheory8] sound'2 (Cdsat_Theory_Conflict_Type.conflict_0 self))
  && ([%#stheory7] is_justified'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) l)
  && ([%#stheory6] invariant'1 (Cdsat_Theory_Conflict_Type.conflict_0 self)))
  /\ (([%#stheory11] is_decision'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) l
   -> justification'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) l
  = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value)))
  && ([%#stheory10] is_input'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) l
   -> justification'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) l
  = (Fset.empty  : Fset.fset (Term'0.t_term, Value'0.t_value)))
  && ([%#stheory9] forall m : Model'0.t_model . inv'0 m
   -> entails'0 m (justification'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) l) l)
   -> (let just = justification'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) l in let e = remove'0 (Cdsat_Theory_Conflict_Type.conflict_1 self) l in let restr = restrict'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (level'0 self
  - 1) in if is_bool'0 (let (_, a) = l in a) then
    (forall a : (Term'0.t_term, Value'0.t_value) . if contains'0 just a then
      if not is_bool'0 (let (_, a) = a in a) then
        [%#stheory12] invariant_nonneg'0 (Cdsat_Theory_Conflict_Type.conflict_0 self)
      else
        true
      
    else
      true
    )
    /\ (if [%#stheory14] exists a : (Term'0.t_term, Value'0.t_value) . contains'0 just a
    /\ not is_bool'0 (let (_, a) = a in a)
    /\ level_of'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) a = level'0 self then
      ([%#stheory12] invariant_nonneg'0 (Cdsat_Theory_Conflict_Type.conflict_0 self))
      /\ (([%#stheory13] level_of'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) l >= 0
      /\ level_of'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) l
      <= level'1 (Cdsat_Theory_Conflict_Type.conflict_0 self))
       -> (if level'0 self = level_of'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) l then
        ([%#stheory15] is_bool'0 (let (_, a) = l in a))
        /\ (([%#stheory16] is_bool'0 (negate'0 (let (_, a) = l in a)))
         -> ([%#stheory18] level'1 restr <= len'0 restr) && ([%#stheory17] level'1 restr >= 0)
         -> (let result = Cdsat_Theory_Normal_Type.normal_0 tgt
        = Trail'0.C_Assign (Assign'0.C_Decision (let (a, _) = l in a) (negate'0 (let (_, a) = l in a))) (level'1 restr
        + 1) restr in ([%#stheory5] result
         -> impls'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (Cdsat_Theory_Normal_Type.normal_0 tgt))
        && ([%#stheory4] result  -> sound'1 tgt)
        && ([%#stheory3] result  -> invariant'1 (Cdsat_Theory_Normal_Type.normal_0 tgt))))
      else
        let result = false in ([%#stheory5] result
         -> impls'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (Cdsat_Theory_Normal_Type.normal_0 tgt))
        && ([%#stheory4] result  -> sound'1 tgt)
        && ([%#stheory3] result  -> invariant'1 (Cdsat_Theory_Normal_Type.normal_0 tgt))
      ))
    else
      let result = false in ([%#stheory5] result
       -> impls'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (Cdsat_Theory_Normal_Type.normal_0 tgt))
      && ([%#stheory4] result  -> sound'1 tgt)
      && ([%#stheory3] result  -> invariant'1 (Cdsat_Theory_Normal_Type.normal_0 tgt))
    )
  else
    let result = false in ([%#stheory5] result
     -> impls'0 (Cdsat_Theory_Conflict_Type.conflict_0 self) (Cdsat_Theory_Normal_Type.normal_0 tgt))
    && ([%#stheory4] result  -> sound'1 tgt)
    && ([%#stheory3] result  -> invariant'1 (Cdsat_Theory_Normal_Type.normal_0 tgt))
  )))
end
module Cdsat_Theory_Impl3
  
end
